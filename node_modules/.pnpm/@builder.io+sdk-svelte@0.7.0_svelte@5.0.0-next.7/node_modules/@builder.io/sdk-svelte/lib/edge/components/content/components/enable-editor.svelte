<script context="module"></script>

<script>import { onDestroy, onMount, setContext } from "svelte";
import { evaluate } from "../../../functions/evaluate/index.js";
import { fetch } from "../../../functions/get-fetch.js";
import { isBrowser } from "../../../functions/is-browser.js";
import { isEditing } from "../../../functions/is-editing.js";
import { createRegisterComponentMessage } from "../../../functions/register-component.js";
import { _track } from "../../../functions/track/index.js";
import builderContext from "../../../context/builder.context.js";
import { registerInsertMenu, setupBrowserForEditing, } from "../../../scripts/init-editing.js";
import { getInteractionPropertiesForEvent } from "../../../functions/track/interaction.js";
import { fetchOneEntry } from "../../../functions/get-content/index.js";
import { isPreviewing } from "../../../functions/is-previewing.js";
import "../../../helpers/preview-lru-cache/set.js";
import { fastClone } from "../../../functions/fast-clone.js";
import { logger } from "../../../helpers/logger.js";
import { getDefaultCanTrack } from "../../../helpers/canTrack.js";
export let builderContextSignal;
export let model = undefined;
export let context = undefined;
export let canTrack = undefined;
export let apiKey;
export let showContent;
export let classNameProp;
export let content = undefined;
export let locale = undefined;
export let includeRefs = undefined;
export let enrich = undefined;
function mergeNewContent(newContent) {
    const newContentValue = {
        ...$builderContextSignal.content,
        ...newContent,
        data: {
            ...$builderContextSignal.content?.data,
            ...newContent?.data,
        },
        meta: {
            ...$builderContextSignal.content?.meta,
            ...newContent?.meta,
            breakpoints: newContent?.meta?.breakpoints ||
                $builderContextSignal.content?.meta?.breakpoints,
        },
    };
    $builderContextSignal.content = newContentValue;
}
function processMessage(event) {
    const { data } = event;
    if (data) {
        switch (data.type) {
            case "builder.configureSdk": {
                const messageContent = data.data;
                const { breakpoints, contentId } = messageContent;
                if (!contentId || contentId !== $builderContextSignal.content?.id) {
                    return;
                }
                if (breakpoints) {
                    mergeNewContent({
                        meta: {
                            breakpoints,
                        },
                    });
                }
                forceReRenderCount = forceReRenderCount + 1; // This is a hack to force Qwik to re-render.
                break;
            }
            case "builder.contentUpdate": {
                const messageContent = data.data;
                const key = messageContent.key ||
                    messageContent.alias ||
                    messageContent.entry ||
                    messageContent.modelName;
                const contentData = messageContent.data;
                if (key === model) {
                    mergeNewContent(contentData);
                    forceReRenderCount = forceReRenderCount + 1; // This is a hack to force Qwik to re-render.
                }
                break;
            }
        }
    }
}
function evaluateJsCode() {
    // run any dynamic JS code attached to content
    const jsCode = $builderContextSignal.content?.data?.jsCode;
    if (jsCode) {
        evaluate({
            code: jsCode,
            context: context || {},
            localState: undefined,
            rootState: $builderContextSignal.rootState,
            rootSetState: $builderContextSignal.rootSetState,
        });
    }
}
function onClick(event) {
    if ($builderContextSignal.content) {
        const variationId = $builderContextSignal.content?.testVariationId;
        const contentId = $builderContextSignal.content?.id;
        _track({
            type: "click",
            canTrack: getDefaultCanTrack(canTrack),
            contentId,
            apiKey: apiKey,
            variationId: variationId !== contentId ? variationId : undefined,
            ...getInteractionPropertiesForEvent(event),
            unique: !clicked,
        });
    }
    if (!clicked) {
        clicked = true;
    }
}
function evalExpression(expression) {
    return expression.replace(/{{([^}]+)}}/g, (_match, group) => evaluate({
        code: group,
        context: context || {},
        localState: undefined,
        rootState: $builderContextSignal.rootState,
        rootSetState: $builderContextSignal.rootSetState,
    }));
}
function handleRequest({ url, key }) {
    fetch(url)
        .then((response) => response.json())
        .then((json) => {
        const newState = {
            ...$builderContextSignal.rootState,
            [key]: json,
        };
        $builderContextSignal.rootSetState?.(newState);
        httpReqsData[key] = true;
    })
        .catch((err) => {
        console.error("error fetching dynamic data", url, err);
    });
}
function runHttpRequests() {
    const requests = $builderContextSignal.content?.data?.httpRequests ?? {};
    Object.entries(requests).forEach(([key, url]) => {
        if (url && (!httpReqsData[key] || isEditing())) {
            const evaluatedUrl = evalExpression(url);
            handleRequest({
                url: evaluatedUrl,
                key,
            });
        }
    });
}
function emitStateUpdate() {
    if (isEditing()) {
        window.dispatchEvent(new CustomEvent("builder:component:stateChange", {
            detail: {
                state: fastClone($builderContextSignal.rootState),
                ref: {
                    name: model,
                },
            },
        }));
    }
}
let elementRef;
let forceReRenderCount = 0;
let lastUpdated = 0;
let shouldSendResetCookie = false;
let httpReqsData = {};
let clicked = false;
onMount(() => {
    if (!apiKey) {
        logger.error("No API key provided to `RenderContent` component. This can cause issues. Please provide an API key using the `apiKey` prop.");
    }
    if (isBrowser()) {
        if (isEditing()) {
            forceReRenderCount = forceReRenderCount + 1;
            window.addEventListener("message", processMessage);
            registerInsertMenu();
            setupBrowserForEditing({
                ...(locale
                    ? {
                        locale: locale,
                    }
                    : {}),
                ...(includeRefs
                    ? {
                        includeRefs: includeRefs,
                    }
                    : {}),
                ...(enrich
                    ? {
                        enrich: enrich,
                    }
                    : {}),
            });
            Object.values($builderContextSignal.componentInfos).forEach((registeredComponent) => {
                const message = createRegisterComponentMessage(registeredComponent);
                window.parent?.postMessage(message, "*");
            });
            window.addEventListener("builder:component:stateChangeListenerActivated", emitStateUpdate);
        }
        if ($builderContextSignal.content) {
            const variationId = $builderContextSignal.content?.testVariationId;
            const contentId = $builderContextSignal.content?.id;
            _track({
                type: "impression",
                canTrack: getDefaultCanTrack(canTrack),
                contentId,
                apiKey: apiKey,
                variationId: variationId !== contentId ? variationId : undefined,
            });
        }
        // override normal content in preview mode
        if (isPreviewing()) {
            const searchParams = new URL(location.href).searchParams;
            const searchParamPreviewModel = searchParams.get("builder.preview");
            const searchParamPreviewId = searchParams.get(`builder.preview.${searchParamPreviewModel}`);
            const previewApiKey = searchParams.get("apiKey") || searchParams.get("builder.space");
            /**
             * Make sure that:
             * - the preview model name is the same as the one we're rendering, since there can be multiple models rendered
             *  at the same time, e.g. header/page/footer.
             * - the API key is the same, since we don't want to preview content from other organizations.
             * - if there is content, that the preview ID is the same as that of the one we receive.
             *
             * TO-DO: should we only update the state when there is a change?
             **/
            if (searchParamPreviewModel === model &&
                previewApiKey === apiKey &&
                (!content || searchParamPreviewId === content.id)) {
                fetchOneEntry({
                    model: model,
                    apiKey: apiKey,
                    apiVersion: $builderContextSignal.apiVersion,
                }).then((content) => {
                    if (content) {
                        mergeNewContent(content);
                    }
                });
            }
        }
        evaluateJsCode();
        runHttpRequests();
        emitStateUpdate();
    }
});
function onUpdateFn_0(..._args) {
    if (content) {
        mergeNewContent(content);
    }
}
$: onUpdateFn_0(...[content]);
function onUpdateFn_1(..._args) { }
$: onUpdateFn_1(...[shouldSendResetCookie]);
function onUpdateFn_2(..._args) {
    evaluateJsCode();
}
$: onUpdateFn_2(...[
    $builderContextSignal.content?.data?.jsCode,
    $builderContextSignal.rootState,
]);
function onUpdateFn_3(..._args) {
    runHttpRequests();
}
$: onUpdateFn_3(...[$builderContextSignal.content?.data?.httpRequests]);
function onUpdateFn_4(..._args) {
    emitStateUpdate();
}
$: onUpdateFn_4(...[$builderContextSignal.rootState]);
setContext(builderContext.key, builderContextSignal);
onDestroy(() => {
    if (isBrowser()) {
        window.removeEventListener("message", processMessage);
        window.removeEventListener("builder:component:stateChangeListenerActivated", emitStateUpdate);
    }
});
</script>

{#if $builderContextSignal.content}
  <div
    key={forceReRenderCount}
    bind:this={elementRef}
    on:click={(event) => {
      onClick(event);
    }}
    builder-content-id={$builderContextSignal.content?.id}
    builder-model={model}
    {...{}}
    {...showContent
      ? {}
      : {
          hidden: true,
          "aria-hidden": true,
        }}
    class={classNameProp}
  >
    <slot />
  </div>
{/if}