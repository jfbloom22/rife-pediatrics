import {
  DEV
} from "./chunk-PLGELRID.js";
import {
  raf
} from "./chunk-IN4DBBVG.js";
import {
  EMPTY_FUNC,
  is_promise,
  subscribe_to_store
} from "./chunk-LXJVWPTW.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "./chunk-OL7BDVYM.js";

// node_modules/.pnpm/svelte@5.0.0-next.7/node_modules/svelte/src/internal/client/utils.js
var object_ref = Object;
var array_ref = Array;
var is_array = array_ref.isArray;
var array_from = array_ref.from;
var define_property = object_ref.defineProperty;
var get_descriptor = object_ref.getOwnPropertyDescriptor;
var get_descriptors = object_ref.getOwnPropertyDescriptors;

// node_modules/.pnpm/svelte@5.0.0-next.7/node_modules/svelte/src/internal/client/hydration.js
var current_hydration_fragment = null;
function set_current_hydration_fragment(fragment) {
  current_hydration_fragment = fragment;
}
function get_hydration_fragment(node) {
  const fragment = [];
  let current_node = node;
  let target_depth = null;
  while (current_node !== null) {
    const node_type = current_node.nodeType;
    const next_sibling = current_node.nextSibling;
    if (node_type === 8) {
      const data = (
        /** @type {Comment} */
        current_node.data
      );
      if (data.startsWith("ssr:")) {
        const depth = data.slice(4);
        if (target_depth === null) {
          target_depth = depth;
        } else if (depth === target_depth) {
          return fragment;
        } else {
          fragment.push(
            /** @type {Text | Comment | Element} */
            current_node
          );
        }
        current_node = next_sibling;
        continue;
      }
    }
    if (target_depth !== null) {
      fragment.push(
        /** @type {Text | Comment | Element} */
        current_node
      );
    }
    current_node = next_sibling;
  }
  return null;
}
function hydrate_block_anchor(anchor_node, is_controlled) {
  let target_node = anchor_node;
  if (current_hydration_fragment !== null) {
    if (is_controlled) {
      target_node = /** @type {Node} */
      target_node.firstChild;
    }
    if (target_node.nodeType === 8) {
      let fragment = target_node.$$fragment;
      if (fragment === void 0) {
        fragment = get_hydration_fragment(target_node);
        target_node.$$fragment = void 0;
      }
      set_current_hydration_fragment(fragment);
    } else {
      set_current_hydration_fragment([
        /** @type {Element} */
        target_node.firstChild
      ]);
    }
  }
}

// node_modules/.pnpm/svelte@5.0.0-next.7/node_modules/svelte/src/internal/client/operations.js
var node_prototype;
var element_prototype;
var text_prototype;
var map_prototype;
var append_child_method;
var clone_node_method;
var map_set_method;
var map_get_method;
var map_delete_method;
var first_child_get;
var next_sibling_get;
var text_content_set;
var class_name_set;
var $window;
var $document;
function init_operations() {
  if (node_prototype !== void 0) {
    return;
  }
  node_prototype = Node.prototype;
  element_prototype = Element.prototype;
  text_prototype = Text.prototype;
  map_prototype = Map.prototype;
  append_child_method = node_prototype.appendChild;
  clone_node_method = node_prototype.cloneNode;
  map_set_method = map_prototype.set;
  map_get_method = map_prototype.get;
  map_delete_method = map_prototype.delete;
  $window = window;
  $document = document;
  element_prototype.__click = void 0;
  text_prototype.__nodeValue = " ";
  element_prototype.__className = "";
  first_child_get = /** @type {(this: Node) => ChildNode | null} */
  // @ts-ignore
  get_descriptor(node_prototype, "firstChild").get;
  next_sibling_get = /** @type {(this: Node) => ChildNode | null} */
  // @ts-ignore
  get_descriptor(node_prototype, "nextSibling").get;
  text_content_set = /** @type {(this: Node, text: string ) => void} */
  // @ts-ignore
  get_descriptor(node_prototype, "textContent").set;
  class_name_set = /** @type {(this: Element, class_name: string) => void} */
  // @ts-ignore
  get_descriptor(element_prototype, "className").set;
}
function append_child(element2, child2) {
  append_child_method.call(element2, child2);
}
function map_set(map, key2, value) {
  map_set_method.call(map, key2, value);
}
function map_get(map, key2) {
  return map_get_method.call(map, key2);
}
function clone_node(node, deep) {
  return (
    /** @type {N} */
    clone_node_method.call(node, deep)
  );
}
function child(node) {
  const child2 = first_child_get.call(node);
  if (current_hydration_fragment !== null) {
    if (child2 === null) {
      const text2 = document.createTextNode("");
      node.appendChild(text2);
      return text2;
    } else {
      return capture_fragment_from_node(child2);
    }
  }
  return child2;
}
function child_frag(node) {
  if (current_hydration_fragment !== null) {
    const first_node = (
      /** @type {Node[]} */
      node[0]
    );
    if (current_hydration_fragment !== null && first_node !== null) {
      return capture_fragment_from_node(first_node);
    }
    return first_node;
  }
  return first_child_get.call(
    /** @type {Node} */
    node
  );
}
function sibling(node) {
  const next_sibling = next_sibling_get.call(node);
  if (current_hydration_fragment !== null && next_sibling !== null) {
    return capture_fragment_from_node(next_sibling);
  }
  return next_sibling;
}
function set_class_name(node, class_name2) {
  class_name_set.call(node, class_name2);
}
function clear_text_content(node) {
  text_content_set.call(node, "");
}
function create_element(name) {
  return document.createElement(name);
}
function capture_fragment_from_node(node) {
  if (node.nodeType === 8 && /** @type {Comment} */
  node.data.startsWith("ssr:") && /** @type {Array<Element | Text | Comment>} */
  current_hydration_fragment.at(-1) !== node) {
    const fragment = (
      /** @type {Array<Element | Text | Comment>} */
      get_hydration_fragment(node)
    );
    const last_child = fragment.at(-1) || node;
    const target = (
      /** @type {Node} */
      last_child.nextSibling
    );
    target.$$fragment = fragment;
    return target;
  }
  return node;
}

// node_modules/.pnpm/svelte@5.0.0-next.7/node_modules/svelte/src/internal/client/block.js
var ROOT_BLOCK = 0;
var IF_BLOCK = 1;
var EACH_BLOCK = 2;
var EACH_ITEM_BLOCK = 3;
var AWAIT_BLOCK = 4;
var KEY_BLOCK = 5;
var HEAD_BLOCK = 6;
var DYNAMIC_COMPONENT_BLOCK = 7;
var DYNAMIC_ELEMENT_BLOCK = 8;
var SNIPPET_BLOCK = 9;
function create_root_block(container, intro) {
  return {
    dom: null,
    effect: null,
    container,
    intro,
    parent: null,
    transition: null,
    type: ROOT_BLOCK
  };
}
function create_if_block() {
  return {
    current: false,
    dom: null,
    effect: null,
    parent: (
      /** @type {import('./types.js').Block} */
      current_block
    ),
    transition: null,
    type: IF_BLOCK
  };
}
function create_key_block() {
  return {
    dom: null,
    effect: null,
    parent: (
      /** @type {import('./types.js').Block} */
      current_block
    ),
    transition: null,
    type: KEY_BLOCK
  };
}
function create_head_block() {
  return {
    dom: null,
    effect: null,
    parent: (
      /** @type {import('./types.js').Block} */
      current_block
    ),
    transition: null,
    type: HEAD_BLOCK
  };
}
function create_dynamic_element_block() {
  return {
    dom: null,
    effect: null,
    parent: (
      /** @type {import('./types.js').Block} */
      current_block
    ),
    transition: null,
    type: DYNAMIC_ELEMENT_BLOCK
  };
}
function create_dynamic_component_block() {
  return {
    dom: null,
    effect: null,
    parent: (
      /** @type {import('./types.js').Block} */
      current_block
    ),
    transition: null,
    type: DYNAMIC_COMPONENT_BLOCK
  };
}
function create_await_block() {
  return {
    dom: null,
    effect: null,
    parent: (
      /** @type {import('./types.js').Block} */
      current_block
    ),
    pending: true,
    transition: null,
    type: AWAIT_BLOCK
  };
}
function create_each_block(flags, anchor) {
  return {
    anchor,
    dom: null,
    flags,
    items: [],
    effect: null,
    parent: (
      /** @type {import('./types.js').Block} */
      current_block
    ),
    transition: null,
    transitions: [],
    type: EACH_BLOCK
  };
}
function create_each_item_block(item, index, key2) {
  return {
    dom: null,
    effect: null,
    index,
    key: key2,
    item,
    parent: (
      /** @type {import('./types.js').EachBlock} */
      current_block
    ),
    transition: null,
    transitions: null,
    type: EACH_ITEM_BLOCK
  };
}
function create_snippet_block() {
  return {
    dom: null,
    parent: (
      /** @type {import('./types.js').Block} */
      current_block
    ),
    effect: null,
    transition: null,
    type: SNIPPET_BLOCK
  };
}

// node_modules/.pnpm/svelte@5.0.0-next.7/node_modules/svelte/src/constants.js
var EACH_ITEM_REACTIVE = 1;
var EACH_INDEX_REACTIVE = 1 << 1;
var EACH_KEYED = 1 << 2;
var EACH_IS_CONTROLLED = 1 << 3;
var EACH_IS_ANIMATED = 1 << 4;
var DelegatedEvents = [
  "beforeinput",
  "click",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  // 'input', This conflicts with bind:input
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
];
var PassiveDelegatedEvents = ["touchstart", "touchmove", "touchend"];

// node_modules/.pnpm/svelte@5.0.0-next.7/node_modules/svelte/src/internal/client/reconciler.js
var NEW_BLOCK = -1;
var MOVED_BLOCK = 99999999;
var LIS_BLOCK = -2;
function create_fragment_from_html(html2) {
  var elem = document.createElement("template");
  elem.innerHTML = html2;
  return elem.content;
}
function insert(current, parent_element, sibling2) {
  if (is_array(current)) {
    var i = 0;
    var node;
    for (; i < current.length; i++) {
      node = current[i];
      if (sibling2 === null) {
        append_child(
          /** @type {Element} */
          parent_element,
          /** @type {Node} */
          node
        );
      } else {
        sibling2.before(
          /** @type {Node} */
          node
        );
      }
    }
    return current[0];
  } else if (current !== null) {
    if (sibling2 === null) {
      append_child(
        /** @type {Element} */
        parent_element,
        /** @type {Node} */
        current
      );
    } else {
      sibling2.before(
        /** @type {Node} */
        current
      );
    }
  }
  return (
    /** @type {Text | Element | Comment} */
    current
  );
}
function remove(current) {
  var first_node = current;
  if (is_array(current)) {
    var i = 0;
    var node;
    for (; i < current.length; i++) {
      node = current[i];
      if (i === 0) {
        first_node = node;
      }
      if (node.isConnected) {
        node.remove();
      }
    }
  } else if (current.isConnected) {
    current.remove();
  }
  return (
    /** @type {Element | Comment | Text} */
    first_node
  );
}
function reconcile_html(dom, value, svg) {
  hydrate_block_anchor(dom);
  if (current_hydration_fragment !== null) {
    return current_hydration_fragment;
  }
  var html2 = value + "";
  var target = dom;
  var frag_nodes;
  if (svg) {
    html2 = `<svg>${html2}</svg>`;
  }
  var content = create_fragment_from_html(html2);
  if (svg) {
    content = /** @type {DocumentFragment} */
    /** @type {unknown} */
    content.firstChild;
  }
  var clone = content.cloneNode(true);
  frag_nodes = Array.from(clone.childNodes);
  target.before(svg ? (
    /** @type {Node} */
    clone.firstChild
  ) : clone);
  return (
    /** @type {Array<Text | Comment | Element>} */
    frag_nodes
  );
}
function insert_each_item_block(block, dom, is_controlled, sibling2) {
  var current = (
    /** @type {import('./types.js').TemplateNode} */
    block.dom
  );
  if (sibling2 === null) {
    if (is_controlled) {
      return insert(
        current,
        /** @type {Element} */
        dom,
        null
      );
    } else {
      return insert(
        current,
        /** @type {Element} */
        dom.parentNode,
        dom
      );
    }
  }
  return insert(current, null, sibling2);
}
function get_first_child(block) {
  var current = block.dom;
  if (is_array(current)) {
    return (
      /** @type {Text | Element | Comment} */
      current[0]
    );
  }
  return (
    /** @type {Text | Element | Comment} */
    current
  );
}
function destroy_active_transition_blocks(active_transitions) {
  var length = active_transitions.length;
  if (length > 0) {
    var i = 0;
    var block;
    var transition2;
    for (; i < length; i++) {
      block = active_transitions[i];
      transition2 = block.transition;
      if (transition2 !== null) {
        block.transition = null;
        destroy_each_item_block(block, null, false);
      }
    }
    active_transitions.length = 0;
  }
}
function reconcile_indexed_array(array, each_block, dom, is_controlled, render_fn, flags, apply_transitions) {
  var a_blocks = each_block.items;
  var active_transitions = each_block.transitions;
  var a = a_blocks.length;
  var b = array.length;
  var length = Math.max(a, b);
  var index = 0;
  var b_blocks;
  var block;
  if (active_transitions.length !== 0) {
    destroy_active_transition_blocks(active_transitions);
  }
  if (b === 0) {
    b_blocks = [];
    if (is_controlled && a !== 0) {
      clear_text_content(dom);
    }
    while (index < length) {
      block = a_blocks[index++];
      destroy_each_item_block(block, active_transitions, apply_transitions, is_controlled);
    }
  } else {
    var item;
    b_blocks = Array(b);
    if (current_hydration_fragment !== null) {
      var hydrating_node = current_hydration_fragment[0];
      for (; index < length; index++) {
        item = array[index];
        var fragment = (
          /** @type {Array<Text | Comment | Element>} */
          get_hydration_fragment(hydrating_node)
        );
        set_current_hydration_fragment(fragment);
        hydrating_node = /** @type {Node} */
        /** @type {Node} */
        /** @type {Node} */
        fragment.at(-1).nextSibling.nextSibling;
        block = each_item_block(item, null, index, render_fn, flags);
        b_blocks[index] = block;
      }
    } else {
      for (; index < length; index++) {
        if (index >= a) {
          item = array[index];
          block = each_item_block(item, null, index, render_fn, flags);
          b_blocks[index] = block;
          insert_each_item_block(block, dom, is_controlled, null);
        } else if (index >= b) {
          block = a_blocks[index];
          destroy_each_item_block(block, active_transitions, apply_transitions);
        } else {
          item = array[index];
          block = a_blocks[index];
          b_blocks[index] = block;
          update_each_item_block(block, item, index, flags);
        }
      }
    }
  }
  each_block.items = b_blocks;
}
function reconcile_tracked_array(array, each_block, dom, is_controlled, render_fn, flags, apply_transitions, keys) {
  var a_blocks = each_block.items;
  const is_computed_key = keys !== null;
  var active_transitions = each_block.transitions;
  var a = a_blocks.length;
  var b = array.length;
  var b_blocks;
  var block;
  if (active_transitions.length !== 0) {
    destroy_active_transition_blocks(active_transitions);
  }
  if (b === 0) {
    b_blocks = [];
    if (is_controlled && a !== 0) {
      clear_text_content(dom);
    }
    while (a > 0) {
      block = a_blocks[--a];
      destroy_each_item_block(block, active_transitions, apply_transitions, is_controlled);
    }
  } else {
    var a_end = a - 1;
    var b_end = b - 1;
    var key2;
    var item;
    var idx;
    b_blocks = Array(b);
    if (current_hydration_fragment !== null) {
      var fragment;
      var hydrating_node = current_hydration_fragment[0];
      while (b > 0) {
        idx = b_end - --b;
        item = array[idx];
        key2 = is_computed_key ? keys[idx] : item;
        fragment = /** @type {Array<Text | Comment | Element>} */
        get_hydration_fragment(hydrating_node);
        set_current_hydration_fragment(fragment);
        hydrating_node = /** @type {Node} */
        /** @type {Node} */
        (fragment.at(-1) || hydrating_node).nextSibling.nextSibling;
        block = each_item_block(item, key2, idx, render_fn, flags);
        b_blocks[idx] = block;
      }
    } else if (a === 0) {
      while (b > 0) {
        idx = b_end - --b;
        item = array[idx];
        key2 = is_computed_key ? keys[idx] : item;
        block = each_item_block(item, key2, idx, render_fn, flags);
        b_blocks[idx] = block;
        insert_each_item_block(block, dom, is_controlled, null);
      }
    } else {
      var should_update_block = (flags & EACH_ITEM_REACTIVE) !== 0 || (flags & EACH_INDEX_REACTIVE) !== 0;
      var start = 0;
      var sibling2 = null;
      item = array[b_end];
      key2 = is_computed_key ? keys[b_end] : item;
      outer:
        while (true) {
          while (a_blocks[a_end].key === key2) {
            block = a_blocks[a_end--];
            item = array[b_end];
            if (should_update_block) {
              update_each_item_block(block, item, b_end, flags);
            }
            sibling2 = get_first_child(block);
            b_blocks[b_end] = block;
            if (start > --b_end || start > a_end) {
              break outer;
            }
            key2 = is_computed_key ? keys[b_end] : item;
          }
          item = array[start];
          key2 = is_computed_key ? keys[start] : item;
          while (start <= a_end && start <= b_end && a_blocks[start].key === key2) {
            item = array[start];
            block = a_blocks[start];
            if (should_update_block) {
              update_each_item_block(block, item, start, flags);
            }
            b_blocks[start] = block;
            ++start;
            key2 = is_computed_key ? keys[start] : array[start];
          }
          break;
        }
      if (start > a_end) {
        while (b_end >= start) {
          item = array[b_end];
          key2 = is_computed_key ? keys[b_end] : item;
          block = each_item_block(item, key2, b_end, render_fn, flags);
          b_blocks[b_end--] = block;
          sibling2 = insert_each_item_block(block, dom, is_controlled, sibling2);
        }
      } else if (start > b_end) {
        b = start;
        do {
          if ((block = a_blocks[b++]) !== null) {
            destroy_each_item_block(block, active_transitions, apply_transitions);
          }
        } while (b <= a_end);
      } else {
        var pos = 0;
        var b_length = b_end - start + 1;
        var sources = new Int32Array(b_length);
        var item_index = /* @__PURE__ */ new Map();
        for (b = 0; b < b_length; ++b) {
          a = b + start;
          sources[b] = NEW_BLOCK;
          item = array[a];
          key2 = is_computed_key ? keys[a] : item;
          map_set(item_index, key2, a);
        }
        for (b = start; b <= a_end; ++b) {
          a = map_get(
            item_index,
            /** @type {V} */
            a_blocks[b].key
          );
          block = a_blocks[b];
          if (a !== void 0) {
            pos = pos < a ? a : MOVED_BLOCK;
            sources[a - start] = b;
            b_blocks[a] = block;
          } else if (block !== null) {
            destroy_each_item_block(block, active_transitions, apply_transitions);
          }
        }
        if (pos === MOVED_BLOCK) {
          mark_lis(sources);
        }
        var is_animated = (flags & EACH_IS_ANIMATED) !== 0;
        var should_create;
        if (is_animated) {
          var i = b_length;
          while (i-- > 0) {
            b_end = i + start;
            a = sources[i];
            if (pos === MOVED_BLOCK && a !== LIS_BLOCK) {
              block = b_blocks[b_end];
              update_each_item_block(block, item, b_end, flags);
            }
          }
        }
        var last_block;
        var last_sibling;
        while (b_length-- > 0) {
          b_end = b_length + start;
          a = sources[b_length];
          should_create = a === -1;
          item = array[b_end];
          if (should_create) {
            key2 = is_computed_key ? keys[b_end] : item;
            block = each_item_block(item, key2, b_end, render_fn, flags);
          } else {
            block = b_blocks[b_end];
            if (!is_animated && should_update_block) {
              update_each_item_block(block, item, b_end, flags);
            }
          }
          if (should_create || pos === MOVED_BLOCK && a !== LIS_BLOCK) {
            last_sibling = last_block === void 0 ? sibling2 : get_first_child(last_block);
            sibling2 = insert_each_item_block(block, dom, is_controlled, last_sibling);
          }
          b_blocks[b_end] = block;
          last_block = block;
        }
      }
    }
  }
  each_block.items = b_blocks;
}
function mark_lis(a) {
  var length = a.length;
  var parent = new Int32Array(length);
  var index = new Int32Array(length);
  var index_length = 0;
  var i = 0;
  var j;
  var k;
  var lo;
  var hi;
  for (; a[i] === NEW_BLOCK; ++i) {
  }
  index[0] = i++;
  for (; i < length; ++i) {
    k = a[i];
    if (k !== NEW_BLOCK) {
      j = index[index_length];
      if (a[j] < k) {
        parent[i] = j;
        index[++index_length] = i;
      } else {
        lo = 0;
        hi = index_length;
        while (lo < hi) {
          j = lo + hi >> 1;
          if (a[index[j]] < k) {
            lo = j + 1;
          } else {
            hi = j;
          }
        }
        if (k < a[index[lo]]) {
          if (lo > 0) {
            parent[i] = index[lo - 1];
          }
          index[lo] = i;
        }
      }
    }
  }
  j = index[index_length];
  while (index_length-- >= 0) {
    a[j] = LIS_BLOCK;
    j = parent[j];
  }
}

// node_modules/.pnpm/svelte@5.0.0-next.7/node_modules/svelte/src/internal/client/transitions.js
var active_tick_animations = /* @__PURE__ */ new Set();
var DELAY_NEXT_TICK = Number.MIN_SAFE_INTEGER;
var active_tick_ref = void 0;
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, cancelable, detail);
  return e;
}
function dispatch_event(dom, type) {
  dom.dispatchEvent(custom_event(type));
}
function css_style_from_camel_case(style2) {
  const parts = style2.split("-");
  if (parts.length === 1)
    return parts[0];
  return parts[0] + parts.slice(1).map(
    /** @param {any} word */
    (word) => word[0].toUpperCase() + word.slice(1)
  ).join("");
}
function css_to_keyframe(css) {
  const keyframe = {};
  const parts = css.split(";");
  for (const part of parts) {
    const [property, value] = part.split(":");
    if (!property || value === void 0)
      break;
    const formatted_property = css_style_from_camel_case(property.trim());
    keyframe[formatted_property] = value.trim();
  }
  return keyframe;
}
var _tick_fn, _duration, _current, _delay, _previous, _reversed, _delay_current, _delayed_reverse, _reverse, reverse_fn;
var TickAnimation = class {
  /**
   * @param {(t: number, u: number) => string} tick_fn
   * @param {number} duration
   * @param {number} delay
   * @param {boolean} out
   */
  constructor(tick_fn, duration, delay, out2) {
    __privateAdd(this, _reverse);
    /** @type {null | (() => void)} */
    __publicField(this, "onfinish");
    /** @type {(t: number, u: number) => string} */
    __privateAdd(this, _tick_fn, void 0);
    /** @type {number} */
    __privateAdd(this, _duration, void 0);
    /** @type {number} */
    __privateAdd(this, _current, void 0);
    /** @type {number} */
    __privateAdd(this, _delay, void 0);
    /** @type {number} */
    __privateAdd(this, _previous, void 0);
    /** @type {boolean} */
    __publicField(this, "paused");
    /** @type {boolean} */
    __privateAdd(this, _reversed, void 0);
    /** @type {number} */
    __privateAdd(this, _delay_current, void 0);
    /** @type {boolean} */
    __privateAdd(this, _delayed_reverse, void 0);
    __privateSet(this, _duration, duration);
    __privateSet(this, _delay, delay);
    this.paused = false;
    __privateSet(this, _tick_fn, tick_fn);
    __privateSet(this, _reversed, out2);
    __privateSet(this, _delay_current, delay);
    __privateSet(this, _current, out2 ? duration : 0);
    __privateSet(this, _previous, 0);
    __privateSet(this, _delayed_reverse, false);
    this.onfinish = null;
    if (__privateGet(this, _delay)) {
      if (!out2) {
        __privateGet(this, _tick_fn).call(this, 0, 1);
      }
    }
  }
  pause() {
    this.paused = true;
  }
  play() {
    this.paused = false;
    if (!active_tick_animations.has(this)) {
      __privateSet(this, _previous, raf.now());
      if (active_tick_ref === void 0) {
        active_tick_ref = raf.tick(handle_raf);
      }
      active_tick_animations.add(this);
    }
  }
  reverse() {
    if (__privateGet(this, _delay) === 0) {
      __privateMethod(this, _reverse, reverse_fn).call(this);
    } else {
      __privateSet(this, _delay_current, __privateGet(this, _delay));
      __privateSet(this, _delayed_reverse, true);
    }
  }
  cancel() {
    const t = __privateGet(this, _reversed) ? 1 : 0;
    active_tick_animations.delete(this);
    __privateGet(this, _tick_fn).call(this, t, 1 - t);
  }
  finish() {
    active_tick_animations.delete(this);
    if (this.onfinish) {
      this.onfinish();
    }
  }
  /** @param {number} time */
  _update(time) {
    let diff = time - __privateGet(this, _previous);
    __privateSet(this, _previous, time);
    if (__privateGet(this, _delay_current) !== 0) {
      const is_delayed = __privateGet(this, _delay_current) === DELAY_NEXT_TICK;
      let cancel = !__privateGet(this, _delayed_reverse);
      __privateSet(this, _delay_current, __privateGet(this, _delay_current) - diff);
      if (__privateGet(this, _delay_current) < 0 || is_delayed || __privateGet(this, _delay_current) === 0 && __privateGet(this, _reversed)) {
        const delay_diff = is_delayed ? 0 : -__privateGet(this, _delay_current);
        __privateSet(this, _delay_current, 0);
        if (__privateGet(this, _delayed_reverse)) {
          __privateSet(this, _delayed_reverse, false);
          __privateMethod(this, _reverse, reverse_fn).call(this);
        } else if (delay_diff !== 0 || __privateGet(this, _reversed)) {
          diff = delay_diff;
        }
        cancel = false;
      } else if (__privateGet(this, _delay_current) === 0) {
        __privateSet(this, _delay_current, DELAY_NEXT_TICK);
      }
      if (cancel) {
        return;
      }
    }
    __privateSet(this, _current, __privateGet(this, _current) + (__privateGet(this, _reversed) ? -diff : diff));
    let t = __privateGet(this, _current) / __privateGet(this, _duration);
    if (t < 0) {
      t = 0;
    } else if (t > 1) {
      t = 1;
    }
    if (__privateGet(this, _reversed) && t <= 0 || !__privateGet(this, _reversed) && t >= 1) {
      t = __privateGet(this, _reversed) ? 0 : 1;
      if (__privateGet(this, _delay_current) === 0) {
        active_tick_animations.delete(this);
        if (this.onfinish) {
          this.paused = true;
          this.onfinish();
        }
      }
    }
    __privateGet(this, _tick_fn).call(this, t, 1 - t);
  }
};
_tick_fn = new WeakMap();
_duration = new WeakMap();
_current = new WeakMap();
_delay = new WeakMap();
_previous = new WeakMap();
_reversed = new WeakMap();
_delay_current = new WeakMap();
_delayed_reverse = new WeakMap();
_reverse = new WeakSet();
reverse_fn = function() {
  __privateSet(this, _reversed, !__privateGet(this, _reversed));
  if (this.paused) {
    if (__privateGet(this, _current) === 0) {
      __privateSet(this, _current, __privateGet(this, _duration));
    }
    this.play();
  }
};
function handle_raf(time) {
  for (const animation of active_tick_animations) {
    if (!animation.paused) {
      animation._update(time);
    }
  }
  if (active_tick_animations.size !== 0) {
    active_tick_ref = raf.tick(handle_raf);
  } else {
    active_tick_ref = void 0;
  }
}
function create_transition(dom, init, direction, effect2) {
  let curr_direction = "in";
  let subs = [];
  let animation = null;
  let cancelled = false;
  const create_animation = () => {
    let payload = (
      /** @type {import('./types.js').TransitionPayload} */
      transition2.payload
    );
    if (typeof payload === "function") {
      payload = payload({ direction: curr_direction });
    }
    const duration = payload.duration ?? 300;
    const delay = payload.delay ?? 0;
    const css_fn = payload.css;
    const tick_fn = payload.tick;
    const linear = (t) => t;
    const easing_fn = payload.easing || linear;
    const keyframes = [];
    if (typeof tick_fn === "function") {
      animation = new TickAnimation(tick_fn, duration, delay, direction === "out");
    } else {
      if (typeof css_fn === "function") {
        const frame_time = 16.666;
        const max_duration = Math.max(duration, frame_time);
        for (let i = 0; i <= max_duration; i += frame_time) {
          let time;
          if (i + frame_time > max_duration) {
            time = 1;
          } else if (i === 0) {
            time = 0;
          } else {
            time = i / max_duration;
          }
          const t = easing_fn(time);
          keyframes.push(css_to_keyframe(css_fn(t, 1 - t)));
        }
        if (direction === "out") {
          keyframes.reverse();
        }
      }
      animation = dom.animate(keyframes, {
        duration,
        endDelay: delay,
        delay,
        fill: "both"
      });
    }
    animation.pause();
    animation.onfinish = () => {
      const is_outro = curr_direction === "out";
      animation.pause();
      if (is_outro) {
        for (const sub of subs) {
          sub();
        }
        subs = [];
      }
      dispatch_event(dom, is_outro ? "outroend" : "introend");
    };
  };
  const transition2 = {
    effect: effect2,
    init,
    payload: null,
    /** @param {() => void} fn */
    finished(fn) {
      subs.push(fn);
    },
    in() {
      const needs_reverse = curr_direction !== "in";
      curr_direction = "in";
      if (animation === null || cancelled) {
        cancelled = false;
        create_animation();
      }
      dispatch_event(dom, "introstart");
      if (needs_reverse) {
        animation.reverse();
      }
      animation.play();
    },
    out() {
      const needs_reverse = direction === "both" && curr_direction !== "out";
      curr_direction = "out";
      if (animation === null || cancelled) {
        cancelled = false;
        create_animation();
      }
      dispatch_event(dom, "outrostart");
      if (needs_reverse) {
        animation.reverse();
      } else {
        animation.play();
      }
    },
    cancel() {
      animation.cancel();
      cancelled = true;
    },
    cleanup() {
      for (const sub of subs) {
        sub();
      }
      subs = [];
    },
    direction,
    dom
  };
  return transition2;
}
function is_transition_block(block) {
  return block.type === IF_BLOCK || block.type === EACH_ITEM_BLOCK || block.type === KEY_BLOCK || block.type === AWAIT_BLOCK || block.type === DYNAMIC_COMPONENT_BLOCK || block.type === EACH_BLOCK && block.items.length === 0;
}
function bind_transition(dom, transition_fn, props_fn, direction, global) {
  const transition_effect = (
    /** @type {import('./types.js').EffectSignal} */
    current_effect
  );
  const block = current_block;
  const props = props_fn === null ? {} : props_fn();
  let skip_intro = true;
  let transition_block = block;
  while (transition_block !== null) {
    if (is_transition_block(transition_block)) {
      if (transition_block.type === EACH_ITEM_BLOCK) {
        transition_block.transition = each_item_transition;
        transition_block = transition_block.parent;
      } else if (transition_block.type === AWAIT_BLOCK && transition_block.pending) {
        skip_intro = false;
      }
      if (skip_intro) {
        skip_intro = transition_block.effect === null;
      }
      if (!skip_intro || !global) {
        break;
      }
    } else if (transition_block.type === ROOT_BLOCK && (transition_block.effect !== null || transition_block.intro)) {
      skip_intro = false;
    }
    transition_block = transition_block.parent;
  }
  let transition2;
  effect(() => {
    const init = (from) => untrack(
      () => direction === "key" ? (
        /** @type {import('./types.js').AnimateFn<any>} */
        transition_fn(
          dom,
          { from: (
            /** @type {DOMRect} */
            from
          ), to: dom.getBoundingClientRect() },
          props,
          {}
        )
      ) : (
        /** @type {import('./types.js').TransitionFn<any>} */
        transition_fn(dom, props, {
          direction
        })
      )
    );
    transition2 = create_transition(dom, init, direction, transition_effect);
    const is_intro = direction === "in";
    const show_intro = !skip_intro && (is_intro || direction === "both");
    if (show_intro) {
      transition2.payload = transition2.init();
    }
    const effect2 = managed_pre_effect(() => {
      destroy_signal(effect2);
      dom.inert = false;
      if (show_intro) {
        transition2.in();
      }
      let transition_block2 = block;
      while (transition_block2 !== null) {
        const parent = transition_block2.parent;
        if (is_transition_block(transition_block2)) {
          if (transition_block2.transition !== null) {
            transition_block2.transition(transition2);
          }
          if (parent === null || !global && (transition_block2.type !== IF_BLOCK || parent.type !== IF_BLOCK || parent.current)) {
            break;
          }
        }
        transition_block2 = parent;
      }
    }, false);
  });
  if (direction === "key") {
    effect(() => {
      return () => {
        transition2.cleanup();
      };
    });
  }
}
function remove_in_transitions(transitions) {
  for (let other of transitions) {
    if (other.direction === "in") {
      transitions.delete(other);
    }
  }
}
function trigger_transitions(transitions, target_direction, from) {
  const outros = [];
  for (const transition2 of transitions) {
    const direction = transition2.direction;
    if (target_direction === "in") {
      if (direction === "in" || direction === "both") {
        transition2.in();
      } else {
        transition2.cancel();
      }
      transition2.dom.inert = false;
      mark_subtree_inert(transition2.effect, false);
    } else if (target_direction === "key") {
      if (direction === "key") {
        transition2.payload = transition2.init(
          /** @type {DOMRect} */
          from
        );
        transition2.in();
      }
    } else {
      if (direction === "out" || direction === "both") {
        transition2.payload = transition2.init();
        outros.push(transition2.out);
      }
      transition2.dom.inert = true;
      mark_subtree_inert(transition2.effect, true);
    }
  }
  if (outros.length > 0) {
    const e = managed_pre_effect(() => {
      destroy_signal(e);
      const e2 = managed_effect(() => {
        destroy_signal(e2);
        outros.forEach(
          /** @param {any} o */
          (o) => o()
        );
      });
    }, false);
  }
}
function each_item_transition(transition2) {
  const block = this;
  const each_block = block.parent;
  const is_controlled = (each_block.flags & EACH_IS_CONTROLLED) !== 0;
  if (is_controlled) {
    const anchor = empty();
    each_block.flags ^= EACH_IS_CONTROLLED;
    append_child(
      /** @type {Element} */
      each_block.anchor,
      anchor
    );
    each_block.anchor = anchor;
  }
  if (transition2.direction === "key" && (each_block.flags & EACH_IS_ANIMATED) === 0) {
    each_block.flags |= EACH_IS_ANIMATED;
  }
  let transitions = block.transitions;
  if (transitions === null) {
    block.transitions = transitions = /* @__PURE__ */ new Set();
  }
  transition2.finished(() => {
    if (transitions !== null) {
      transitions.delete(transition2);
      if (transition2.direction !== "key") {
        for (let other of transitions) {
          if (other.direction === "key" || other.direction === "in") {
            transitions.delete(other);
          }
        }
        if (transitions.size === 0) {
          block.transitions = null;
          destroy_each_item_block(block, null, true);
        }
      }
    }
  });
  transitions.add(transition2);
}

// node_modules/.pnpm/svelte@5.0.0-next.7/node_modules/svelte/src/internal/client/render.js
var all_registerd_events = /* @__PURE__ */ new Set();
var root_event_handles = /* @__PURE__ */ new Set();
function empty() {
  return document.createTextNode("");
}
function template(html2, is_fragment) {
  let cached_content;
  return () => {
    if (cached_content === void 0) {
      const content = create_fragment_from_html(html2);
      cached_content = is_fragment ? content : (
        /** @type {Node} */
        child(content)
      );
    }
    return cached_content;
  };
}
function svg_template(svg, is_fragment) {
  let cached_content;
  return () => {
    if (cached_content === void 0) {
      const content = (
        /** @type {Node} */
        child(create_fragment_from_html(`<svg>${svg}</svg>`))
      );
      cached_content = is_fragment ? content : (
        /** @type {Node} */
        child(content)
      );
    }
    return cached_content;
  };
}
function svg_replace(node) {
  const first_child = (
    /** @type {Element} */
    node.firstChild
  );
  node.replaceWith(first_child);
  return first_child;
}
function open_template(is_fragment, use_clone_node, anchor, template_element_fn) {
  if (current_hydration_fragment !== null) {
    if (anchor !== null) {
      hydrate_block_anchor(anchor, false);
    }
    const fragment = current_hydration_fragment;
    if (fragment !== null) {
      return is_fragment ? fragment : (
        /** @type {Element} */
        fragment[0]
      );
    }
  }
  return use_clone_node ? clone_node(
    /** @type {() => Element} */
    template_element_fn(),
    true
  ) : document.importNode(
    /** @type {() => Element} */
    template_element_fn(),
    true
  );
}
function open(anchor, use_clone_node, template_element_fn) {
  return open_template(false, use_clone_node, anchor, template_element_fn);
}
function open_frag(anchor, use_clone_node, template_element_fn) {
  return open_template(true, use_clone_node, anchor, template_element_fn);
}
function close_template(dom, is_fragment, anchor) {
  const block = (
    /** @type {import('./types.js').Block} */
    current_block
  );
  const current = is_fragment ? is_array(dom) ? dom : (
    /** @type {import('./types.js').TemplateNode[]} */
    Array.from(dom.childNodes)
  ) : dom;
  if (anchor !== null && current_hydration_fragment === null) {
    insert(current, null, anchor);
  }
  block.dom = current;
}
function close(anchor, dom) {
  close_template(dom, false, anchor);
}
function close_frag(anchor, dom) {
  close_template(dom, true, anchor);
}
function trusted(fn) {
  return function(...args) {
    const event2 = (
      /** @type {Event} */
      args[0]
    );
    if (event2.isTrusted) {
      unwrap(fn).apply(this, args);
    }
  };
}
function self(fn) {
  return function(...args) {
    const event2 = (
      /** @type {Event} */
      args[0]
    );
    if (event2.target === this) {
      unwrap(fn).apply(this, args);
    }
  };
}
function stopPropagation(fn) {
  return function(...args) {
    const event2 = (
      /** @type {Event} */
      args[0]
    );
    event2.stopPropagation();
    return unwrap(fn).apply(this, args);
  };
}
function once(fn) {
  let ran = false;
  return function(...args) {
    if (ran) {
      return;
    }
    ran = true;
    return unwrap(fn).apply(this, args);
  };
}
function stopImmediatePropagation(fn) {
  return function(...args) {
    const event2 = (
      /** @type {Event} */
      args[0]
    );
    event2.stopImmediatePropagation();
    return unwrap(fn).apply(this, args);
  };
}
function preventDefault(fn) {
  return function(...args) {
    const event2 = (
      /** @type {Event} */
      args[0]
    );
    event2.preventDefault();
    return unwrap(fn).apply(this, args);
  };
}
function event(event_name, dom, handler, capture, passive) {
  const options = {
    capture,
    passive
  };
  const target_handler = handler;
  dom.addEventListener(event_name, target_handler, options);
  if (dom === document.body || dom === window || dom === document) {
    render_effect(() => {
      return () => {
        dom.removeEventListener(event_name, target_handler, options);
      };
    });
  }
}
function class_name_effect(dom, value) {
  render_effect(() => {
    const string = value();
    class_name(dom, string);
  });
}
function class_name(dom, value) {
  const prev_class_name = dom.__className;
  const next_class_name = to_class(value);
  const is_hydrating = current_hydration_fragment !== null;
  if (is_hydrating && dom.className === next_class_name) {
    dom.__className = next_class_name;
  } else if (prev_class_name !== next_class_name || is_hydrating && dom.className !== next_class_name) {
    if (next_class_name === "") {
      dom.removeAttribute("class");
    } else {
      set_class_name(dom, next_class_name);
    }
    dom.__className = next_class_name;
  }
}
function text_effect(dom, value) {
  render_effect(() => {
    const string = value();
    text(dom, string);
  });
}
function text(dom, value) {
  const prev_node_value = dom.__nodeValue;
  const next_node_value = stringify(value);
  if (current_hydration_fragment !== null && dom.nodeValue === next_node_value) {
    dom.__nodeValue = next_node_value;
  } else if (prev_node_value !== next_node_value) {
    dom.nodeValue = next_node_value;
    dom.__nodeValue = next_node_value;
  }
}
function auto_focus(dom, value) {
  if (value) {
    const body = document.body;
    dom.autofocus = true;
    render_effect(
      () => {
        if (document.activeElement === body) {
          dom.focus();
        }
      },
      current_block,
      true,
      false
    );
  }
}
function to_class(value) {
  return value == null ? "" : value;
}
function class_toggle(dom, class_name2, value) {
  if (value) {
    dom.classList.add(class_name2);
  } else {
    dom.classList.remove(class_name2);
  }
}
function select_option(select, value) {
  if (select.multiple) {
    return select_options(select, value);
  }
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    const option_value = get_option_value(option);
    if (option_value === value) {
      option.selected = true;
      return;
    }
  }
  select.value = "";
}
function select_options(select, value) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    option.selected = ~value.indexOf(get_option_value(option));
  }
}
function get_option_value(option) {
  if ("__value" in option) {
    return option.__value;
  } else {
    return option.value;
  }
}
function bind_online(update) {
  const status_changed = () => {
    update(navigator.onLine);
  };
  listen_to_events(window, ["online", "offline"], status_changed);
}
function time_ranges_to_array(ranges) {
  const array = [];
  for (let i = 0; i < ranges.length; i += 1) {
    array.push({ start: ranges.start(i), end: ranges.end(i) });
  }
  return array;
}
function bind_current_time(media, get_value, update) {
  let raf_id;
  let updating = false;
  const callback = () => {
    cancelAnimationFrame(raf_id);
    if (!media.paused) {
      raf_id = requestAnimationFrame(callback);
    }
    updating = true;
    update(media.currentTime);
  };
  raf_id = requestAnimationFrame(callback);
  media.addEventListener("timeupdate", callback);
  render_effect(() => {
    const value = get_value();
    if (!updating && !isNaN(
      /** @type {any} */
      value
    )) {
      media.currentTime = /** @type {number} */
      value;
    }
    updating = false;
  });
  render_effect(() => () => cancelAnimationFrame(raf_id));
}
function bind_buffered(media, update) {
  const callback = () => {
    update(time_ranges_to_array(media.buffered));
  };
  listen_to_events(media, ["loadedmetadata", "progress"], callback);
}
function bind_seekable(media, update) {
  const callback = () => {
    update(time_ranges_to_array(media.seekable));
  };
  listen_to_events(media, ["loadedmetadata"], callback);
}
function bind_played(media, update) {
  const callback = () => {
    update(time_ranges_to_array(media.played));
  };
  listen_to_events(media, ["timeupdate"], callback);
}
function bind_seeking(media, update) {
  const callback = () => {
    update(media.seeking);
  };
  listen_to_events(media, ["seeking", "seeked"], callback);
}
function bind_ended(media, update) {
  const callback = () => {
    update(media.ended);
  };
  listen_to_events(media, ["timeupdate", "ended"], callback);
}
function bind_ready_state(media, update) {
  const callback = () => {
    update(media.readyState);
  };
  listen_to_events(
    media,
    ["loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "emptied"],
    callback
  );
}
function bind_playback_rate(media, get_value, update) {
  let updating = false;
  const callback = () => {
    if (!updating) {
      update(media.playbackRate);
    }
    updating = false;
  };
  let render;
  let destroyed = false;
  const effect2 = managed_effect(() => {
    destroy_signal(effect2);
    if (destroyed)
      return;
    if (get_value() == null) {
      callback();
    }
    listen_to_events(media, ["ratechange"], callback, false);
    render = render_effect(() => {
      const value = get_value();
      if (!isNaN(
        /** @type {any} */
        value
      ) && value !== media.playbackRate) {
        updating = true;
        media.playbackRate = /** @type {number} */
        value;
      }
    });
  });
  render_effect(() => () => {
    destroyed = true;
    if (render) {
      destroy_signal(render);
    }
  });
}
function bind_paused(media, get_value, update) {
  let mounted = current_hydration_fragment !== null;
  let paused = get_value();
  const callback = () => {
    if (paused !== media.paused) {
      paused = media.paused;
      update(paused = media.paused);
    }
  };
  if (paused == null) {
    callback();
  }
  if (mounted) {
    listen_to_events(media, ["play", "pause", "canplay"], callback, false);
  }
  render_effect(() => {
    paused = !!get_value();
    if (paused !== media.paused) {
      const toggle = () => {
        mounted = true;
        if (paused) {
          media.pause();
        } else {
          media.play().catch(() => {
            update(paused = true);
          });
        }
      };
      if (mounted) {
        toggle();
      } else {
        media.addEventListener(
          "canplay",
          () => {
            listen_to_events(media, ["play", "pause", "canplay"], callback, false);
            toggle();
          },
          { once: true }
        );
      }
    }
  });
}
function bind_volume(media, get_value, update) {
  let updating = false;
  const callback = () => {
    updating = true;
    update(media.volume);
  };
  if (get_value() == null) {
    callback();
  }
  listen_to_events(media, ["volumechange"], callback, false);
  render_effect(() => {
    const value = get_value();
    if (!updating && !isNaN(
      /** @type {any} */
      value
    )) {
      media.volume = /** @type {number} */
      value;
    }
    updating = false;
  });
}
function bind_muted(media, get_value, update) {
  let updating = false;
  const callback = () => {
    updating = true;
    update(media.muted);
  };
  if (get_value() == null) {
    callback();
  }
  listen_to_events(media, ["volumechange"], callback, false);
  render_effect(() => {
    const value = get_value();
    if (!updating) {
      media.muted = !!value;
    }
    updating = false;
  });
}
function listen_to_events(dom, events, handler, call_handler_immediately = true) {
  if (call_handler_immediately) {
    handler();
  }
  for (const name of events) {
    dom.addEventListener(name, handler);
  }
  render_effect(() => {
    return () => {
      for (const name of events) {
        dom.removeEventListener(name, handler);
      }
    };
  });
}
var _listeners, _observer, _options, _getObserver, getObserver_fn;
var _ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    __privateAdd(this, _getObserver);
    /** */
    __privateAdd(this, _listeners, /* @__PURE__ */ new WeakMap());
    /** @type {ResizeObserver | undefined} */
    __privateAdd(this, _observer, void 0);
    /** @type {ResizeObserverOptions} */
    __privateAdd(this, _options, void 0);
    __privateSet(this, _options, options);
  }
  /**
   * @param {Element} element
   * @param {(entry: ResizeObserverEntry) => any} listener
   */
  observe(element2, listener) {
    const listeners = __privateGet(this, _listeners).get(element2) || /* @__PURE__ */ new Set();
    listeners.add(listener);
    __privateGet(this, _listeners).set(element2, listeners);
    __privateMethod(this, _getObserver, getObserver_fn).call(this).observe(element2, __privateGet(this, _options));
    return () => {
      const listeners2 = __privateGet(this, _listeners).get(element2);
      listeners2.delete(listener);
      if (listeners2.size === 0) {
        __privateGet(this, _listeners).delete(element2);
        __privateGet(this, _observer).unobserve(element2);
      }
    };
  }
};
_listeners = new WeakMap();
_observer = new WeakMap();
_options = new WeakMap();
_getObserver = new WeakSet();
getObserver_fn = function() {
  return __privateGet(this, _observer) ?? __privateSet(this, _observer, new ResizeObserver(
    /** @param {any} entries */
    (entries) => {
      for (const entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        for (const listener of __privateGet(this, _listeners).get(entry.target) || []) {
          listener(entry);
        }
      }
    }
  ));
};
/** @static */
__publicField(_ResizeObserverSingleton, "entries", /* @__PURE__ */ new WeakMap());
var ResizeObserverSingleton = _ResizeObserverSingleton;
var resize_observer_content_box = new ResizeObserverSingleton({
  box: "content-box"
});
var resize_observer_border_box = new ResizeObserverSingleton({
  box: "border-box"
});
var resize_observer_device_pixel_content_box = new ResizeObserverSingleton({
  box: "device-pixel-content-box"
});
function bind_resize_observer(dom, type, update) {
  const observer = type === "contentRect" || type === "contentBoxSize" ? resize_observer_content_box : type === "borderBoxSize" ? resize_observer_border_box : resize_observer_device_pixel_content_box;
  const unsub = observer.observe(
    dom,
    /** @param {any} entry */
    (entry) => update(entry[type])
  );
  render_effect(() => unsub);
}
function bind_element_size(dom, type, update) {
  requestAnimationFrame(() => requestAnimationFrame(() => update(dom[type])));
  const unsub = resize_observer_border_box.observe(dom, () => update(dom[type]));
  render_effect(() => unsub);
}
function bind_window_size(type, update) {
  const callback = () => update(window[type]);
  listen_to_events(window, ["resize"], callback);
}
function selected(dom) {
  effect(() => {
    let select = dom.parentNode;
    while (select != null) {
      if (select.nodeName === "SELECT") {
        break;
      }
      select = select.parentNode;
    }
    if (select != null) {
      const select_value = select.__value;
      const option_value = dom.__value;
      const selected2 = select_value === option_value;
      dom.selected = selected2;
      dom.value = option_value;
      if (select.__value === null) {
        select.value = "";
      }
    }
  });
}
function bind_value(dom, get_value, update) {
  dom.addEventListener("input", () => {
    let value = dom.value;
    const type = dom.type;
    if (type === "number" || type === "range") {
      value = value === "" ? null : +value;
    }
    update(value);
  });
  render_effect(() => {
    const value = get_value();
    const coerced_value = value == null ? null : value + "";
    dom.value = coerced_value;
    dom.__value = value;
  });
}
function bind_select_value(dom, get_value, update) {
  let mounted = false;
  dom.addEventListener("change", () => {
    let value;
    if (dom.multiple) {
      value = [].map.call(dom.querySelectorAll(":checked"), get_option_value);
    } else {
      const selected_option = dom.querySelector(":checked");
      value = selected_option && get_option_value(selected_option);
    }
    update(value);
  });
  effect(() => {
    const value = get_value();
    if (value == null && !mounted) {
      let selected_option = value === void 0 ? dom.querySelector(":checked") : null;
      if (selected_option === null) {
        dom.value = "";
        dom.__value = null;
      }
      const options = dom.querySelectorAll("option");
      for (const option of options) {
        if (get_option_value(option) === value || option.hasAttribute("selected")) {
          if (option.disabled) {
            option.value = "";
          }
          option.selected = true;
          selected_option = option;
          break;
        }
      }
      if (selected_option != null) {
        const non_null_value = get_option_value(selected_option);
        update(non_null_value);
        if (selected_option.hasAttribute("selected")) {
          selected_option.removeAttribute("selected");
          selected_option.selected = true;
        }
      }
    } else {
      select_option(dom, value);
      dom.__value = value;
    }
    mounted = true;
  });
}
function bind_content_editable(property, dom, get_value, update) {
  dom.addEventListener("input", () => {
    const value = dom[property];
    update(value);
  });
  render_effect(() => {
    const value = get_value();
    if (dom[property] !== value) {
      if (value === null) {
        const non_null_value = dom[property];
        update(non_null_value);
      } else {
        dom[property] = value + "";
      }
    }
  });
}
function get_binding_group_value(group, __value, checked) {
  const value = /* @__PURE__ */ new Set();
  for (let i = 0; i < group.length; i += 1) {
    if (group[i].checked) {
      value.add(group[i].__value);
    }
  }
  if (!checked) {
    value.delete(__value);
  }
  return Array.from(value);
}
function bind_group(group, group_index, dom, get_value, update) {
  const is_checkbox = dom.getAttribute("type") === "checkbox";
  let binding_group = group;
  if (group_index !== null) {
    for (const index of group_index) {
      const group2 = binding_group;
      binding_group = group2[index];
      if (binding_group === void 0) {
        binding_group = group2[index] = [];
      }
    }
  }
  binding_group.push(dom);
  dom.addEventListener("change", () => {
    let value = dom.__value;
    if (is_checkbox) {
      value = get_binding_group_value(binding_group, value, dom.checked);
    }
    update(value);
  });
  render_effect(() => {
    let value = get_value();
    if (is_checkbox) {
      value = value || [];
      dom.checked = value.includes(dom.__value);
    } else {
      dom.checked = dom.__value === value;
    }
  });
  render_effect(() => {
    return () => {
      const index = binding_group.indexOf(dom);
      if (index !== -1) {
        binding_group.splice(index, 1);
      }
    };
  });
}
function bind_checked(dom, get_value, update) {
  dom.addEventListener("change", () => {
    const value = dom.checked;
    update(value);
  });
  if (get_value() == void 0) {
    update(false);
  }
  render_effect(() => {
    const value = get_value();
    dom.checked = Boolean(value);
  });
}
function bind_window_scroll(type, get_value, update) {
  const is_scrolling_x = type === "x";
  const target_handler = () => {
    scrolling = true;
    clearTimeout(timeout);
    timeout = setTimeout(clear, 100);
    const value = window[is_scrolling_x ? "scrollX" : "scrollY"];
    update(value);
  };
  addEventListener("scroll", target_handler, {
    passive: true
  });
  let latest_value = 0;
  let scrolling = false;
  let timeout;
  const clear = () => {
    scrolling = false;
  };
  render_effect(() => {
    latest_value = get_value() || 0;
    if (!scrolling) {
      scrolling = true;
      clearTimeout(timeout);
      if (is_scrolling_x) {
        scrollTo(latest_value, window.scrollY);
      } else {
        scrollTo(window.scrollX, latest_value);
      }
      timeout = setTimeout(clear, 100);
    }
  });
  render_effect(() => {
    return () => {
      removeEventListener("scroll", target_handler);
    };
  });
}
function bind_property(property, event_name, type, dom, get_value, update) {
  const target_handler = () => {
    const value = dom[property];
    update(value);
  };
  dom.addEventListener(event_name, target_handler);
  if (type === "set") {
    render_effect(() => {
      const value = get_value();
      dom[property] = value;
    });
  }
  if (type === "get") {
    const value = dom[property];
    update(value);
  }
  render_effect(() => {
    if (dom === document.body || dom === window || dom === document) {
      return () => {
        dom.removeEventListener(event_name, target_handler);
      };
    }
  });
}
function bind_prop(props, prop2, value) {
  const update = (value2) => {
    var _a;
    const current_props = unwrap(props);
    const signal = expose(() => current_props[prop2]);
    if (is_signal(signal)) {
      set(signal, value2);
    } else if (((_a = Object.getOwnPropertyDescriptor(current_props, prop2)) == null ? void 0 : _a.set) !== void 0) {
      current_props[prop2] = value2;
    }
  };
  update(value);
  render_effect(() => () => {
    update(null);
  });
}
function bind_this(element_or_component, update) {
  untrack(() => {
    update(element_or_component);
    render_effect(() => () => {
      untrack(() => {
        update(null);
      });
    });
  });
}
function delegate(events) {
  for (let i = 0; i < events.length; i++) {
    all_registerd_events.add(events[i]);
  }
  for (const fn of root_event_handles) {
    fn(events);
  }
}
function handle_event_propagation(root_element, event2) {
  var _a;
  const event_name = event2.type;
  const path = ((_a = event2.composedPath) == null ? void 0 : _a.call(event2)) || [];
  let current_target = (
    /** @type {null | Element} */
    path[0] || event2.target
  );
  if (event2.target !== current_target) {
    define_property(event2, "target", {
      configurable: true,
      value: current_target
    });
  }
  let path_idx = 0;
  const handled_at = event2.__root;
  if (handled_at) {
    const at_idx = path.indexOf(handled_at);
    if (at_idx < path.indexOf(root_element)) {
      path_idx = at_idx;
    }
  }
  current_target = /** @type {Element} */
  path[path_idx] || event2.target;
  define_property(event2, "currentTarget", {
    configurable: true,
    get() {
      return current_target || document;
    }
  });
  while (current_target !== null) {
    const parent_element = current_target.parentNode || /** @type {any} */
    current_target.host || null;
    const internal_prop_name = "__" + event_name;
    const delegated = current_target[internal_prop_name];
    if (delegated !== void 0 && !/** @type {any} */
    current_target.disabled) {
      if (is_array(delegated)) {
        const [fn, ...data] = delegated;
        fn.apply(current_target, [event2, ...data]);
      } else {
        delegated.call(current_target, event2);
      }
    }
    if (event2.cancelBubble || parent_element === root_element) {
      break;
    }
    current_target = parent_element;
  }
  event2.__root = root_element;
}
function slot(anchor_node, slot_fn, slot_props, fallback_fn) {
  hydrate_block_anchor(anchor_node);
  if (slot_fn === void 0) {
    if (fallback_fn !== null) {
      fallback_fn(anchor_node);
    }
  } else {
    slot_fn(anchor_node, slot_props);
  }
}
function if_block(anchor_node, condition_fn, consequent_fn, alternate_fn) {
  const block = create_if_block();
  hydrate_block_anchor(anchor_node);
  const consequent_transitions = /* @__PURE__ */ new Set();
  const alternate_transitions = /* @__PURE__ */ new Set();
  const previous_hydration_fragment = current_hydration_fragment;
  let consequent_dom = null;
  let alternate_dom = null;
  let has_mounted = false;
  let has_mounted_branch = false;
  block.transition = /**
   * @param {import('./types.js').Transition} transition
   * @returns {void}
   */
  (transition2) => {
    if (block.current) {
      consequent_transitions.add(transition2);
      transition2.finished(() => {
        consequent_transitions.delete(transition2);
        remove_in_transitions(consequent_transitions);
        if (consequent_transitions.size === 0) {
          execute_effect(consequent_effect);
        }
      });
    } else {
      alternate_transitions.add(transition2);
      transition2.finished(() => {
        alternate_transitions.delete(transition2);
        remove_in_transitions(alternate_transitions);
        if (alternate_transitions.size === 0) {
          execute_effect(alternate_effect);
        }
      });
    }
  };
  const if_effect = render_effect(
    () => {
      var _a, _b;
      const result = !!condition_fn();
      if (block.current !== result || !has_mounted) {
        block.current = result;
        if (has_mounted) {
          if (result) {
            remove_in_transitions(alternate_transitions);
            if (alternate_transitions.size === 0) {
              execute_effect(alternate_effect);
            } else {
              trigger_transitions(alternate_transitions, "out");
            }
            if (consequent_transitions.size === 0) {
              execute_effect(consequent_effect);
            } else {
              trigger_transitions(consequent_transitions, "in");
            }
          } else {
            remove_in_transitions(consequent_transitions);
            if (consequent_transitions.size === 0) {
              execute_effect(consequent_effect);
            } else {
              trigger_transitions(consequent_transitions, "out");
            }
            if (alternate_transitions.size === 0) {
              execute_effect(alternate_effect);
            } else {
              trigger_transitions(alternate_transitions, "in");
            }
          }
        } else if (current_hydration_fragment !== null) {
          const comment_text = (
            /** @type {Comment} */
            (_b = (_a = current_hydration_fragment) == null ? void 0 : _a[0]) == null ? void 0 : _b.data
          );
          if (!comment_text && // Can happen when a svelte:element that is turned into a void element has an if block inside
          current_hydration_fragment[0] !== null || comment_text === "ssr:if:true" && !result || comment_text === "ssr:if:false" && result) {
            remove(current_hydration_fragment);
            set_current_hydration_fragment(null);
          } else {
            current_hydration_fragment.shift();
          }
        }
        has_mounted = true;
      }
    },
    block,
    false
  );
  const consequent_effect = render_effect(
    () => {
      if (consequent_dom !== null) {
        remove(consequent_dom);
        consequent_dom = null;
      }
      if (block.current) {
        consequent_fn(anchor_node);
        if (!has_mounted_branch) {
          set_current_hydration_fragment(previous_hydration_fragment);
          has_mounted_branch = true;
        }
      }
      consequent_dom = block.dom;
      block.dom = null;
    },
    block,
    true
  );
  const alternate_effect = render_effect(
    () => {
      if (alternate_dom !== null) {
        remove(alternate_dom);
        alternate_dom = null;
      }
      if (!block.current) {
        if (alternate_fn !== null) {
          alternate_fn(anchor_node);
        }
        if (!has_mounted_branch) {
          set_current_hydration_fragment(previous_hydration_fragment);
          has_mounted_branch = true;
        }
      }
      alternate_dom = block.dom;
      block.dom = null;
    },
    block,
    true
  );
  push_destroy_fn(if_effect, () => {
    if (consequent_dom !== null) {
      remove(consequent_dom);
    }
    if (alternate_dom !== null) {
      remove(alternate_dom);
    }
    destroy_signal(consequent_effect);
    destroy_signal(alternate_effect);
  });
  block.effect = if_effect;
}
function head(render_fn) {
  const block = create_head_block();
  const hydration_fragment = current_hydration_fragment !== null ? get_hydration_fragment(document.head.firstChild) : null;
  const previous_hydration_fragment = current_hydration_fragment;
  set_current_hydration_fragment(hydration_fragment);
  try {
    const head_effect = render_effect(
      () => {
        const current = block.dom;
        if (current !== null) {
          remove(current);
          block.dom = null;
        }
        let anchor = null;
        if (current_hydration_fragment === null) {
          anchor = empty();
          document.head.appendChild(anchor);
        }
        render_fn(anchor);
      },
      block,
      false
    );
    push_destroy_fn(head_effect, () => {
      const current = block.dom;
      if (current !== null) {
        remove(current);
      }
    });
    block.effect = head_effect;
  } finally {
    set_current_hydration_fragment(previous_hydration_fragment);
  }
}
function swap_block_dom(block, from, to) {
  const dom = block.dom;
  if (is_array(dom)) {
    for (let i = 0; i < dom.length; i++) {
      if (dom[i] === from) {
        dom[i] = to;
        break;
      }
    }
  } else if (dom === from) {
    block.dom = to;
  }
}
function element(anchor_node, tag_fn, render_fn, is_svg = false) {
  const block = create_dynamic_element_block();
  hydrate_block_anchor(anchor_node);
  let has_mounted = false;
  let tag;
  let element2 = null;
  const element_effect = render_effect(
    () => {
      tag = tag_fn();
      if (has_mounted) {
        execute_effect(render_effect_signal);
      }
      has_mounted = true;
    },
    block,
    false
  );
  const render_effect_signal = render_effect(
    () => {
      const next_element = tag ? current_hydration_fragment !== null ? (
        /** @type {HTMLElement | SVGElement} */
        current_hydration_fragment[0]
      ) : is_svg ? document.createElementNS("http://www.w3.org/2000/svg", tag) : document.createElement(tag) : null;
      const prev_element = element2;
      if (prev_element !== null) {
        block.dom = null;
      }
      element2 = next_element;
      if (element2 !== null && render_fn !== null) {
        let anchor;
        if (current_hydration_fragment !== null) {
          anchor = /** @type {Comment} */
          element2.firstChild;
        } else {
          anchor = empty();
          element2.appendChild(anchor);
        }
        render_fn(element2, anchor);
      }
      const has_prev_element = prev_element !== null;
      if (has_prev_element) {
        remove(prev_element);
      }
      if (element2 !== null) {
        insert(element2, null, anchor_node);
        if (has_prev_element) {
          const parent_block = block.parent;
          swap_block_dom(parent_block, prev_element, element2);
        }
      }
    },
    block,
    true
  );
  push_destroy_fn(element_effect, () => {
    if (element2 !== null) {
      remove(element2);
      block.dom = null;
      element2 = null;
    }
    destroy_signal(render_effect_signal);
  });
  block.effect = element_effect;
}
function component(anchor_node, component_fn, render_fn) {
  const block = create_dynamic_component_block();
  let current_render = null;
  hydrate_block_anchor(anchor_node);
  let component2 = null;
  block.transition = /**
   * @param {import('./types.js').Transition} transition
   * @returns {void}
   */
  (transition2) => {
    const render2 = (
      /** @type {import('./types.js').Render} */
      current_render
    );
    const transitions = render2.transitions;
    transitions.add(transition2);
    transition2.finished(() => {
      transitions.delete(transition2);
      remove_in_transitions(transitions);
      if (transitions.size === 0) {
        if (render2.effect !== null) {
          if (render2.dom !== null) {
            remove(render2.dom);
            render2.dom = null;
          }
          destroy_signal(render2.effect);
          render2.effect = null;
        }
      }
    });
  };
  const create_render_effect = () => {
    const render2 = {
      dom: null,
      effect: null,
      transitions: /* @__PURE__ */ new Set(),
      prev: current_render
    };
    const effect2 = render_effect(
      () => {
        const current = block.dom;
        if (current !== null) {
          remove(current);
          block.dom = null;
        }
        if (component2) {
          render_fn(component2);
        }
        render2.dom = block.dom;
        block.dom = null;
      },
      block,
      true
    );
    render2.effect = effect2;
    current_render = render2;
  };
  const render = () => {
    const render2 = current_render;
    if (render2 === null) {
      create_render_effect();
      return;
    }
    const transitions = render2.transitions;
    if (transitions.size === 0) {
      if (render2.dom !== null) {
        remove(render2.dom);
        render2.dom = null;
      }
      if (render2.effect) {
        execute_effect(render2.effect);
      } else {
        create_render_effect();
      }
    } else {
      create_render_effect();
      trigger_transitions(transitions, "out");
    }
  };
  const component_effect = render_effect(
    () => {
      const next_component = component_fn();
      if (component2 !== next_component) {
        component2 = next_component;
        render();
      }
    },
    block,
    false
  );
  push_destroy_fn(component_effect, () => {
    let render2 = current_render;
    while (render2 !== null) {
      const dom = render2.dom;
      if (dom !== null) {
        remove(dom);
      }
      const effect2 = render2.effect;
      if (effect2 !== null) {
        destroy_signal(effect2);
      }
      render2 = render2.prev;
    }
  });
  block.effect = component_effect;
}
function await_block(anchor_node, input, pending_fn, then_fn, catch_fn) {
  const block = create_await_block();
  let current_render = null;
  hydrate_block_anchor(anchor_node);
  let latest_token;
  let resolved_value = UNINITIALIZED;
  let error = UNINITIALIZED;
  let pending = false;
  block.transition = /**
   * @param {import('./types.js').Transition} transition
   * @returns {void}
   */
  (transition2) => {
    const render2 = (
      /** @type {import('./types.js').Render} */
      current_render
    );
    const transitions = render2.transitions;
    transitions.add(transition2);
    transition2.finished(() => {
      transitions.delete(transition2);
      remove_in_transitions(transitions);
      if (transitions.size === 0) {
        if (render2.effect !== null) {
          if (render2.dom !== null) {
            remove(render2.dom);
            render2.dom = null;
          }
          destroy_signal(render2.effect);
          render2.effect = null;
        }
      }
    });
  };
  const create_render_effect = () => {
    const render2 = {
      dom: null,
      effect: null,
      transitions: /* @__PURE__ */ new Set(),
      prev: current_render
    };
    const effect2 = render_effect(
      () => {
        if (error === UNINITIALIZED) {
          if (resolved_value === UNINITIALIZED) {
            block.pending = true;
            if (pending_fn !== null) {
              pending_fn(anchor_node);
            }
          } else if (then_fn !== null) {
            block.pending = false;
            then_fn(anchor_node, resolved_value);
          }
        } else if (catch_fn !== null) {
          block.pending = false;
          catch_fn(anchor_node, error);
        }
        render2.dom = block.dom;
        block.dom = null;
      },
      block,
      true,
      true
    );
    render2.effect = effect2;
    current_render = render2;
  };
  const render = () => {
    const render2 = current_render;
    if (render2 === null) {
      create_render_effect();
      return;
    }
    const transitions = render2.transitions;
    remove_in_transitions(transitions);
    if (transitions.size === 0) {
      if (render2.dom !== null) {
        remove(render2.dom);
        render2.dom = null;
      }
      if (render2.effect) {
        execute_effect(render2.effect);
      } else {
        create_render_effect();
      }
    } else {
      create_render_effect();
      trigger_transitions(transitions, "out");
    }
  };
  const await_effect = render_effect(
    () => {
      const token = {};
      latest_token = token;
      const promise = is_signal(input) ? get(input) : typeof input === "function" ? input() : input;
      if (is_promise(promise)) {
        promise.then(
          /** @param {V} v */
          (v) => {
            if (latest_token === token) {
              flushSync();
              resolved_value = v;
              pending = false;
              render();
            }
          },
          /** @param {unknown} _error */
          (_error) => {
            error = _error;
            pending = false;
            render();
          }
        );
        if (resolved_value !== UNINITIALIZED || error !== UNINITIALIZED) {
          error = UNINITIALIZED;
          resolved_value = UNINITIALIZED;
        }
        if (!pending) {
          pending = true;
          render();
        }
      } else {
        error = UNINITIALIZED;
        resolved_value = promise;
        pending = false;
        render();
      }
    },
    block,
    false
  );
  push_destroy_fn(await_effect, () => {
    let render2 = current_render;
    latest_token = {};
    while (render2 !== null) {
      const dom = render2.dom;
      if (dom !== null) {
        remove(dom);
      }
      const effect2 = render2.effect;
      if (effect2 !== null) {
        destroy_signal(effect2);
      }
      render2 = render2.prev;
    }
  });
  block.effect = await_effect;
}
function key(anchor_node, key2, render_fn) {
  const block = create_key_block();
  let current_render = null;
  hydrate_block_anchor(anchor_node);
  let key_value = UNINITIALIZED;
  let mounted = false;
  block.transition = /**
   * @param {import('./types.js').Transition} transition
   * @returns {void}
   */
  (transition2) => {
    const render2 = (
      /** @type {import('./types.js').Render} */
      current_render
    );
    const transitions = render2.transitions;
    transitions.add(transition2);
    transition2.finished(() => {
      transitions.delete(transition2);
      remove_in_transitions(transitions);
      if (transitions.size === 0) {
        if (render2.effect !== null) {
          if (render2.dom !== null) {
            remove(render2.dom);
            render2.dom = null;
          }
          destroy_signal(render2.effect);
          render2.effect = null;
        }
      }
    });
  };
  const create_render_effect = () => {
    const render2 = {
      dom: null,
      effect: null,
      transitions: /* @__PURE__ */ new Set(),
      prev: current_render
    };
    const effect2 = render_effect(
      () => {
        render_fn(anchor_node);
        render2.dom = block.dom;
        block.dom = null;
      },
      block,
      true,
      true
    );
    render2.effect = effect2;
    current_render = render2;
  };
  const render = () => {
    const render2 = current_render;
    if (render2 === null) {
      create_render_effect();
      return;
    }
    const transitions = render2.transitions;
    remove_in_transitions(transitions);
    if (transitions.size === 0) {
      if (render2.dom !== null) {
        remove(render2.dom);
        render2.dom = null;
      }
      if (render2.effect) {
        execute_effect(render2.effect);
      } else {
        create_render_effect();
      }
    } else {
      trigger_transitions(transitions, "out");
      create_render_effect();
    }
  };
  const key_effect = render_effect(
    () => {
      const prev_key_value = key_value;
      key_value = key2();
      if (mounted && safe_not_equal(prev_key_value, key_value)) {
        render();
      }
    },
    block,
    false
  );
  render();
  mounted = true;
  push_destroy_fn(key_effect, () => {
    let render2 = current_render;
    while (render2 !== null) {
      const dom = render2.dom;
      if (dom !== null) {
        remove(dom);
      }
      const effect2 = render2.effect;
      if (effect2 !== null) {
        destroy_signal(effect2);
      }
      render2 = render2.prev;
    }
  });
  block.effect = key_effect;
}
function get_first_element(block) {
  const current = block.dom;
  if (is_array(current)) {
    for (let i = 0; i < current.length; i++) {
      const node = current[i];
      if (node.nodeType !== 8) {
        return node;
      }
    }
  }
  return (
    /** @type {Text | Element | Comment} */
    current
  );
}
function update_each_item_block(block, item, index, type) {
  if ((type & EACH_ITEM_REACTIVE) !== 0) {
    set_signal_value(block.item, item);
  }
  const transitions = block.transitions;
  const index_is_reactive = (type & EACH_INDEX_REACTIVE) !== 0;
  if (transitions !== null && (type & EACH_KEYED) !== 0) {
    let prev_index = block.index;
    if (index_is_reactive) {
      prev_index = /** @type {import('./types.js').Signal<number>} */
      prev_index.v;
    }
    const items = block.parent.items;
    if (prev_index !== index && /** @type {number} */
    index < items.length) {
      const from_dom = (
        /** @type {Element} */
        get_first_element(block)
      );
      const from = from_dom.getBoundingClientRect();
      schedule_task(() => {
        trigger_transitions(transitions, "key", from);
      });
    }
  }
  if (index_is_reactive) {
    set_signal_value(
      /** @type {import('./types.js').Signal<number>} */
      block.index,
      index
    );
  } else {
    block.index = index;
  }
}
function destroy_each_item_block(block, transition_block, apply_transitions, controlled = false) {
  const transitions = block.transitions;
  if (apply_transitions && transitions !== null) {
    trigger_transitions(transitions, "out");
    if (transition_block !== null) {
      transition_block.push(block);
    }
  } else {
    const dom = block.dom;
    if (!controlled && dom !== null) {
      remove(dom);
    }
    destroy_signal(
      /** @type {import('./types.js').EffectSignal} */
      block.effect
    );
  }
}
function each_item_block(item, key2, index, render_fn, flags) {
  const item_value = (flags & EACH_ITEM_REACTIVE) === 0 ? item : source(item);
  const index_value = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);
  const block = create_each_item_block(item_value, index_value, key2);
  const effect2 = render_effect(
    /** @param {import('./types.js').EachItemBlock} block */
    (block2) => {
      render_fn(null, block2.item, block2.index);
    },
    block,
    true
  );
  block.effect = effect2;
  return block;
}
function each(anchor_node, collection, flags, key_fn, render_fn, fallback_fn, reconcile_fn) {
  const is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;
  const block = create_each_block(flags, anchor_node);
  let current_fallback = null;
  hydrate_block_anchor(anchor_node, is_controlled);
  let array;
  let keys = null;
  let render = null;
  block.transition = /** @param {import('./types.js').Transition} transition */
  (transition2) => {
    const fallback = (
      /** @type {import('./types.js').Render} */
      current_fallback
    );
    const transitions = fallback.transitions;
    transitions.add(transition2);
    transition2.finished(() => {
      transitions.delete(transition2);
      remove_in_transitions(transitions);
      if (transitions.size === 0) {
        if (fallback.effect !== null) {
          if (fallback.dom !== null) {
            remove(fallback.dom);
            fallback.dom = null;
          }
          destroy_signal(fallback.effect);
          fallback.effect = null;
        }
      }
    });
  };
  const create_fallback_effect = () => {
    const fallback = {
      dom: null,
      effect: null,
      transitions: /* @__PURE__ */ new Set(),
      prev: current_fallback
    };
    const effect2 = render_effect(
      () => {
        const dom = block.dom;
        if (dom !== null) {
          remove(dom);
          block.dom = null;
        }
        let anchor = block.anchor;
        const is_controlled2 = (block.flags & EACH_IS_CONTROLLED) !== 0;
        if (is_controlled2) {
          anchor = empty();
          block.anchor.appendChild(anchor);
        }
        fallback_fn(anchor);
        fallback.dom = block.dom;
        block.dom = null;
      },
      block,
      true
    );
    fallback.effect = effect2;
    current_fallback = fallback;
  };
  const each2 = render_effect(
    () => {
      const maybe_array = collection();
      array = is_array(maybe_array) ? maybe_array : maybe_array == null ? [] : Array.from(maybe_array);
      if (key_fn !== null) {
        keys = array.map(key_fn);
      }
      if (fallback_fn !== null) {
        if (array.length === 0) {
          if (block.items.length !== 0 || render === null) {
            create_fallback_effect();
          }
        } else if (block.items.length === 0 && current_fallback !== null) {
          const fallback = current_fallback;
          const transitions = fallback.transitions;
          if (transitions.size === 0) {
            if (fallback.dom !== null) {
              remove(fallback.dom);
              fallback.dom = null;
            }
          } else {
            trigger_transitions(transitions, "out");
          }
        }
      }
      if (render !== null) {
        execute_effect(render);
      }
    },
    block,
    false
  );
  render = render_effect(
    /** @param {import('./types.js').EachBlock} block */
    (block2) => {
      const flags2 = block2.flags;
      const is_controlled2 = (flags2 & EACH_IS_CONTROLLED) !== 0;
      const anchor_node2 = block2.anchor;
      reconcile_fn(array, block2, anchor_node2, is_controlled2, render_fn, flags2, true, keys);
    },
    block,
    true
  );
  push_destroy_fn(each2, () => {
    const flags2 = block.flags;
    const is_controlled2 = (flags2 & EACH_IS_CONTROLLED) !== 0;
    const anchor_node2 = block.anchor;
    let fallback = current_fallback;
    while (fallback !== null) {
      const dom = fallback.dom;
      if (dom !== null) {
        remove(dom);
      }
      const effect2 = fallback.effect;
      if (effect2 !== null) {
        destroy_signal(effect2);
      }
      fallback = fallback.prev;
    }
    reconcile_fn([], block, anchor_node2, is_controlled2, render_fn, flags2, false, keys);
    destroy_signal(
      /** @type {import('./types.js').EffectSignal} */
      render
    );
  });
  block.effect = each2;
}
function each_keyed(anchor_node, collection, flags, key_fn, render_fn, fallback_fn) {
  each(anchor_node, collection, flags, key_fn, render_fn, fallback_fn, reconcile_tracked_array);
}
function each_indexed(anchor_node, collection, flags, render_fn, fallback_fn) {
  each(anchor_node, collection, flags, null, render_fn, fallback_fn, reconcile_indexed_array);
}
function cssProps(anchor, is_html, props, component2) {
  hydrate_block_anchor(anchor);
  let tag;
  let component_anchor;
  if (current_hydration_fragment !== null) {
    tag = /** @type {HTMLElement | SVGElement} */
    current_hydration_fragment[0];
    component_anchor = /** @type {Comment} */
    tag.firstChild;
  } else {
    if (is_html) {
      tag = document.createElement("div");
      tag.style.display = "contents";
    } else {
      tag = document.createElementNS("http://www.w3.org/2000/svg", "g");
    }
    insert(tag, null, anchor);
    component_anchor = empty();
    tag.appendChild(component_anchor);
  }
  component2(component_anchor);
  let current_props = {};
  const effect2 = render_effect(() => {
    const next_props = props();
    for (const key2 in current_props) {
      if (!(key2 in next_props)) {
        tag.style.removeProperty(key2);
      }
    }
    for (const key2 in next_props) {
      tag.style.setProperty(key2, next_props[key2]);
    }
    current_props = next_props;
  });
  push_destroy_fn(effect2, () => {
    remove(tag);
  });
}
function stringify(value) {
  return typeof value === "string" ? value : value == null ? "" : value + "";
}
function html(dom, get_value, svg) {
  let html_dom;
  let value;
  const effect2 = render_effect(() => {
    if (value !== (value = get_value())) {
      if (html_dom) {
        remove(html_dom);
      }
      html_dom = reconcile_html(dom, value, svg);
    }
  });
  push_destroy_fn(effect2, () => {
    if (html_dom) {
      remove(html_dom);
    }
  });
}
function transition(dom, transition_fn, props, global = false) {
  bind_transition(dom, transition_fn, props, "both", global);
}
function animate(dom, transition_fn, props) {
  bind_transition(dom, transition_fn, props, "key", false);
}
function in_fn(dom, transition_fn, props, global = false) {
  bind_transition(dom, transition_fn, props, "in", global);
}
function out(dom, transition_fn, props, global = false) {
  bind_transition(dom, transition_fn, props, "out", global);
}
function action(dom, action2, value_fn) {
  let payload = void 0;
  effect(() => {
    if (value_fn) {
      const value = value_fn();
      untrack(() => {
        if (payload === void 0) {
          payload = action2(dom, value);
        } else {
          const update = payload.update;
          if (typeof update === "function") {
            update(value);
          }
        }
      });
    } else {
      untrack(() => payload = action2(dom));
    }
  });
  effect(() => {
    if (payload !== void 0) {
      const destroy = payload.destroy;
      if (typeof destroy === "function") {
        return () => {
          destroy();
        };
      }
    }
  });
}
function remove_input_attr_defaults(dom) {
  if (current_hydration_fragment !== null) {
    attr(dom, "value", null);
    attr(dom, "checked", null);
  }
}
function remove_textarea_child(dom) {
  if (current_hydration_fragment !== null && dom.firstChild !== null) {
    dom.textContent = "";
  }
}
function attr_effect(dom, attribute, value) {
  render_effect(() => {
    const string = value();
    attr(dom, attribute, string);
  });
}
function attr(dom, attribute, value) {
  value = value == null ? null : value + "";
  if (DEV) {
    check_src_in_dev_hydration(dom, attribute, value);
  }
  if (current_hydration_fragment === null || dom.getAttribute(attribute) !== value && // If we reset those, they would result in another network request, which we want to avoid.
  // We assume they are the same between client and server as checking if they are equal is expensive
  // (we can't just compare the strings as they can be different between client and server but result in the
  // same url, so we would need to create hidden anchor elements to compare them)
  attribute !== "src" && attribute !== "srcset") {
    if (value === null) {
      dom.removeAttribute(attribute);
    } else {
      dom.setAttribute(attribute, value);
    }
  }
}
var src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (element_src === url)
    return true;
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function split_srcset(srcset) {
  return srcset.split(",").map((src) => src.trim().split(" ").filter(Boolean));
}
function srcset_url_equal(element_srcset, srcset) {
  const element_urls = split_srcset(element_srcset.srcset);
  const urls = split_srcset(srcset || "");
  return urls.length === element_urls.length && urls.every(
    ([url, width], i) => width === element_urls[i][1] && // We need to test both ways because Vite will create an a full URL with
    // `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the
    // relative URLs inside srcset are not automatically resolved to absolute URLs by
    // browsers (in contrast to img.src). This means both SSR and DOM code could
    // contain relative or absolute URLs.
    (src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))
  );
}
function check_src_in_dev_hydration(dom, attribute, value) {
  if (current_hydration_fragment !== null && (attribute === "src" || attribute === "srcset")) {
    if (attribute === "src" && !src_url_equal(dom.getAttribute("src") || "", value || "") || attribute === "srcset" && !srcset_url_equal(
      /** @type {HTMLImageElement | HTMLSourceElement} */
      dom,
      value || ""
    )) {
      console.error(
        "Detected a src/srcset attribute value change during hydration. This will not be repaired during hydration, the src/srcset value that came from the server will be used. Related element:",
        dom,
        " Differing value:",
        value
      );
    }
  }
}
function xlink_attr_effect(dom, attribute, value) {
  render_effect(() => {
    const string = value();
    xlink_attr(dom, attribute, string);
  });
}
function xlink_attr(dom, attribute, value) {
  dom.setAttributeNS("http://www.w3.org/1999/xlink", attribute, value);
}
function set_custom_element_data_effect(node, prop2, value) {
  render_effect(() => {
    set_custom_element_data(node, prop2, value());
  });
}
function set_custom_element_data(node, prop2, value) {
  if (prop2 in node) {
    node[prop2] = typeof node[prop2] === "boolean" && value === "" ? true : value;
  } else {
    attr(node, prop2, value);
  }
}
function style(dom, key2, value, important) {
  if (value == null) {
    dom.style.removeProperty(key2);
  } else {
    dom.style.setProperty(key2, value, important ? "important" : "");
  }
}
var always_set_through_set_attribute = ["width", "height"];
var setters_cache = /* @__PURE__ */ new Map();
function get_setters(element2) {
  const setters = [];
  const descriptors = get_descriptors(element2.__proto__);
  for (const key2 in descriptors) {
    if (descriptors[key2].set && !always_set_through_set_attribute.includes(key2)) {
      setters.push(key2);
    }
  }
  return setters;
}
function spread_attributes(dom, prev, attrs, css_hash) {
  const next = Object.assign({}, ...attrs);
  const has_hash = css_hash.length !== 0;
  for (const key2 in prev) {
    if (!(key2 in next)) {
      next[key2] = null;
    }
  }
  if (has_hash && !next.class) {
    next.class = "";
  }
  let setters = map_get(setters_cache, dom.nodeName);
  if (!setters)
    map_set(setters_cache, dom.nodeName, setters = get_setters(dom));
  for (const key2 in next) {
    let value = next[key2];
    if (value === (prev == null ? void 0 : prev[key2]))
      continue;
    const prefix = key2.slice(0, 2);
    if (prefix === "$$")
      continue;
    if (prefix === "on") {
      const opts = {};
      let event_name = key2.slice(2).toLowerCase();
      const delegated = DelegatedEvents.includes(event_name);
      if (event_name.endsWith("capture") && event_name !== "ongotpointercapture" && event_name !== "onlostpointercapture") {
        event_name = event_name.slice(0, -7);
        opts.capture = true;
      }
      if (!delegated && (prev == null ? void 0 : prev[key2])) {
        dom.removeEventListener(
          event_name,
          /** @type {any} */
          prev[key2],
          opts
        );
      }
      if (value != null) {
        if (!delegated) {
          dom.addEventListener(event_name, value, opts);
        } else {
          dom[`__${event_name}`] = value;
          delegate([event_name]);
        }
      }
    } else if (value == null) {
      dom.removeAttribute(key2);
    } else if (key2 === "style") {
      dom.style.cssText = value + "";
    } else if (key2 === "autofocus") {
      auto_focus(
        /** @type {HTMLElement} */
        dom,
        Boolean(value)
      );
    } else if (key2 === "__value" || key2 === "value") {
      dom.value = dom[key2] = dom.__value = value;
    } else if (setters.includes(key2)) {
      if (DEV) {
        check_src_in_dev_hydration(dom, key2, value);
      }
      if (current_hydration_fragment === null || //  @ts-ignore see attr method for an explanation of src/srcset
      dom[key2] !== value && key2 !== "src" && key2 !== "srcset") {
        dom[key2] = value;
      }
    } else if (typeof value !== "function") {
      if (has_hash && key2 === "class") {
        if (value)
          value += " ";
        value += css_hash;
      }
      attr(dom, key2, value);
    }
  }
  return next;
}
function spread_dynamic_element_attributes(node, prev, attrs, css_hash) {
  if (node.tagName.includes("-")) {
    const next = Object.assign({}, ...attrs);
    if (prev !== null) {
      for (const key2 in prev) {
        if (!(key2 in next)) {
          next[key2] = null;
        }
      }
    }
    for (const key2 in next) {
      set_custom_element_data(node, key2, next[key2]);
    }
    return next;
  } else {
    return spread_attributes(
      /** @type {Element & ElementCSSInlineStyle} */
      node,
      prev,
      attrs,
      css_hash
    );
  }
}
function rest_props(props_signal, rest) {
  return derived(() => {
    var props = unwrap(props_signal);
    var rest_props2 = {};
    for (var key2 in props) {
      if (rest.includes(key2))
        continue;
      const { get: get2, value, enumerable } = (
        /** @type {PropertyDescriptor} */
        get_descriptor(props, key2)
      );
      define_property(rest_props2, key2, get2 ? { get: get2, enumerable } : { value, enumerable });
    }
    return rest_props2;
  });
}
function spread_props(props) {
  if (typeof props === "function") {
    return derived(() => {
      return spread_props(props());
    });
  }
  const merged_props = {};
  let key2;
  for (let i = 0; i < props.length; i++) {
    const obj = props[i];
    for (key2 in obj) {
      const desc = (
        /** @type {PropertyDescriptor} */
        get_descriptor(obj, key2)
      );
      const getter = desc.get;
      if (getter !== void 0) {
        define_property(merged_props, key2, {
          enumerable: true,
          configurable: true,
          get: getter
        });
      } else if (desc.get !== void 0) {
        merged_props[key2] = obj[key2];
      } else {
        define_property(merged_props, key2, {
          enumerable: true,
          configurable: true,
          value: obj[key2]
        });
      }
    }
  }
  return merged_props;
}
function unwrap(value) {
  if (is_signal(value)) {
    return get(value);
  }
  return value;
}
function createRoot(component2, options) {
  const _props = {};
  const _sources = {};
  function add_prop(name, value) {
    const prop2 = source(
      value,
      options.immutable ? (
        /**
         * @param {any} a
         * @param {any} b
         */
        (a, b) => a === b
      ) : safe_equal
    );
    _sources[name] = prop2;
    define_property(_props, name, {
      get() {
        return get(prop2);
      },
      enumerable: true
    });
  }
  for (const prop2 in options.props || {}) {
    add_prop(
      prop2,
      // @ts-expect-error TS doesn't understand this properly
      options.props[prop2]
    );
  }
  const props_proxy = new Proxy(_props, {
    /**
     * @param {any} target
     * @param {any} property
     */
    get: (target, property) => {
      if (typeof property !== "string")
        return target[property];
      if (!(property in _sources)) {
        add_prop(property, void 0);
      }
      return _props[property];
    }
  });
  const props_source = source(
    props_proxy,
    // We're resetting the same proxy instance for updates, therefore bypass equality checks
    () => false
  );
  let [accessors, $destroy] = mount(component2, {
    ...options,
    // @ts-expect-error We hide the "the props object could be a signal" fact from the public typings
    props: props_source
  });
  const result = (
    /** @type {Exports & { $destroy: () => void; $set: (props: Partial<Props>) => void; }} */
    {
      $set: (props) => {
        for (const [prop2, value] of Object.entries(props)) {
          if (prop2 in _sources) {
            set(_sources[prop2], value);
          } else {
            add_prop(prop2, value);
            set(props_source, props_proxy);
          }
        }
      },
      $destroy
    }
  );
  for (const key2 of Object.keys(accessors || {})) {
    define_property(result, key2, {
      get() {
        return accessors[key2];
      },
      /** @param {any} value */
      set(value) {
        accessors[key2] = value;
      },
      enumerable: true
    });
  }
  return result;
}
function mount(component2, options) {
  var _a, _b;
  init_operations();
  const registered_events = /* @__PURE__ */ new Set();
  const container = options.target;
  const block = create_root_block(container, options.intro || false);
  const first_child = (
    /** @type {ChildNode} */
    container.firstChild
  );
  const hydration_fragment = get_hydration_fragment(first_child);
  const previous_hydration_fragment = current_hydration_fragment;
  let accessors = void 0;
  try {
    let anchor = null;
    if (hydration_fragment === null) {
      anchor = empty();
      container.appendChild(anchor);
    }
    set_current_hydration_fragment(hydration_fragment);
    const effect2 = render_effect(
      () => {
        if (options.context) {
          push({});
          current_component_context.context = options.context;
        }
        accessors = component2(anchor, options.props || {}, options.events || {});
        if (options.context) {
          pop();
        }
      },
      block,
      true
    );
    block.effect = effect2;
  } catch (error) {
    if (options.recover !== false && hydration_fragment !== null) {
      console.error(
        "Hydration failed because the initial UI does not match what was rendered on the server.",
        error
      );
      remove(hydration_fragment);
      first_child.remove();
      (_b = (_a = hydration_fragment.at(-1)) == null ? void 0 : _a.nextSibling) == null ? void 0 : _b.remove();
      return mount(component2, options);
    } else {
      throw error;
    }
  } finally {
    set_current_hydration_fragment(previous_hydration_fragment);
  }
  const bound_event_listener = handle_event_propagation.bind(null, container);
  const event_handle = (events) => {
    for (let i = 0; i < events.length; i++) {
      const event_name = events[i];
      if (!registered_events.has(event_name)) {
        registered_events.add(event_name);
        container.addEventListener(
          event_name,
          bound_event_listener,
          PassiveDelegatedEvents.includes(event_name) ? {
            passive: true
          } : void 0
        );
      }
    }
  };
  event_handle(array_from(all_registerd_events));
  root_event_handles.add(event_handle);
  return [
    accessors,
    () => {
      for (const event_name of registered_events) {
        container.removeEventListener(event_name, bound_event_listener);
      }
      root_event_handles.delete(event_handle);
      const dom = block.dom;
      if (dom !== null) {
        remove(dom);
      }
      if (hydration_fragment !== null) {
        remove(hydration_fragment);
      }
      destroy_signal(
        /** @type {import('./types.js').EffectSignal} */
        block.effect
      );
    }
  ];
}
function access_props(props) {
  for (const prop2 in props) {
    props[prop2];
  }
}
function sanitize_slots(props) {
  props = unwrap(props);
  const sanitized = { ...props.$$slots };
  if (props.children)
    sanitized.default = props.children;
  return sanitized;
}
function snippet_effect(create_snippet) {
  const block = create_snippet_block();
  render_effect(() => {
    create_snippet();
    return () => {
      if (block.dom !== null) {
        remove(block.dom);
      }
    };
  }, block);
}
async function append_styles(target, style_sheet_id, styles) {
  await Promise.resolve();
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style2 = create_element("style");
    style2.id = style_sheet_id;
    style2.textContent = styles;
    append_child(
      /** @type {Document} */
      append_styles_to.head || append_styles_to,
      style2
    );
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return (
    /** @type {Document} */
    node.ownerDocument
  );
}
function compile_error(message, filename, code_highlights) {
  const page = document.createElement("div");
  const container = document.createElement("div");
  const pre = document.createElement("pre");
  const h1 = document.createElement("h1");
  const h2 = document.createElement("h2");
  const p = document.createElement("p");
  h1.textContent = "Compilation Error";
  h2.textContent = message;
  p.textContent = filename;
  pre.appendChild(h1);
  pre.appendChild(h2);
  if (code_highlights) {
    const code_container = document.createElement("div");
    for (const line of code_highlights) {
      const code_line = document.createElement("div");
      const code_line_number = document.createElement("span");
      code_line_number.textContent = String(line.line);
      const code_source = document.createElement("span");
      code_source.textContent = line.source;
      if (line.highlight) {
        code_line.style.cssText = "padding:8px;background:#333;color:#fff";
      } else {
        code_line.style.cssText = "padding:8px;background:#000;color:#999";
      }
      code_line_number.style.cssText = "color:#888;padding:0 15px 0 5px;text-align:right;";
      code_line.appendChild(code_line_number);
      code_line.appendChild(code_source);
      code_container.appendChild(code_line);
    }
    pre.appendChild(code_container);
  }
  h1.style.cssText = "color:#ff5555;font-weight:normal;margin-top:0;padding:0;font-size:20px;";
  h2.style.cssText = "color:#ccc;font-weight:normal;margin-top:0;padding:0;font-size:16px;white-space:normal;";
  p.style.cssText = "color: #999;";
  page.style.cssText = "z-index:9999;margin:0;position:fixed;top: 0;left: 0;height:100%;width:100%;background:rgba(0,0,0,0.66)";
  container.style.cssText = `background:#181818;margin:30px auto;padding:25px 40px;position:relative;color:#d8d8d8;border-radius:6px 6px 8px 8px;width:800px;font-family:'SF Mono', SFMono-Regular, ui-monospace,'DejaVu Sans Mono', Menlo, Consolas, monospace;;border-top:8px solid #ff5555;`;
  pre.appendChild(p);
  container.appendChild(pre);
  page.appendChild(container);
  document.body.appendChild(page);
  console.error("[Compilation Error] " + message);
}

// node_modules/.pnpm/svelte@5.0.0-next.7/node_modules/svelte/src/internal/client/runtime.js
var SOURCE = 1;
var DERIVED = 1 << 1;
var EFFECT = 1 << 2;
var PRE_EFFECT = 1 << 3;
var RENDER_EFFECT = 1 << 4;
var SYNC_EFFECT = 1 << 5;
var MANAGED = 1 << 6;
var UNOWNED = 1 << 7;
var CLEAN = 1 << 8;
var DIRTY = 1 << 9;
var MAYBE_DIRTY = 1 << 10;
var INERT = 1 << 11;
var DESTROYED = 1 << 12;
var IS_EFFECT = EFFECT | PRE_EFFECT | RENDER_EFFECT | SYNC_EFFECT;
var FLUSH_MICROTASK = 0;
var FLUSH_SYNC = 1;
var MAX_SAFE_INT = Number.MAX_SAFE_INTEGER;
var UNINITIALIZED = Symbol();
var current_scheduler_mode = FLUSH_MICROTASK;
var is_micro_task_queued = false;
var is_task_queued = false;
var is_signal_exposed = false;
var current_queued_pre_and_render_effects = [];
var current_queued_effects = [];
var current_queued_tasks = [];
var flush_count = 0;
var current_consumer = null;
var current_effect = null;
var current_dependencies = null;
var current_dependencies_index = 0;
var current_should_capture_signal = false;
var current_untracking = false;
var ignore_mutation_validation = false;
var current_captured_signal = null;
var current_skip_consumer = false;
var is_signals_recorded = false;
var captured_signals = /* @__PURE__ */ new Set();
var current_block = null;
var current_component_context = null;
var is_ssr = false;
function create_component_context(props) {
  const parent = current_component_context;
  return {
    effects: null,
    props,
    parent,
    accessors: null,
    context: null,
    immutable: false,
    mounted: false,
    runes: false,
    update_callbacks: null
  };
}
function is_runes(context) {
  const component_context = context || current_component_context;
  return component_context !== null && component_context.runes;
}
function default_equals(a, b) {
  return a === b;
}
function create_source_signal(flags, value) {
  return {
    c: null,
    // We can remove this if we get rid of beforeUpdate/afterUpdate
    x: null,
    e: null,
    f: flags,
    v: value
  };
}
function create_computation_signal(flags, value, block) {
  return {
    b: block,
    c: null,
    x: null,
    d: null,
    y: null,
    e: null,
    f: flags,
    i: null,
    r: null,
    v: value
  };
}
function push_reference(target_signal, ref_signal) {
  const references = target_signal.r;
  if (references === null) {
    target_signal.r = [ref_signal];
  } else {
    references.push(ref_signal);
  }
}
function is_signal_dirty(signal) {
  const flags = signal.f;
  if ((flags & DIRTY) !== 0 || signal.v === UNINITIALIZED) {
    return true;
  }
  if ((flags & MAYBE_DIRTY) !== 0) {
    const dependencies = (
      /** @type {import('./types.js').ComputationSignal<V>} **/
      signal.d
    );
    if (dependencies !== null) {
      const length = dependencies.length;
      let i;
      for (i = 0; i < length; i++) {
        const dependency = dependencies[i];
        if ((dependency.f & MAYBE_DIRTY) !== 0 && !is_signal_dirty(dependency)) {
          set_signal_status(dependency, CLEAN);
          continue;
        }
        if ((dependency.f & DIRTY) !== 0) {
          if ((dependency.f & DERIVED) !== 0) {
            update_derived(
              /** @type {import('./types.js').ComputationSignal<V>} **/
              dependency,
              true
            );
            if ((signal.f & DIRTY) !== 0) {
              return true;
            }
          } else {
            return true;
          }
        }
      }
    }
  }
  return false;
}
function execute_signal_fn(signal) {
  const init = signal.i;
  const previous_dependencies = current_dependencies;
  const previous_dependencies_index = current_dependencies_index;
  const previous_consumer = current_consumer;
  const previous_block = current_block;
  const previous_component_context = current_component_context;
  const previous_skip_consumer = current_skip_consumer;
  const is_render_effect = (signal.f & RENDER_EFFECT) !== 0;
  const previous_untracking = current_untracking;
  current_dependencies = /** @type {null | import('./types.js').Signal[]} */
  null;
  current_dependencies_index = 0;
  current_consumer = signal;
  current_block = signal.b;
  current_component_context = signal.x;
  current_skip_consumer = current_effect === null && (signal.f & UNOWNED) !== 0;
  current_untracking = false;
  if (is_render_effect && (current_component_context == null ? void 0 : current_component_context.update_callbacks) != null) {
    current_component_context.update_callbacks.execute();
  }
  try {
    let res;
    if (is_render_effect) {
      res = /** @type {(block: import('./types.js').Block) => V} */
      init(
        /** @type {import('./types.js').Block} */
        signal.b
      );
    } else {
      res = /** @type {() => V} */
      init();
    }
    let dependencies = (
      /** @type {import('./types.js').Signal<unknown>[]} **/
      signal.d
    );
    if (current_dependencies !== null) {
      let i;
      remove_consumer(signal, current_dependencies_index, false);
      if (dependencies !== null && current_dependencies_index > 0) {
        dependencies.length = current_dependencies_index + current_dependencies.length;
        for (i = 0; i < current_dependencies.length; i++) {
          dependencies[current_dependencies_index + i] = current_dependencies[i];
        }
      } else {
        signal.d = /** @type {import('./types.js').Signal<V>[]} **/
        dependencies = current_dependencies;
      }
      if (!current_skip_consumer) {
        for (i = current_dependencies_index; i < dependencies.length; i++) {
          const dependency = dependencies[i];
          if (dependency.c === null) {
            dependency.c = [signal];
          } else {
            dependency.c.push(signal);
          }
        }
      }
    } else if (dependencies !== null && current_dependencies_index < dependencies.length) {
      remove_consumer(signal, current_dependencies_index, false);
      dependencies.length = current_dependencies_index;
    }
    return res;
  } finally {
    current_dependencies = previous_dependencies;
    current_dependencies_index = previous_dependencies_index;
    current_consumer = previous_consumer;
    current_block = previous_block;
    current_component_context = previous_component_context;
    current_skip_consumer = previous_skip_consumer;
    current_untracking = previous_untracking;
  }
}
function remove_consumer(signal, start_index, remove_unowned) {
  const dependencies = signal.d;
  if (dependencies !== null) {
    let i;
    for (i = start_index; i < dependencies.length; i++) {
      const dependency = dependencies[i];
      const consumers = dependency.c;
      let consumers_length = 0;
      if (consumers !== null) {
        consumers_length = consumers.length - 1;
        if (consumers_length === 0) {
          dependency.c = null;
        } else {
          const index = consumers.indexOf(signal);
          consumers[index] = consumers[consumers_length];
          consumers.pop();
        }
      }
      if (remove_unowned && consumers_length === 0 && (dependency.f & UNOWNED) !== 0) {
        remove_consumer(
          /** @type {import('./types.js').ComputationSignal<V>} **/
          dependency,
          0,
          true
        );
      }
    }
  }
}
function destroy_references(signal) {
  const references = signal.r;
  signal.r = null;
  if (references !== null) {
    let i;
    for (i = 0; i < references.length; i++) {
      const reference = references[i];
      if ((reference.f & IS_EFFECT) !== 0) {
        destroy_signal(reference);
      } else {
        remove_consumer(reference, 0, true);
        reference.d = null;
      }
    }
  }
}
function report_error(block, error) {
  let current_block2 = block;
  if (current_block2 !== null) {
    throw error;
  }
}
function execute_effect(signal) {
  if ((signal.f & DESTROYED) !== 0) {
    return;
  }
  const teardown = signal.v;
  const previous_effect = current_effect;
  current_effect = signal;
  try {
    destroy_references(signal);
    if (teardown !== null) {
      teardown();
    }
    const possible_teardown = execute_signal_fn(signal);
    if (typeof possible_teardown === "function") {
      signal.v = possible_teardown;
    }
  } catch (error) {
    const block = signal.b;
    if (block !== null) {
      report_error(block, error);
    } else {
      throw error;
    }
  } finally {
    current_effect = previous_effect;
  }
  const component_context = signal.x;
  if (is_runes(component_context) && // Don't rerun pre effects more than once to accomodate for "$: only runs once" behavior
  (signal.f & PRE_EFFECT) !== 0 && current_queued_pre_and_render_effects.length > 0) {
    flush_local_pre_effects(component_context);
  }
}
function flush_queued_effects(effects) {
  const length = effects.length;
  if (length > 0) {
    if (flush_count > 100) {
      throw new Error(
        "Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops."
      );
    }
    flush_count++;
    let i;
    for (i = 0; i < length; i++) {
      const signal = effects[i];
      const flags = signal.f;
      if ((flags & (DESTROYED | INERT)) === 0) {
        if (is_signal_dirty(signal)) {
          set_signal_status(signal, CLEAN);
          execute_effect(signal);
        } else if ((flags & MAYBE_DIRTY) !== 0) {
          set_signal_status(signal, CLEAN);
        }
      }
    }
    effects.length = 0;
  }
}
function process_microtask() {
  is_micro_task_queued = false;
  if (flush_count > 101) {
    return;
  }
  const previous_queued_pre_and_render_effects = current_queued_pre_and_render_effects;
  const previous_queued_effects = current_queued_effects;
  current_queued_pre_and_render_effects = [];
  current_queued_effects = [];
  flush_queued_effects(previous_queued_pre_and_render_effects);
  flush_queued_effects(previous_queued_effects);
  if (!is_micro_task_queued) {
    flush_count = 0;
  }
}
function schedule_effect(signal, sync) {
  const flags = signal.f;
  if (sync || (flags & SYNC_EFFECT) !== 0) {
    execute_effect(signal);
    set_signal_status(signal, CLEAN);
  } else {
    if (current_scheduler_mode === FLUSH_MICROTASK) {
      if (!is_micro_task_queued) {
        is_micro_task_queued = true;
        queueMicrotask(process_microtask);
      }
    }
    if ((flags & EFFECT) !== 0) {
      current_queued_effects.push(signal);
    } else {
      current_queued_pre_and_render_effects.push(signal);
    }
  }
}
function process_task() {
  is_task_queued = false;
  const tasks = current_queued_tasks.slice();
  current_queued_tasks = [];
  for (let i = 0; i < tasks.length; i++) {
    tasks[i]();
  }
}
function schedule_task(fn) {
  if (!is_task_queued) {
    is_task_queued = true;
    setTimeout(process_task, 0);
  }
  current_queued_tasks.push(fn);
}
function flush_local_render_effects() {
  const effects = [];
  for (let i = 0; i < current_queued_pre_and_render_effects.length; i++) {
    const effect2 = current_queued_pre_and_render_effects[i];
    if ((effect2.f & RENDER_EFFECT) !== 0 && effect2.x === current_component_context) {
      effects.push(effect2);
      current_queued_pre_and_render_effects.splice(i, 1);
      i--;
    }
  }
  flush_queued_effects(effects);
}
function flush_local_pre_effects(context) {
  const effects = [];
  for (let i = 0; i < current_queued_pre_and_render_effects.length; i++) {
    const effect2 = current_queued_pre_and_render_effects[i];
    if ((effect2.f & PRE_EFFECT) !== 0 && effect2.x === context) {
      effects.push(effect2);
      current_queued_pre_and_render_effects.splice(i, 1);
      i--;
    }
  }
  flush_queued_effects(effects);
}
function flushSync(fn) {
  const previous_scheduler_mode = current_scheduler_mode;
  const previous_queued_pre_and_render_effects = current_queued_pre_and_render_effects;
  const previous_queued_effects = current_queued_effects;
  try {
    const pre_and_render_effects = [];
    const effects = [];
    current_scheduler_mode = FLUSH_SYNC;
    flush_count = 0;
    current_queued_pre_and_render_effects = pre_and_render_effects;
    current_queued_effects = effects;
    flush_queued_effects(previous_queued_pre_and_render_effects);
    flush_queued_effects(previous_queued_effects);
    if (fn !== void 0) {
      fn();
    }
    if (current_queued_pre_and_render_effects.length > 0 || effects.length > 0) {
      flushSync();
    }
    if (is_task_queued) {
      process_task();
    }
  } finally {
    current_scheduler_mode = previous_scheduler_mode;
    current_queued_pre_and_render_effects = previous_queued_pre_and_render_effects;
    current_queued_effects = previous_queued_effects;
  }
}
async function tick() {
  await Promise.resolve();
  flushSync();
}
function update_derived(signal, force_schedule) {
  const value = execute_signal_fn(signal);
  const status = current_skip_consumer || current_effect === null && (signal.f & UNOWNED) !== 0 ? DIRTY : CLEAN;
  set_signal_status(signal, status);
  const equals = (
    /** @type {import('./types.js').EqualsFunctions} */
    signal.e
  );
  if (!equals(value, signal.v)) {
    signal.v = value;
    mark_signal_consumers(signal, DIRTY, force_schedule);
  }
}
function store_get(store, store_name, stores) {
  let entry = stores[store_name];
  const is_new = entry === void 0;
  if (is_new) {
    entry = {
      store: null,
      last_value: null,
      value: source(UNINITIALIZED),
      unsubscribe: EMPTY_FUNC
    };
    stores[store_name] = entry;
  }
  if (is_new || entry.store !== store) {
    entry.unsubscribe();
    entry.store = store ?? null;
    entry.unsubscribe = connect_store_to_signal(store, entry.value);
  }
  const value = get(entry.value);
  return value === UNINITIALIZED ? entry.last_value : value;
}
function connect_store_to_signal(store, source2) {
  if (store == null) {
    set(source2, void 0);
    return EMPTY_FUNC;
  }
  const run = (v) => {
    ignore_mutation_validation = true;
    set(source2, v);
    ignore_mutation_validation = false;
  };
  return subscribe_to_store(store, run);
}
function store_set(store, value) {
  store.set(value);
  return value;
}
function unsubscribe_on_destroy(stores) {
  onDestroy(() => {
    let store_name;
    for (store_name in stores) {
      const ref = stores[store_name];
      ref.unsubscribe();
    }
  });
}
function exposable(fn) {
  const previous_is_signal_exposed = is_signal_exposed;
  try {
    is_signal_exposed = true;
    return fn();
  } finally {
    is_signal_exposed = previous_is_signal_exposed;
  }
}
function get(signal) {
  const flags = signal.f;
  if ((flags & DESTROYED) !== 0) {
    return signal.v;
  }
  if (is_signal_exposed && current_should_capture_signal) {
    current_captured_signal = signal;
  }
  if (is_signals_recorded) {
    captured_signals.add(signal);
  }
  if (current_consumer !== null && (current_consumer.f & MANAGED) === 0 && !current_untracking) {
    const unowned = (current_consumer.f & UNOWNED) !== 0;
    const dependencies = current_consumer.d;
    if (current_dependencies === null && dependencies !== null && dependencies[current_dependencies_index] === signal && !(unowned && current_effect !== null)) {
      current_dependencies_index++;
    } else if (current_dependencies === null) {
      current_dependencies = [signal];
    } else if (signal !== current_dependencies[current_dependencies.length - 1]) {
      current_dependencies.push(signal);
    }
  }
  if ((flags & DERIVED) !== 0 && is_signal_dirty(signal)) {
    update_derived(
      /** @type {import('./types.js').ComputationSignal<V>} **/
      signal,
      false
    );
  }
  return signal.v;
}
function set(signal, value) {
  set_signal_value(signal, value);
  return value;
}
function set_sync(signal, value) {
  flushSync(() => set_signal_value(signal, value));
}
function expose(possible_signal_fn) {
  const previous_captured_signal = current_captured_signal;
  const previous_should_capture_signal = current_should_capture_signal;
  current_captured_signal = null;
  current_should_capture_signal = true;
  try {
    const value = possible_signal_fn();
    if (current_captured_signal === null) {
      return value;
    }
    return current_captured_signal;
  } finally {
    current_captured_signal = previous_captured_signal;
    current_should_capture_signal = previous_should_capture_signal;
  }
}
function invalidate_inner_signals(fn) {
  const previous_is_signals_recorded = is_signals_recorded;
  const previous_captured_signals = captured_signals;
  is_signals_recorded = true;
  captured_signals = /* @__PURE__ */ new Set();
  try {
    untrack(fn);
  } finally {
    is_signals_recorded = previous_is_signals_recorded;
    let signal2;
    for (signal2 of captured_signals) {
      previous_captured_signals.add(signal2);
    }
    captured_signals = previous_captured_signals;
  }
  let signal;
  for (signal of captured_signals) {
    mutate(
      signal,
      null
      /* doesnt matter */
    );
  }
  return captured_signals;
}
function mutate(source2, value) {
  set_signal_value(
    source2,
    untrack(() => get(source2))
  );
  return value;
}
function mutate_store(store, expression, new_value) {
  store.set(new_value);
  return expression;
}
function mark_subtree_inert(signal, inert) {
  const flags = signal.f;
  const is_already_inert = (flags & INERT) !== 0;
  if (is_already_inert !== inert) {
    signal.f ^= INERT;
    if (!inert && (flags & IS_EFFECT) !== 0 && (flags & CLEAN) === 0) {
      schedule_effect(
        /** @type {import('./types.js').EffectSignal} */
        signal,
        false
      );
    }
  }
  const references = signal.r;
  if (references !== null) {
    let i;
    for (i = 0; i < references.length; i++) {
      mark_subtree_inert(references[i], inert);
    }
  }
}
function mark_signal_consumers(signal, to_status, force_schedule) {
  const runes = is_runes(signal.x);
  const consumers = signal.c;
  if (consumers !== null) {
    const length = consumers.length;
    let i;
    for (i = 0; i < length; i++) {
      const consumer = consumers[i];
      const flags = consumer.f;
      const unowned = (flags & UNOWNED) !== 0;
      const dirty = (flags & DIRTY) !== 0;
      if (dirty && !unowned || (!force_schedule || !runes) && consumer === current_effect) {
        continue;
      }
      set_signal_status(consumer, to_status);
      if ((flags & CLEAN) !== 0 || dirty && unowned) {
        if ((consumer.f & IS_EFFECT) !== 0) {
          schedule_effect(
            /** @type {import('./types.js').EffectSignal} */
            consumer,
            false
          );
        } else {
          mark_signal_consumers(consumer, MAYBE_DIRTY, force_schedule);
        }
      }
    }
  }
}
function set_signal_value(signal, value) {
  if (!current_untracking && !ignore_mutation_validation && current_consumer !== null && is_runes(signal.x) && (current_consumer.f & DERIVED) !== 0) {
    throw new Error(
      `Unsafe mutations during Svelte's render or derived phase are not permitted in runes mode. This can lead to unexpected errors and possibly cause infinite loops.

If this mutation is not meant to be reactive do not use the "$state" rune for that declaration.`
    );
  }
  if ((signal.f & SOURCE) !== 0 && !/** @type {import('./types.js').EqualsFunctions} */
  signal.e(value, signal.v)) {
    const component_context = signal.x;
    signal.v = value;
    if (is_runes(component_context) && current_effect !== null && current_effect.c === null && (current_effect.f & CLEAN) !== 0 && current_dependencies !== null && current_dependencies.includes(signal)) {
      set_signal_status(current_effect, DIRTY);
      schedule_effect(current_effect, false);
    }
    mark_signal_consumers(signal, DIRTY, true);
    if (current_effect === null && current_queued_pre_and_render_effects.length === 0) {
      const update_callbacks = component_context == null ? void 0 : component_context.update_callbacks;
      if (update_callbacks != null) {
        update_callbacks.before.forEach(
          /** @param {any} c */
          (c) => c()
        );
        const managed = managed_effect(() => {
          destroy_signal(managed);
          update_callbacks.after.forEach(
            /** @param {any} c */
            (c) => c()
          );
        });
      }
    }
  }
}
function destroy_signal(signal) {
  const teardown = (
    /** @type {null | (() => void)} */
    signal.v
  );
  const destroy = signal.y;
  const flags = signal.f;
  destroy_references(signal);
  remove_consumer(signal, 0, true);
  signal.i = null;
  signal.r = null;
  signal.y = null;
  signal.x = null;
  signal.b = null;
  signal.v = /** @type {V} */
  null;
  signal.d = null;
  signal.c = null;
  set_signal_status(signal, DESTROYED);
  if (destroy !== null) {
    if (is_array(destroy)) {
      let i;
      for (i = 0; i < destroy.length; i++) {
        destroy[i]();
      }
    } else {
      destroy();
    }
  }
  if (teardown !== null && (flags & IS_EFFECT) !== 0) {
    teardown();
  }
}
function derived(init, equals) {
  const is_unowned = current_effect === null;
  const flags = is_unowned ? DERIVED | UNOWNED : DERIVED;
  const signal = (
    /** @type {import('./types.js').ComputationSignal<V>} */
    create_computation_signal(flags | CLEAN, UNINITIALIZED, current_block)
  );
  signal.i = init;
  signal.x = current_component_context;
  signal.e = get_equals_method(equals);
  if (!is_unowned) {
    push_reference(
      /** @type {import('./types.js').EffectSignal} */
      current_effect,
      signal
    );
  }
  return signal;
}
function source(initial_value, equals) {
  const source2 = create_source_signal(SOURCE | CLEAN, initial_value);
  source2.x = current_component_context;
  source2.e = get_equals_method(equals);
  return source2;
}
function get_equals_method(equals) {
  if (equals !== void 0) {
    return equals;
  }
  const context = current_component_context;
  if (context && !context.immutable) {
    return safe_equal;
  }
  return default_equals;
}
function untrack(fn) {
  const previous_untracking = current_untracking;
  try {
    current_untracking = true;
    return fn();
  } finally {
    current_untracking = previous_untracking;
  }
}
function internal_create_effect(type, init, sync, block, schedule) {
  const signal = create_computation_signal(type | DIRTY, null, block);
  signal.i = init;
  signal.x = current_component_context;
  if (schedule) {
    schedule_effect(signal, sync);
  }
  if (current_effect !== null && (type & MANAGED) === 0) {
    push_reference(current_effect, signal);
  }
  return signal;
}
function user_effect(init) {
  if (current_effect === null) {
    throw new Error("The Svelte $effect rune can only be used during component initialisation.");
  }
  const apply_component_effect_heuristics = current_effect.f & RENDER_EFFECT && current_component_context !== null && !current_component_context.mounted;
  const effect2 = internal_create_effect(
    EFFECT,
    init,
    false,
    current_block,
    !apply_component_effect_heuristics
  );
  if (apply_component_effect_heuristics) {
    let effects = (
      /** @type {import('./types.js').ComponentContext} */
      current_component_context.effects
    );
    if (effects === null) {
      effects = /** @type {import('./types.js').ComponentContext} */
      current_component_context.effects = [];
    }
    effects.push(effect2);
  }
  return effect2;
}
function effect(init) {
  return internal_create_effect(EFFECT, init, false, current_block, true);
}
function managed_effect(init) {
  return internal_create_effect(EFFECT | MANAGED, init, false, current_block, true);
}
function managed_pre_effect(init, sync) {
  return internal_create_effect(PRE_EFFECT | MANAGED, init, sync, current_block, true);
}
function pre_effect(init) {
  if (current_effect === null) {
    throw new Error(
      "The Svelte $effect.pre rune can only be used during component initialisation."
    );
  }
  const sync = current_effect !== null && (current_effect.f & RENDER_EFFECT) !== 0;
  return internal_create_effect(
    PRE_EFFECT,
    () => {
      const val = init();
      flush_local_render_effects();
      return val;
    },
    sync,
    current_block,
    true
  );
}
function sync_effect(init) {
  return internal_create_effect(SYNC_EFFECT, init, true, current_block, true);
}
function render_effect(init, block = current_block, managed = false, sync = true) {
  let flags = RENDER_EFFECT;
  if (managed) {
    flags |= MANAGED;
  }
  return internal_create_effect(
    flags,
    /** @type {any} */
    init,
    sync,
    block,
    true
  );
}
function push_destroy_fn(signal, destroy_fn) {
  let destroy = signal.y;
  if (destroy === null) {
    signal.y = destroy_fn;
  } else if (is_array(destroy)) {
    destroy.push(destroy_fn);
  } else {
    signal.y = [destroy, destroy_fn];
  }
}
function set_signal_status(signal, status) {
  const flags = signal.f;
  if ((flags & status) === 0) {
    if ((flags & MAYBE_DIRTY) !== 0) {
      signal.f ^= MAYBE_DIRTY;
    } else if ((flags & CLEAN) !== 0) {
      signal.f ^= CLEAN;
    } else if ((flags & DIRTY) !== 0) {
      signal.f ^= DIRTY;
    }
    signal.f ^= status;
  }
}
function is_signal(val) {
  return typeof val === "object" && val !== null && typeof /** @type {import('./types.js').Signal<V>} */
  val.f === "number";
}
function prop_source(props_obj, key2, default_value, call_default_value) {
  var _a;
  const props = is_signal(props_obj) ? get(props_obj) : props_obj;
  const possible_signal = (
    /** @type {import('./types.js').MaybeSignal<V>} */
    expose(() => props[key2])
  );
  const update_bound_prop = (_a = Object.getOwnPropertyDescriptor(props, key2)) == null ? void 0 : _a.set;
  let value = props[key2];
  const should_set_default_value = value === void 0 && default_value !== void 0;
  if (is_signal(possible_signal) && possible_signal.v === value && update_bound_prop === void 0 && get_equals_method() === possible_signal.e) {
    if (should_set_default_value) {
      set(
        possible_signal,
        // @ts-expect-error would need a cumbersome method overload to type this
        call_default_value ? default_value() : default_value
      );
    }
    return possible_signal;
  }
  if (should_set_default_value) {
    value = // @ts-expect-error would need a cumbersome method overload to type this
    call_default_value ? default_value() : default_value;
  }
  const source_signal = source(value);
  const immutable = (
    /** @type {import('./types.js').ComponentContext} */
    current_component_context.immutable
  );
  let ignore_next1 = false;
  let ignore_next2 = false;
  let mount2 = true;
  sync_effect(() => {
    const props2 = is_signal(props_obj) ? get(props_obj) : props_obj;
    const propagating_value = props2[key2];
    if (mount2) {
      mount2 = false;
      return;
    }
    if (ignore_next1) {
      ignore_next1 = false;
      return;
    }
    if (not_equal(immutable, propagating_value, source_signal.v)) {
      ignore_next2 = true;
      untrack(() => set_signal_value(source_signal, propagating_value));
    }
  });
  if (is_signal(possible_signal) && update_bound_prop !== void 0) {
    let ignore_first = !should_set_default_value;
    sync_effect(() => {
      const propagating_value = get(source_signal);
      if (ignore_first) {
        ignore_first = false;
        return;
      }
      if (ignore_next2) {
        ignore_next2 = false;
        return;
      }
      if (not_equal(immutable, propagating_value, possible_signal.v)) {
        ignore_next1 = true;
        untrack(() => update_bound_prop(propagating_value));
      }
    });
  }
  return (
    /** @type {import('./types.js').Signal<V>} */
    source_signal
  );
}
function prop(props_obj, key2) {
  return () => {
    const props = is_signal(props_obj) ? get(props_obj) : props_obj;
    return (
      /** @type {V} */
      props[key2]
    );
  };
}
function not_equal(immutable, a, b) {
  return immutable ? immutable_not_equal(a, b) : safe_not_equal(a, b);
}
function immutable_not_equal(a, b) {
  return a != a ? b == b : a !== b;
}
function safe_not_equal(a, b) {
  return a != a ? (
    // eslint-disable-next-line eqeqeq
    b == b
  ) : a !== b || a !== null && typeof a === "object" || typeof a === "function";
}
function safe_equal(a, b) {
  return !safe_not_equal(a, b);
}
function get_or_init_context_map() {
  const component_context = current_component_context;
  if (component_context === null) {
    throw new Error("Context can only be used during component initialisation.");
  }
  let context_map = component_context.context;
  if (context_map === null) {
    const parent_context = get_parent_context(component_context);
    context_map = component_context.context = new Map(parent_context || void 0);
  }
  return context_map;
}
function get_parent_context(component_context) {
  let parent = component_context.parent;
  while (parent !== null) {
    const context_map = parent.context;
    if (context_map !== null) {
      return context_map;
    }
    parent = parent.parent;
  }
  return null;
}
function bubble_event($$props, event2) {
  var _a;
  const events = (
    /** @type {Record<string, Function[] | Function>} */
    (_a = unwrap($$props).$$events) == null ? void 0 : _a[event2.type]
  );
  const callbacks = is_array(events) ? events.slice() : [events];
  let fn;
  for (fn of callbacks) {
    if (is_signal(fn)) {
      get(fn).call(this, event2);
    } else {
      fn.call(this, event2);
    }
  }
}
function increment(signal) {
  const value = get(signal);
  set_signal_value(signal, value + 1);
  return value;
}
function increment_store(store, store_value) {
  store.set(store_value + 1);
  return store_value;
}
function decrement(signal) {
  const value = get(signal);
  set_signal_value(signal, value - 1);
  return value;
}
function decrement_store(store, store_value) {
  store.set(store_value - 1);
  return store_value;
}
function increment_pre(signal) {
  const value = get(signal) + 1;
  set_signal_value(signal, value);
  return value;
}
function increment_pre_store(store, store_value) {
  const value = store_value + 1;
  store.set(value);
  return value;
}
function decrement_pre(signal) {
  const value = get(signal) - 1;
  set_signal_value(signal, value);
  return value;
}
function decrement_pre_store(store, store_value) {
  const value = store_value - 1;
  store.set(value);
  return value;
}
function reactive_import(fn) {
  const s = source(0);
  return function() {
    if (arguments.length === 1) {
      set(s, get(s) + 1);
      return arguments[0];
    } else {
      get(s);
      return fn();
    }
  };
}
function exclude_from_object(obj, keys) {
  obj = { ...obj };
  let key2;
  for (key2 of keys) {
    delete obj[key2];
  }
  return obj;
}
function value_or_fallback(value, fallback) {
  return value === void 0 ? fallback : value;
}
function onDestroy(fn) {
  if (!is_ssr) {
    user_effect(() => () => untrack(fn));
  }
}
function push(props, runes = false, immutable = false) {
  const context_stack_item = create_component_context(props);
  context_stack_item.runes = runes;
  context_stack_item.immutable = immutable;
  current_component_context = context_stack_item;
}
function pop(accessors) {
  const context_stack_item = current_component_context;
  if (context_stack_item !== null) {
    if (accessors !== void 0) {
      context_stack_item.accessors = accessors;
    }
    const effects = context_stack_item.effects;
    if (effects !== null) {
      context_stack_item.effects = null;
      for (let i = 0; i < effects.length; i++) {
        schedule_effect(effects[i], false);
      }
    }
    current_component_context = context_stack_item.parent;
    context_stack_item.mounted = true;
  }
}

// node_modules/.pnpm/svelte@5.0.0-next.7/node_modules/svelte/src/internal/client/validate.js
var void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;
function is_void(tag) {
  return void_element_names.test(tag) || tag.toLowerCase() === "!doctype";
}
function validate_store(store, name) {
  if (store != null && typeof store.subscribe !== "function") {
    throw new Error(`'${name}' is not a store with a 'subscribe' method`);
  }
}
function validate_dynamic_component(component_fn) {
  const error_message = "this={...} of <svelte:component> should specify a Svelte component.";
  try {
    const instance = component_fn();
    if (instance !== void 0 && typeof instance !== "object") {
      throw new Error(error_message);
    }
    return instance;
  } catch (err) {
    const { message } = (
      /** @type {Error} */
      err
    );
    if (typeof message === "string" && message.indexOf("is not a function") !== -1) {
      throw new Error(error_message);
    } else {
      throw err;
    }
  }
}
function validate_void_dynamic_element(tag_fn) {
  const tag = tag_fn();
  if (tag && is_void(tag)) {
    console.warn(`<svelte:element this="${tag}"> is self-closing and cannot have content.`);
  }
}
function validate_dynamic_element_tag(tag_fn) {
  const tag = tag_fn();
  const is_string = typeof tag === "string";
  if (tag && !is_string) {
    throw new Error('<svelte:element> expects "this" attribute to be a string.');
  }
}
function validate_each_keys(collection, key_fn) {
  const keys = /* @__PURE__ */ new Map();
  const maybe_array = collection();
  const array = is_array(maybe_array) ? maybe_array : maybe_array == null ? [] : Array.from(maybe_array);
  const length = array.length;
  for (let i = 0; i < length; i++) {
    const key2 = key_fn(array[i]);
    if (keys.has(key2)) {
      throw new Error(
        `Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(
          key2
        )} and ${i} with value '${array[i]}' are duplicates`
      );
    }
    keys.set(key2, i);
  }
}
function loop_guard(timeout) {
  const start = Date.now();
  return () => {
    if (Date.now() - start > timeout) {
      throw new Error("Infinite loop detected");
    }
  };
}
var snippet_symbol = Symbol.for("svelte.snippet");
function add_snippet_symbol(fn) {
  fn[snippet_symbol] = true;
  return fn;
}
function validate_snippet(snippet_fn) {
  if (snippet_fn[snippet_symbol] !== true) {
    throw new Error(
      "The argument to `{@render ...}` must be a snippet function, not a component or some other kind of function. If you want to dynamically render one snippet or another, use `$derived` and pass its result to `{@render ...}`."
    );
  }
  return snippet_fn;
}
function validate_component(component_fn) {
  if ((component_fn == null ? void 0 : component_fn[snippet_symbol]) === true) {
    throw new Error("A snippet must be rendered with `{@render ...}`");
  }
  return component_fn;
}

// node_modules/.pnpm/svelte@5.0.0-next.7/node_modules/svelte/src/internal/client/custom-element.js
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    /**
     * @param {*} $$componentCtor
     * @param {*} $$slots
     * @param {*} use_shadow_dom
     */
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** @type {any} The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** @type {Record<string, any>} Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      /** @type {any} The managed render effect for reflecting attributes */
      __publicField(this, "$$me");
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    /**
     * @param {string} type
     * @param {EventListenerOrEventListenerObject} listener
     * @param {boolean | AddEventListenerOptions} [options]
     */
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    /**
     * @param {string} type
     * @param {EventListenerOrEventListenerObject} listener
     * @param {boolean | AddEventListenerOptions} [options]
     */
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot = function(name) {
          return (anchor) => {
            const node = open(anchor, true, () => {
              const slot2 = document.createElement("slot");
              if (name !== "default") {
                slot2.name = name;
              }
              return slot2;
            });
            close(
              anchor,
              /** @type {Element} */
              node
            );
          };
        };
        await Promise.resolve();
        if (!this.$$cn) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            if (name === "default") {
              this.$$d.children = create_slot(name);
            } else {
              $$slots[name] = create_slot(name);
            }
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        this.$$c = createClassComponent({
          component: this.$$ctor,
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots
          }
        });
        this.$$me = render_effect(() => {
          var _a;
          this.$$r = true;
          for (const key2 of Object.keys(this.$$c)) {
            if (!((_a = this.$$p_d[key2]) == null ? void 0 : _a.reflect))
              continue;
            this.$$d[key2] = this.$$c[key2];
            const attribute_value = get_custom_element_value(
              key2,
              this.$$d[key2],
              this.$$p_d,
              "toAttribute"
            );
            if (attribute_value == null) {
              this.removeAttribute(this.$$p_d[key2].attribute || key2);
            } else {
              this.setAttribute(this.$$p_d[key2].attribute || key2, attribute_value);
            }
          }
          this.$$r = false;
        });
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    /**
     * @param {string} attr
     * @param {string} _oldValue
     * @param {string} newValue
     */
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn) {
          this.$$c.$destroy();
          destroy_signal(this.$$me);
          this.$$c = void 0;
        }
      });
    }
    /**
     * @param {string} attribute_name
     */
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key2) => this.$$p_d[key2].attribute === attribute_name || !this.$$p_d[key2].attribute && key2.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop2, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop2]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop2]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach((node) => {
    result[
      /** @type {Element} node */
      node.slot || "default"
    ] = true;
  });
  return result;
}
function create_custom_element(Component, props_definition, slots, accessors, use_shadow_dom, extend) {
  let Class = class extends SvelteElement {
    constructor() {
      super(Component, slots, use_shadow_dom);
      this.$$p_d = props_definition;
    }
    static get observedAttributes() {
      return Object.keys(props_definition).map(
        (key2) => (props_definition[key2].attribute || key2).toLowerCase()
      );
    }
  };
  Object.keys(props_definition).forEach((prop2) => {
    define_property(Class.prototype, prop2, {
      get() {
        return this.$$c && prop2 in this.$$c ? this.$$c[prop2] : this.$$d[prop2];
      },
      set(value) {
        var _a;
        value = get_custom_element_value(prop2, value, props_definition);
        this.$$d[prop2] = value;
        (_a = this.$$c) == null ? void 0 : _a.$set({ [prop2]: value });
      }
    });
  });
  accessors.forEach((accessor) => {
    define_property(Class.prototype, accessor, {
      get() {
        var _a;
        return (_a = this.$$c) == null ? void 0 : _a[accessor];
      }
    });
  });
  if (extend) {
    Class = extend(Class);
  }
  Component.element = /** @type {any} */
  Class;
  return Class;
}

// node_modules/.pnpm/svelte@5.0.0-next.7/node_modules/svelte/src/legacy/legacy-client.js
function createClassComponent(options) {
  return new Svelte4Component(options);
}
function asClassComponent(component2) {
  return class extends Svelte4Component {
    /** @param {any} options */
    constructor(options) {
      super({
        component: component2,
        ...options
      });
    }
  };
}
var _events, _instance;
var Svelte4Component = class {
  /**
   * @param {import('../main/public.js').ComponentConstructorOptions & {
   *  component: any;
   * 	immutable?: boolean;
   * 	recover?: false;
   * }} options
   */
  constructor(options) {
    /** @type {any} */
    __privateAdd(this, _events, {});
    /** @type {ReturnType<typeof $.createRoot>} */
    __privateAdd(this, _instance, void 0);
    __privateSet(this, _instance, createRoot(options.component, {
      target: options.target,
      props: { ...options.props, $$events: __privateGet(this, _events) },
      context: options.context,
      immutable: options.immutable,
      intro: options.intro,
      recover: options.recover
    }));
    for (const key2 of Object.keys(__privateGet(this, _instance))) {
      if (key2 === "$set" || key2 === "$destroy")
        continue;
      define_property(this, key2, {
        get() {
          return __privateGet(this, _instance)[key2];
        },
        /** @param {any} value */
        set(value) {
          __privateGet(this, _instance)[key2] = value;
        },
        enumerable: true
      });
    }
  }
  /** @param {Record<string, any>} props */
  $set(props) {
    __privateGet(this, _instance).$set(props);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(event2, callback) {
    __privateGet(this, _events)[event2] = __privateGet(this, _events)[event2] || [];
    const cb = (...args) => callback.call(this, ...args);
    __privateGet(this, _events)[event2].push(cb);
    return () => {
      __privateGet(this, _events)[event2] = __privateGet(this, _events)[event2].filter(
        /** @param {any} fn */
        (fn) => fn !== cb
      );
    };
  }
  $destroy() {
    __privateGet(this, _instance).$destroy();
  }
};
_events = new WeakMap();
_instance = new WeakMap();

export {
  is_array,
  $window,
  $document,
  child,
  child_frag,
  sibling,
  empty,
  template,
  svg_template,
  svg_replace,
  open,
  open_frag,
  close,
  close_frag,
  trusted,
  self,
  stopPropagation,
  once,
  stopImmediatePropagation,
  preventDefault,
  event,
  class_name_effect,
  class_name,
  text_effect,
  text,
  auto_focus,
  to_class,
  class_toggle,
  select_option,
  bind_online,
  bind_current_time,
  bind_buffered,
  bind_seekable,
  bind_played,
  bind_seeking,
  bind_ended,
  bind_ready_state,
  bind_playback_rate,
  bind_paused,
  bind_volume,
  bind_muted,
  bind_resize_observer,
  bind_element_size,
  bind_window_size,
  selected,
  bind_value,
  bind_select_value,
  bind_content_editable,
  bind_group,
  bind_checked,
  bind_window_scroll,
  bind_property,
  bind_prop,
  bind_this,
  delegate,
  slot,
  if_block,
  head,
  element,
  component,
  await_block,
  key,
  update_each_item_block,
  destroy_each_item_block,
  each_item_block,
  each_keyed,
  each_indexed,
  cssProps,
  stringify,
  html,
  transition,
  animate,
  in_fn,
  out,
  action,
  remove_input_attr_defaults,
  remove_textarea_child,
  attr_effect,
  attr,
  src_url_equal,
  srcset_url_equal,
  xlink_attr_effect,
  xlink_attr,
  set_custom_element_data_effect,
  set_custom_element_data,
  style,
  spread_attributes,
  spread_dynamic_element_attributes,
  rest_props,
  spread_props,
  unwrap,
  createRoot,
  mount,
  access_props,
  sanitize_slots,
  snippet_effect,
  append_styles,
  compile_error,
  current_component_context,
  is_ssr,
  flush_local_render_effects,
  flushSync,
  tick,
  store_get,
  store_set,
  unsubscribe_on_destroy,
  exposable,
  get,
  set,
  set_sync,
  expose,
  invalidate_inner_signals,
  mutate,
  mutate_store,
  destroy_signal,
  derived,
  source,
  untrack,
  user_effect,
  managed_effect,
  pre_effect,
  render_effect,
  is_signal,
  prop_source,
  prop,
  safe_equal,
  get_or_init_context_map,
  bubble_event,
  increment,
  increment_store,
  decrement,
  decrement_store,
  increment_pre,
  increment_pre_store,
  decrement_pre,
  decrement_pre_store,
  reactive_import,
  exclude_from_object,
  value_or_fallback,
  onDestroy,
  push,
  pop,
  validate_store,
  validate_dynamic_component,
  validate_void_dynamic_element,
  validate_dynamic_element_tag,
  validate_each_keys,
  loop_guard,
  add_snippet_symbol,
  validate_snippet,
  validate_component,
  createClassComponent,
  asClassComponent,
  create_custom_element
};
//# sourceMappingURL=chunk-7TSOLIEW.js.map
