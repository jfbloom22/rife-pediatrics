{
  "version": 3,
  "sources": ["../../.pnpm/svelte@5.0.0-next.7/node_modules/svelte/src/internal/client/utils.js", "../../.pnpm/svelte@5.0.0-next.7/node_modules/svelte/src/internal/client/hydration.js", "../../.pnpm/svelte@5.0.0-next.7/node_modules/svelte/src/internal/client/operations.js", "../../.pnpm/svelte@5.0.0-next.7/node_modules/svelte/src/internal/client/block.js", "../../.pnpm/svelte@5.0.0-next.7/node_modules/svelte/src/constants.js", "../../.pnpm/svelte@5.0.0-next.7/node_modules/svelte/src/internal/client/reconciler.js", "../../.pnpm/svelte@5.0.0-next.7/node_modules/svelte/src/internal/client/transitions.js", "../../.pnpm/svelte@5.0.0-next.7/node_modules/svelte/src/internal/client/render.js", "../../.pnpm/svelte@5.0.0-next.7/node_modules/svelte/src/internal/client/runtime.js", "../../.pnpm/svelte@5.0.0-next.7/node_modules/svelte/src/internal/client/validate.js", "../../.pnpm/svelte@5.0.0-next.7/node_modules/svelte/src/internal/client/custom-element.js", "../../.pnpm/svelte@5.0.0-next.7/node_modules/svelte/src/legacy/legacy-client.js"],
  "sourcesContent": ["// Store the references to globals in case someone tries to monkey patch these, causing the below\n// to de-opt (this occurs often when using popular extensions).\nexport const object_ref = Object;\nexport const array_ref = Array;\n\nexport const is_array = array_ref.isArray;\nexport const array_from = array_ref.from;\nexport const define_property = object_ref.defineProperty;\nexport const get_descriptor = object_ref.getOwnPropertyDescriptor;\nexport const get_descriptors = object_ref.getOwnPropertyDescriptors;\n", "// Handle hydration\n\n/** @type {null | Array<Text | Comment | Element>} */\nexport let current_hydration_fragment = null;\n\n/**\n * @param {null | Array<Text | Comment | Element>} fragment\n * @returns {void}\n */\nexport function set_current_hydration_fragment(fragment) {\n\tcurrent_hydration_fragment = fragment;\n}\n\n/**\n * Returns all nodes between the first `<!--ssr:...-->` comment tag pair encountered.\n * @param {Node | null} node\n * @returns {Array<Text | Comment | Element> | null}\n */\nexport function get_hydration_fragment(node) {\n\t/** @type {Array<Text | Comment | Element>} */\n\tconst fragment = [];\n\n\t/** @type {null | Node} */\n\tlet current_node = node;\n\n\t/** @type {null | string} */\n\tlet target_depth = null;\n\twhile (current_node !== null) {\n\t\tconst node_type = current_node.nodeType;\n\t\tconst next_sibling = current_node.nextSibling;\n\t\tif (node_type === 8) {\n\t\t\tconst data = /** @type {Comment} */ (current_node).data;\n\t\t\tif (data.startsWith('ssr:')) {\n\t\t\t\tconst depth = data.slice(4);\n\t\t\t\tif (target_depth === null) {\n\t\t\t\t\ttarget_depth = depth;\n\t\t\t\t} else if (depth === target_depth) {\n\t\t\t\t\treturn fragment;\n\t\t\t\t} else {\n\t\t\t\t\tfragment.push(/** @type {Text | Comment | Element} */ (current_node));\n\t\t\t\t}\n\t\t\t\tcurrent_node = next_sibling;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (target_depth !== null) {\n\t\t\tfragment.push(/** @type {Text | Comment | Element} */ (current_node));\n\t\t}\n\t\tcurrent_node = next_sibling;\n\t}\n\treturn null;\n}\n\n/**\n * @param {Text | Comment | Element} anchor_node\n * @param {boolean} [is_controlled]\n * @returns {void}\n */\nexport function hydrate_block_anchor(anchor_node, is_controlled) {\n\t/** @type {Node} */\n\tlet target_node = anchor_node;\n\tif (current_hydration_fragment !== null) {\n\t\tif (is_controlled) {\n\t\t\ttarget_node = /** @type {Node} */ (target_node.firstChild);\n\t\t}\n\t\tif (target_node.nodeType === 8) {\n\t\t\t// @ts-ignore\n\t\t\tlet fragment = target_node.$$fragment;\n\t\t\tif (fragment === undefined) {\n\t\t\t\tfragment = get_hydration_fragment(target_node);\n\t\t\t\t// @ts-ignore remove to prevent memory leaks\n\t\t\t\ttarget_node.$$fragment = undefined;\n\t\t\t}\n\t\t\tset_current_hydration_fragment(fragment);\n\t\t} else {\n\t\t\tset_current_hydration_fragment([/** @type {Element} */ (target_node.firstChild)]);\n\t\t}\n\t}\n}\n", "import { current_hydration_fragment, get_hydration_fragment } from './hydration.js';\nimport { get_descriptor } from './utils.js';\n\n// We cache the Node and Element prototype methods, so that we can avoid doing\n// expensive prototype chain lookups.\n\n/** @type {Node} */\nvar node_prototype;\n\n/** @type {Element} */\nvar element_prototype;\n\n/** @type {Text} */\nvar text_prototype;\n\n/** @type {Map<any, any>} */\nvar map_prototype;\n\n/** @type {typeof Node.prototype.appendChild} */\nvar append_child_method;\n\n/** @type {typeof Node.prototype.cloneNode} */\nvar clone_node_method;\n\n/** @type {typeof Map.prototype.set} */\nvar map_set_method;\n\n/** @type {typeof Map.prototype.get} */\nvar map_get_method;\n\n/** @type {typeof Map.prototype.delete} */\nvar map_delete_method;\n\n/** @type {(this: Node) => ChildNode | null} */\nvar first_child_get;\n\n/** @type {(this: Node) => ChildNode | null} */\nvar next_sibling_get;\n\n/** @type {(this: Node, text: string ) => void} */\nvar text_content_set;\n\n/** @type {(this: Element, class_name: string) => void} */\nvar class_name_set;\n\n// export these for reference in the compiled code, making global name deduplication unnecessary\n/**\n * @type {Window}\n */\nexport var $window;\n/**\n * @type {Document}\n */\nexport var $document;\n\n/**\n * Initialize these lazily to avoid issues when using the runtime in a server context\n * where these globals are not available while avoiding a separate server entry point\n */\nexport function init_operations() {\n\tif (node_prototype !== undefined) {\n\t\treturn;\n\t}\n\n\tnode_prototype = Node.prototype;\n\telement_prototype = Element.prototype;\n\ttext_prototype = Text.prototype;\n\tmap_prototype = Map.prototype;\n\n\tappend_child_method = node_prototype.appendChild;\n\tclone_node_method = node_prototype.cloneNode;\n\tmap_set_method = map_prototype.set;\n\tmap_get_method = map_prototype.get;\n\tmap_delete_method = map_prototype.delete;\n\n\t$window = window;\n\t$document = document;\n\n\t// the following assignments improve perf of lookups on DOM nodes\n\t// @ts-expect-error\n\telement_prototype.__click = undefined;\n\t// @ts-expect-error\n\ttext_prototype.__nodeValue = ' ';\n\t// @ts-expect-error\n\telement_prototype.__className = '';\n\n\tfirst_child_get = /** @type {(this: Node) => ChildNode | null} */ (\n\t\t// @ts-ignore\n\t\tget_descriptor(node_prototype, 'firstChild').get\n\t);\n\n\tnext_sibling_get = /** @type {(this: Node) => ChildNode | null} */ (\n\t\t// @ts-ignore\n\t\tget_descriptor(node_prototype, 'nextSibling').get\n\t);\n\n\ttext_content_set = /** @type {(this: Node, text: string ) => void} */ (\n\t\t// @ts-ignore\n\t\tget_descriptor(node_prototype, 'textContent').set\n\t);\n\n\tclass_name_set = /** @type {(this: Element, class_name: string) => void} */ (\n\t\t// @ts-ignore\n\t\tget_descriptor(element_prototype, 'className').set\n\t);\n}\n\n/**\n * @template {Element} E\n * @template {Node} T\n * @param {E} element\n * @param {T} child\n */\nexport function append_child(element, child) {\n\tappend_child_method.call(element, child);\n}\n\n/**\n * @template K\n * @template V\n * @param {Map<K, V>} map\n * @param {K} key\n * @param {V} value\n */\nexport function map_set(map, key, value) {\n\tmap_set_method.call(map, key, value);\n}\n\n/**\n * @template K\n * @template V\n * @param {Map<K, V>} map\n * @param {K} key\n */\nexport function map_delete(map, key) {\n\tmap_delete_method.call(map, key);\n}\n\n/**\n * @template K\n * @template V\n * @param {Map<K, V>} map\n * @param {K} key\n * @return {V}\n */\nexport function map_get(map, key) {\n\treturn map_get_method.call(map, key);\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @param {boolean} deep\n * @returns {N}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function clone_node(node, deep) {\n\treturn /** @type {N} */ (clone_node_method.call(node, deep));\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {Node | null}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function child(node) {\n\tconst child = first_child_get.call(node);\n\tif (current_hydration_fragment !== null) {\n\t\t// Child can be null if we have an element with a single child, like `<p>{text}</p>`, where `text` is empty\n\t\tif (child === null) {\n\t\t\tconst text = document.createTextNode('');\n\t\t\tnode.appendChild(text);\n\t\t\treturn text;\n\t\t} else {\n\t\t\treturn capture_fragment_from_node(child);\n\t\t}\n\t}\n\treturn child;\n}\n\n/**\n * @template {Node | Node[]} N\n * @param {N} node\n * @returns {Node | null}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function child_frag(node) {\n\tif (current_hydration_fragment !== null) {\n\t\tconst first_node = /** @type {Node[]} */ (node)[0];\n\t\tif (current_hydration_fragment !== null && first_node !== null) {\n\t\t\treturn capture_fragment_from_node(first_node);\n\t\t}\n\t\treturn first_node;\n\t}\n\treturn first_child_get.call(/** @type {Node} */ (node));\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {Node | null}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function sibling(node) {\n\tconst next_sibling = next_sibling_get.call(node);\n\tif (current_hydration_fragment !== null && next_sibling !== null) {\n\t\treturn capture_fragment_from_node(next_sibling);\n\t}\n\treturn next_sibling;\n}\n\n/**\n * @template {Element} N\n * @param {N} node\n * @param {string} class_name\n * @returns {void}\n */\nexport function set_class_name(node, class_name) {\n\tclass_name_set.call(node, class_name);\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {void}\n */\nexport function clear_text_content(node) {\n\ttext_content_set.call(node, '');\n}\n\n/** @param {string} name */\n/*#__NO_SIDE_EFFECTS__*/\nexport function create_element(name) {\n\treturn document.createElement(name);\n}\n\n/**\n * @param {Node} node\n * @returns {Node}\n */\nfunction capture_fragment_from_node(node) {\n\tif (\n\t\tnode.nodeType === 8 &&\n\t\t/** @type {Comment} */ (node).data.startsWith('ssr:') &&\n\t\t/** @type {Array<Element | Text | Comment>} */ (current_hydration_fragment).at(-1) !== node\n\t) {\n\t\tconst fragment = /** @type {Array<Element | Text | Comment>} */ (get_hydration_fragment(node));\n\t\tconst last_child = fragment.at(-1) || node;\n\t\tconst target = /** @type {Node} */ (last_child.nextSibling);\n\t\t// @ts-ignore\n\t\ttarget.$$fragment = fragment;\n\t\treturn target;\n\t}\n\treturn node;\n}\n", "import { current_block } from './runtime.js';\n\nexport const ROOT_BLOCK = 0;\nexport const IF_BLOCK = 1;\nexport const EACH_BLOCK = 2;\nexport const EACH_ITEM_BLOCK = 3;\nexport const AWAIT_BLOCK = 4;\nexport const KEY_BLOCK = 5;\nexport const HEAD_BLOCK = 6;\nexport const DYNAMIC_COMPONENT_BLOCK = 7;\nexport const DYNAMIC_ELEMENT_BLOCK = 8;\nexport const SNIPPET_BLOCK = 9;\n\n/**\n * @param {Node} container\n * @param {boolean} intro\n * @returns {import('./types.js').RootBlock}\n */\nexport function create_root_block(container, intro) {\n\treturn {\n\t\tdom: null,\n\t\teffect: null,\n\t\tcontainer,\n\t\tintro,\n\t\tparent: null,\n\t\ttransition: null,\n\t\ttype: ROOT_BLOCK\n\t};\n}\n\n/** @returns {import('./types.js').IfBlock} */\nexport function create_if_block() {\n\treturn {\n\t\tcurrent: false,\n\t\tdom: null,\n\t\teffect: null,\n\t\tparent: /** @type {import('./types.js').Block} */ (current_block),\n\t\ttransition: null,\n\t\ttype: IF_BLOCK\n\t};\n}\n\n/** @returns {import('./types.js').KeyBlock} */\nexport function create_key_block() {\n\treturn {\n\t\tdom: null,\n\t\teffect: null,\n\t\tparent: /** @type {import('./types.js').Block} */ (current_block),\n\t\ttransition: null,\n\t\ttype: KEY_BLOCK\n\t};\n}\n\n/** @returns {import('./types.js').HeadBlock} */\nexport function create_head_block() {\n\treturn {\n\t\tdom: null,\n\t\teffect: null,\n\t\tparent: /** @type {import('./types.js').Block} */ (current_block),\n\t\ttransition: null,\n\t\ttype: HEAD_BLOCK\n\t};\n}\n\n/** @returns {import('./types.js').DynamicElementBlock} */\nexport function create_dynamic_element_block() {\n\treturn {\n\t\tdom: null,\n\t\teffect: null,\n\t\tparent: /** @type {import('./types.js').Block} */ (current_block),\n\t\ttransition: null,\n\t\ttype: DYNAMIC_ELEMENT_BLOCK\n\t};\n}\n\n/** @returns {import('./types.js').DynamicComponentBlock} */\nexport function create_dynamic_component_block() {\n\treturn {\n\t\tdom: null,\n\t\teffect: null,\n\t\tparent: /** @type {import('./types.js').Block} */ (current_block),\n\t\ttransition: null,\n\t\ttype: DYNAMIC_COMPONENT_BLOCK\n\t};\n}\n\n/** @returns {import('./types.js').AwaitBlock} */\nexport function create_await_block() {\n\treturn {\n\t\tdom: null,\n\t\teffect: null,\n\t\tparent: /** @type {import('./types.js').Block} */ (current_block),\n\t\tpending: true,\n\t\ttransition: null,\n\t\ttype: AWAIT_BLOCK\n\t};\n}\n\n/**\n * @param {number} flags\n * @param {Element | Comment} anchor\n * @returns {import('./types.js').EachBlock}\n */\nexport function create_each_block(flags, anchor) {\n\treturn {\n\t\tanchor,\n\t\tdom: null,\n\t\tflags,\n\t\titems: [],\n\t\teffect: null,\n\t\tparent: /** @type {import('./types.js').Block} */ (current_block),\n\t\ttransition: null,\n\t\ttransitions: [],\n\t\ttype: EACH_BLOCK\n\t};\n}\n\n/**\n * @param {any | import('./types.js').Signal<any>} item\n * @param {number | import('./types.js').Signal<number>} index\n * @param {null | unknown} key\n * @returns {import('./types.js').EachItemBlock}\n */\nexport function create_each_item_block(item, index, key) {\n\treturn {\n\t\tdom: null,\n\t\teffect: null,\n\t\tindex,\n\t\tkey,\n\t\titem,\n\t\tparent: /** @type {import('./types.js').EachBlock} */ (current_block),\n\t\ttransition: null,\n\t\ttransitions: null,\n\t\ttype: EACH_ITEM_BLOCK\n\t};\n}\n\n/** @returns {import('./types.js').SnippetBlock} */\nexport function create_snippet_block() {\n\treturn {\n\t\tdom: null,\n\t\tparent: /** @type {import('./types.js').Block} */ (current_block),\n\t\teffect: null,\n\t\ttransition: null,\n\t\ttype: SNIPPET_BLOCK\n\t};\n}\n", "export const EACH_ITEM_REACTIVE = 1;\nexport const EACH_INDEX_REACTIVE = 1 << 1;\nexport const EACH_KEYED = 1 << 2;\nexport const EACH_IS_CONTROLLED = 1 << 3;\nexport const EACH_IS_ANIMATED = 1 << 4;\n\n/** List of Element events that will be delegated */\nexport const DelegatedEvents = [\n\t'beforeinput',\n\t'click',\n\t'dblclick',\n\t'contextmenu',\n\t'focusin',\n\t'focusout',\n\t// 'input', This conflicts with bind:input\n\t'keydown',\n\t'keyup',\n\t'mousedown',\n\t'mousemove',\n\t'mouseout',\n\t'mouseover',\n\t'mouseup',\n\t'pointerdown',\n\t'pointermove',\n\t'pointerout',\n\t'pointerover',\n\t'pointerup',\n\t'touchend',\n\t'touchmove',\n\t'touchstart'\n];\n\n/** List of Element events that will be delegated and are passive */\nexport const PassiveDelegatedEvents = ['touchstart', 'touchmove', 'touchend'];\n", "import { append_child, map_get, map_set, clear_text_content } from './operations.js';\nimport {\n\tcurrent_hydration_fragment,\n\tget_hydration_fragment,\n\thydrate_block_anchor,\n\tset_current_hydration_fragment\n} from './hydration.js';\nimport { is_array } from './utils.js';\nimport { each_item_block, destroy_each_item_block, update_each_item_block } from './render.js';\nimport { EACH_INDEX_REACTIVE, EACH_IS_ANIMATED, EACH_ITEM_REACTIVE } from '../../constants.js';\n\nconst NEW_BLOCK = -1;\nconst MOVED_BLOCK = 99999999;\nconst LIS_BLOCK = -2;\n\n/** @param {string} html */\nexport function create_fragment_from_html(html) {\n\tvar elem = document.createElement('template');\n\telem.innerHTML = html;\n\treturn elem.content;\n}\n\n/**\n * @param {Array<import('./types.js').TemplateNode> | import('./types.js').TemplateNode} current\n * @param {null | Element} parent_element\n * @param {null | Text | Element | Comment} sibling\n * @returns {Text | Element | Comment}\n */\nexport function insert(current, parent_element, sibling) {\n\tif (is_array(current)) {\n\t\tvar i = 0;\n\t\tvar node;\n\t\tfor (; i < current.length; i++) {\n\t\t\tnode = current[i];\n\t\t\tif (sibling === null) {\n\t\t\t\tappend_child(/** @type {Element} */ (parent_element), /** @type {Node} */ (node));\n\t\t\t} else {\n\t\t\t\tsibling.before(/** @type {Node} */ (node));\n\t\t\t}\n\t\t}\n\t\treturn current[0];\n\t} else if (current !== null) {\n\t\tif (sibling === null) {\n\t\t\tappend_child(/** @type {Element} */ (parent_element), /** @type {Node} */ (current));\n\t\t} else {\n\t\t\tsibling.before(/** @type {Node} */ (current));\n\t\t}\n\t}\n\treturn /** @type {Text | Element | Comment} */ (current);\n}\n\n/**\n * @param {Array<import('./types.js').TemplateNode> | import('./types.js').TemplateNode} current\n * @returns {Element | Comment | Text}\n */\nexport function remove(current) {\n\tvar first_node = current;\n\tif (is_array(current)) {\n\t\tvar i = 0;\n\t\tvar node;\n\t\tfor (; i < current.length; i++) {\n\t\t\tnode = current[i];\n\t\t\tif (i === 0) {\n\t\t\t\tfirst_node = node;\n\t\t\t}\n\t\t\tif (node.isConnected) {\n\t\t\t\tnode.remove();\n\t\t\t}\n\t\t}\n\t} else if (current.isConnected) {\n\t\tcurrent.remove();\n\t}\n\treturn /** @type {Element | Comment | Text} */ (first_node);\n}\n\n/**\n * @template V\n * @param {Element | Text | Comment} dom\n * @param {V} value\n * @param {boolean} svg\n * @returns {Element | Comment | (Element | Comment | Text)[]}\n */\nexport function reconcile_html(dom, value, svg) {\n\thydrate_block_anchor(dom);\n\tif (current_hydration_fragment !== null) {\n\t\treturn current_hydration_fragment;\n\t}\n\tvar html = value + '';\n\t// Even if html is the empty string we need to continue to insert something or\n\t// else the element ordering gets out of sync, resulting in subsequent values\n\t// not getting inserted anymore.\n\tvar target = dom;\n\tvar frag_nodes;\n\tif (svg) {\n\t\thtml = `<svg>${html}</svg>`;\n\t}\n\tvar content = create_fragment_from_html(html);\n\tif (svg) {\n\t\tcontent = /** @type {DocumentFragment} */ (/** @type {unknown} */ (content.firstChild));\n\t}\n\tvar clone = content.cloneNode(true);\n\tfrag_nodes = Array.from(clone.childNodes);\n\ttarget.before(svg ? /** @type {Node} */ (clone.firstChild) : clone);\n\treturn /** @type {Array<Text | Comment | Element>} */ (frag_nodes);\n}\n\n/**\n * @param {import('./types.js').Block} block\n * @param {Element | Comment | Text} dom\n * @param {boolean} is_controlled\n * @param {null | Text | Element | Comment} sibling\n * @returns {Text | Element | Comment}\n */\nfunction insert_each_item_block(block, dom, is_controlled, sibling) {\n\tvar current = /** @type {import('./types.js').TemplateNode} */ (block.dom);\n\tif (sibling === null) {\n\t\tif (is_controlled) {\n\t\t\treturn insert(current, /** @type {Element} */ (dom), null);\n\t\t} else {\n\t\t\treturn insert(current, /** @type {Element} */ (dom.parentNode), dom);\n\t\t}\n\t}\n\treturn insert(current, null, sibling);\n}\n\n/**\n * @param {import('./types.js').Block} block\n * @returns {Text | Element | Comment}\n */\nfunction get_first_child(block) {\n\tvar current = block.dom;\n\tif (is_array(current)) {\n\t\treturn /** @type {Text | Element | Comment} */ (current[0]);\n\t}\n\treturn /** @type {Text | Element | Comment} */ (current);\n}\n\n/**\n * @param {Array<import('./types.js').EachItemBlock>} active_transitions\n * @returns {void}\n */\nfunction destroy_active_transition_blocks(active_transitions) {\n\tvar length = active_transitions.length;\n\tif (length > 0) {\n\t\tvar i = 0;\n\t\tvar block;\n\t\tvar transition;\n\t\tfor (; i < length; i++) {\n\t\t\tblock = active_transitions[i];\n\t\t\ttransition = block.transition;\n\t\t\tif (transition !== null) {\n\t\t\t\tblock.transition = null;\n\t\t\t\tdestroy_each_item_block(block, null, false);\n\t\t\t}\n\t\t}\n\t\tactive_transitions.length = 0;\n\t}\n}\n\n/**\n * @template V\n * @param {Array<V>} array\n * @param {import('./types.js').EachBlock} each_block\n * @param {Element | Comment | Text} dom\n * @param {boolean} is_controlled\n * @param {(anchor: null, item: V, index: number | import('./types.js').Signal<number>) => void} render_fn\n * @param {number} flags\n * @param {boolean} apply_transitions\n * @returns {void}\n */\nexport function reconcile_indexed_array(\n\tarray,\n\teach_block,\n\tdom,\n\tis_controlled,\n\trender_fn,\n\tflags,\n\tapply_transitions\n) {\n\tvar a_blocks = each_block.items;\n\tvar active_transitions = each_block.transitions;\n\n\t/** @type {number | void} */\n\tvar a = a_blocks.length;\n\n\t/** @type {number} */\n\tvar b = array.length;\n\tvar length = Math.max(a, b);\n\tvar index = 0;\n\n\t/** @type {Array<import('./types.js').EachItemBlock>} */\n\tvar b_blocks;\n\tvar block;\n\tif (active_transitions.length !== 0) {\n\t\tdestroy_active_transition_blocks(active_transitions);\n\t}\n\tif (b === 0) {\n\t\tb_blocks = [];\n\t\t// Remove old blocks\n\t\tif (is_controlled && a !== 0) {\n\t\t\tclear_text_content(dom);\n\t\t}\n\t\twhile (index < length) {\n\t\t\tblock = a_blocks[index++];\n\t\t\tdestroy_each_item_block(block, active_transitions, apply_transitions, is_controlled);\n\t\t}\n\t} else {\n\t\tvar item;\n\t\tb_blocks = Array(b);\n\t\tif (current_hydration_fragment !== null) {\n\t\t\t/** @type {Node} */\n\t\t\tvar hydrating_node = current_hydration_fragment[0];\n\t\t\tfor (; index < length; index++) {\n\t\t\t\t// Hydrate block\n\t\t\t\titem = array[index];\n\t\t\t\tvar fragment = /** @type {Array<Text | Comment | Element>} */ (\n\t\t\t\t\tget_hydration_fragment(hydrating_node)\n\t\t\t\t);\n\t\t\t\tset_current_hydration_fragment(fragment);\n\t\t\t\thydrating_node = /** @type {Node} */ (\n\t\t\t\t\t/** @type {Node} */ (/** @type {Node} */ (fragment.at(-1)).nextSibling).nextSibling\n\t\t\t\t);\n\t\t\t\tblock = each_item_block(item, null, index, render_fn, flags);\n\t\t\t\tb_blocks[index] = block;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (; index < length; index++) {\n\t\t\t\tif (index >= a) {\n\t\t\t\t\t// Add block\n\t\t\t\t\titem = array[index];\n\t\t\t\t\tblock = each_item_block(item, null, index, render_fn, flags);\n\t\t\t\t\tb_blocks[index] = block;\n\t\t\t\t\tinsert_each_item_block(block, dom, is_controlled, null);\n\t\t\t\t} else if (index >= b) {\n\t\t\t\t\t// Remove block\n\t\t\t\t\tblock = a_blocks[index];\n\t\t\t\t\tdestroy_each_item_block(block, active_transitions, apply_transitions);\n\t\t\t\t} else {\n\t\t\t\t\t// Update block\n\t\t\t\t\titem = array[index];\n\t\t\t\t\tblock = a_blocks[index];\n\t\t\t\t\tb_blocks[index] = block;\n\t\t\t\t\tupdate_each_item_block(block, item, index, flags);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\teach_block.items = b_blocks;\n}\n// Reconcile arrays by the equality of the elements in the array. This algorithm\n// is based on Ivi's reconcilation logic:\n//\n// https://github.com/localvoid/ivi/blob/9f1bd0918f487da5b131941228604763c5d8ef56/packages/ivi/src/client/core.ts#L968\n//\n\n/**\n * @template V\n * @param {Array<V>} array\n * @param {import('./types.js').EachBlock} each_block\n * @param {Element | Comment | Text} dom\n * @param {boolean} is_controlled\n * @param {(anchor: null, item: V, index: number | import('./types.js').Signal<number>) => void} render_fn\n * @param {number} flags\n * @param {boolean} apply_transitions\n * @param {Array<string> | null} keys\n * @returns {void}\n */\nexport function reconcile_tracked_array(\n\tarray,\n\teach_block,\n\tdom,\n\tis_controlled,\n\trender_fn,\n\tflags,\n\tapply_transitions,\n\tkeys\n) {\n\tvar a_blocks = each_block.items;\n\tconst is_computed_key = keys !== null;\n\tvar active_transitions = each_block.transitions;\n\n\t/** @type {number | void} */\n\tvar a = a_blocks.length;\n\n\t/** @type {number} */\n\tvar b = array.length;\n\n\t/** @type {Array<import('./types.js').EachItemBlock>} */\n\tvar b_blocks;\n\tvar block;\n\tif (active_transitions.length !== 0) {\n\t\tdestroy_active_transition_blocks(active_transitions);\n\t}\n\tif (b === 0) {\n\t\tb_blocks = [];\n\t\t// Remove old blocks\n\t\tif (is_controlled && a !== 0) {\n\t\t\tclear_text_content(dom);\n\t\t}\n\t\twhile (a > 0) {\n\t\t\tblock = a_blocks[--a];\n\t\t\tdestroy_each_item_block(block, active_transitions, apply_transitions, is_controlled);\n\t\t}\n\t} else {\n\t\tvar a_end = a - 1;\n\t\tvar b_end = b - 1;\n\t\tvar key;\n\t\tvar item;\n\t\tvar idx;\n\t\tb_blocks = Array(b);\n\t\tif (current_hydration_fragment !== null) {\n\t\t\tvar fragment;\n\n\t\t\t/** @type {Node} */\n\t\t\tvar hydrating_node = current_hydration_fragment[0];\n\t\t\twhile (b > 0) {\n\t\t\t\t// Hydrate block\n\t\t\t\tidx = b_end - --b;\n\t\t\t\titem = array[idx];\n\t\t\t\tkey = is_computed_key ? keys[idx] : item;\n\t\t\t\tfragment = /** @type {Array<Text | Comment | Element>} */ (\n\t\t\t\t\tget_hydration_fragment(hydrating_node)\n\t\t\t\t);\n\t\t\t\tset_current_hydration_fragment(fragment);\n\t\t\t\t// Get the <!--ssr:..--> tag of the next item in the list\n\t\t\t\t// The fragment array can be empty if each block has no content\n\t\t\t\thydrating_node = /** @type {Node} */ (\n\t\t\t\t\t/** @type {Node} */ ((fragment.at(-1) || hydrating_node).nextSibling).nextSibling\n\t\t\t\t);\n\t\t\t\tblock = each_item_block(item, key, idx, render_fn, flags);\n\t\t\t\tb_blocks[idx] = block;\n\t\t\t}\n\t\t} else if (a === 0) {\n\t\t\t// Create new blocks\n\t\t\twhile (b > 0) {\n\t\t\t\tidx = b_end - --b;\n\t\t\t\titem = array[idx];\n\t\t\t\tkey = is_computed_key ? keys[idx] : item;\n\t\t\t\tblock = each_item_block(item, key, idx, render_fn, flags);\n\t\t\t\tb_blocks[idx] = block;\n\t\t\t\tinsert_each_item_block(block, dom, is_controlled, null);\n\t\t\t}\n\t\t} else {\n\t\t\tvar should_update_block =\n\t\t\t\t(flags & EACH_ITEM_REACTIVE) !== 0 || (flags & EACH_INDEX_REACTIVE) !== 0;\n\t\t\tvar start = 0;\n\n\t\t\t/** @type {null | Text | Element | Comment} */\n\t\t\tvar sibling = null;\n\t\t\titem = array[b_end];\n\t\t\tkey = is_computed_key ? keys[b_end] : item;\n\t\t\t// Step 1\n\t\t\touter: while (true) {\n\t\t\t\t// From the end\n\t\t\t\twhile (a_blocks[a_end].key === key) {\n\t\t\t\t\tblock = a_blocks[a_end--];\n\t\t\t\t\titem = array[b_end];\n\t\t\t\t\tif (should_update_block) {\n\t\t\t\t\t\tupdate_each_item_block(block, item, b_end, flags);\n\t\t\t\t\t}\n\t\t\t\t\tsibling = get_first_child(block);\n\t\t\t\t\tb_blocks[b_end] = block;\n\t\t\t\t\tif (start > --b_end || start > a_end) {\n\t\t\t\t\t\tbreak outer;\n\t\t\t\t\t}\n\t\t\t\t\tkey = is_computed_key ? keys[b_end] : item;\n\t\t\t\t}\n\t\t\t\titem = array[start];\n\t\t\t\tkey = is_computed_key ? keys[start] : item;\n\t\t\t\t// At the start\n\t\t\t\twhile (start <= a_end && start <= b_end && a_blocks[start].key === key) {\n\t\t\t\t\titem = array[start];\n\t\t\t\t\tblock = a_blocks[start];\n\t\t\t\t\tif (should_update_block) {\n\t\t\t\t\t\tupdate_each_item_block(block, item, start, flags);\n\t\t\t\t\t}\n\t\t\t\t\tb_blocks[start] = block;\n\t\t\t\t\t++start;\n\t\t\t\t\tkey = is_computed_key ? keys[start] : array[start];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// Step 2\n\t\t\tif (start > a_end) {\n\t\t\t\twhile (b_end >= start) {\n\t\t\t\t\titem = array[b_end];\n\t\t\t\t\tkey = is_computed_key ? keys[b_end] : item;\n\t\t\t\t\tblock = each_item_block(item, key, b_end, render_fn, flags);\n\t\t\t\t\tb_blocks[b_end--] = block;\n\t\t\t\t\tsibling = insert_each_item_block(block, dom, is_controlled, sibling);\n\t\t\t\t}\n\t\t\t} else if (start > b_end) {\n\t\t\t\tb = start;\n\t\t\t\tdo {\n\t\t\t\t\tif ((block = a_blocks[b++]) !== null) {\n\t\t\t\t\t\tdestroy_each_item_block(block, active_transitions, apply_transitions);\n\t\t\t\t\t}\n\t\t\t\t} while (b <= a_end);\n\t\t\t} else {\n\t\t\t\t// Step 3\n\t\t\t\tvar pos = 0;\n\t\t\t\tvar b_length = b_end - start + 1;\n\t\t\t\tvar sources = new Int32Array(b_length);\n\t\t\t\tvar item_index = new Map();\n\t\t\t\tfor (b = 0; b < b_length; ++b) {\n\t\t\t\t\ta = b + start;\n\t\t\t\t\tsources[b] = NEW_BLOCK;\n\t\t\t\t\titem = array[a];\n\t\t\t\t\tkey = is_computed_key ? keys[a] : item;\n\t\t\t\t\tmap_set(item_index, key, a);\n\t\t\t\t}\n\t\t\t\tfor (b = start; b <= a_end; ++b) {\n\t\t\t\t\ta = map_get(item_index, /** @type {V} */ (a_blocks[b].key));\n\t\t\t\t\tblock = a_blocks[b];\n\t\t\t\t\tif (a !== undefined) {\n\t\t\t\t\t\tpos = pos < a ? a : MOVED_BLOCK;\n\t\t\t\t\t\tsources[a - start] = b;\n\t\t\t\t\t\tb_blocks[a] = block;\n\t\t\t\t\t} else if (block !== null) {\n\t\t\t\t\t\tdestroy_each_item_block(block, active_transitions, apply_transitions);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Step 4\n\t\t\t\tif (pos === MOVED_BLOCK) {\n\t\t\t\t\tmark_lis(sources);\n\t\t\t\t}\n\t\t\t\t// If keys are animated, we need to do updates before actual moves\n\t\t\t\tvar is_animated = (flags & EACH_IS_ANIMATED) !== 0;\n\t\t\t\tvar should_create;\n\t\t\t\tif (is_animated) {\n\t\t\t\t\tvar i = b_length;\n\t\t\t\t\twhile (i-- > 0) {\n\t\t\t\t\t\tb_end = i + start;\n\t\t\t\t\t\ta = sources[i];\n\t\t\t\t\t\tif (pos === MOVED_BLOCK && a !== LIS_BLOCK) {\n\t\t\t\t\t\t\tblock = b_blocks[b_end];\n\t\t\t\t\t\t\tupdate_each_item_block(block, item, b_end, flags);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar last_block;\n\t\t\t\tvar last_sibling;\n\t\t\t\twhile (b_length-- > 0) {\n\t\t\t\t\tb_end = b_length + start;\n\t\t\t\t\ta = sources[b_length];\n\t\t\t\t\tshould_create = a === -1;\n\t\t\t\t\titem = array[b_end];\n\t\t\t\t\tif (should_create) {\n\t\t\t\t\t\tkey = is_computed_key ? keys[b_end] : item;\n\t\t\t\t\t\tblock = each_item_block(item, key, b_end, render_fn, flags);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tblock = b_blocks[b_end];\n\t\t\t\t\t\tif (!is_animated && should_update_block) {\n\t\t\t\t\t\t\tupdate_each_item_block(block, item, b_end, flags);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (should_create || (pos === MOVED_BLOCK && a !== LIS_BLOCK)) {\n\t\t\t\t\t\tlast_sibling = last_block === undefined ? sibling : get_first_child(last_block);\n\t\t\t\t\t\tsibling = insert_each_item_block(block, dom, is_controlled, last_sibling);\n\t\t\t\t\t}\n\t\t\t\t\tb_blocks[b_end] = block;\n\t\t\t\t\tlast_block = block;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\teach_block.items = b_blocks;\n}\n// Longest Increased Subsequence algorithm.\n\n/**\n * @param {Int32Array} a\n * @returns {void}\n */\nfunction mark_lis(a) {\n\tvar length = a.length;\n\tvar parent = new Int32Array(length);\n\tvar index = new Int32Array(length);\n\tvar index_length = 0;\n\tvar i = 0;\n\n\t/** @type {number} */\n\tvar j;\n\n\t/** @type {number} */\n\tvar k;\n\n\t/** @type {number} */\n\tvar lo;\n\n\t/** @type {number} */\n\tvar hi;\n\t// Skip -1 values at the start of the input array `a`.\n\tfor (; a[i] === NEW_BLOCK; ++i) {\n\t\t/**/\n\t}\n\tindex[0] = i++;\n\tfor (; i < length; ++i) {\n\t\tk = a[i];\n\t\tif (k !== NEW_BLOCK) {\n\t\t\t// Ignore -1 values.\n\t\t\tj = index[index_length];\n\t\t\tif (a[j] < k) {\n\t\t\t\tparent[i] = j;\n\t\t\t\tindex[++index_length] = i;\n\t\t\t} else {\n\t\t\t\tlo = 0;\n\t\t\t\thi = index_length;\n\t\t\t\twhile (lo < hi) {\n\t\t\t\t\tj = (lo + hi) >> 1;\n\t\t\t\t\tif (a[index[j]] < k) {\n\t\t\t\t\t\tlo = j + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thi = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (k < a[index[lo]]) {\n\t\t\t\t\tif (lo > 0) {\n\t\t\t\t\t\tparent[i] = index[lo - 1];\n\t\t\t\t\t}\n\t\t\t\t\tindex[lo] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Mutate input array `a` and assign -2 value to all nodes that are part of LIS.\n\tj = index[index_length];\n\twhile (index_length-- >= 0) {\n\t\ta[j] = LIS_BLOCK;\n\t\tj = parent[j];\n\t}\n}\n", "import { EACH_IS_ANIMATED, EACH_IS_CONTROLLED } from '../../constants.js';\nimport {\n\tAWAIT_BLOCK,\n\tDYNAMIC_COMPONENT_BLOCK,\n\tEACH_BLOCK,\n\tEACH_ITEM_BLOCK,\n\tIF_BLOCK,\n\tKEY_BLOCK,\n\tROOT_BLOCK\n} from './block.js';\nimport { append_child } from './operations.js';\nimport { destroy_each_item_block, empty } from './render.js';\nimport {\n\tcurrent_block,\n\tcurrent_effect,\n\tdestroy_signal,\n\teffect,\n\tmanaged_effect,\n\tmanaged_pre_effect,\n\tmark_subtree_inert,\n\tuntrack\n} from './runtime.js';\nimport { raf } from './timing.js';\n\nconst active_tick_animations = new Set();\nconst DELAY_NEXT_TICK = Number.MIN_SAFE_INTEGER;\n\n/** @type {undefined | number} */\nlet active_tick_ref = undefined;\n\n/**\n * @template T\n * @param {string} type\n * @param {T} [detail]\n * @param {any}params_0\n * @returns {Event}\n */\nfunction custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n\tconst e = document.createEvent('CustomEvent');\n\te.initCustomEvent(type, bubbles, cancelable, detail);\n\treturn e;\n}\n\n/**\n * @param {HTMLElement} dom\n * @param {'introstart' | 'introend' | 'outrostart' | 'outroend'} type\n * @returns {void}\n */\nfunction dispatch_event(dom, type) {\n\tdom.dispatchEvent(custom_event(type));\n}\n\n/**\n * @param {string} style\n * @returns {string}\n */\nfunction css_style_from_camel_case(style) {\n\tconst parts = style.split('-');\n\tif (parts.length === 1) return parts[0];\n\treturn (\n\t\tparts[0] +\n\t\tparts\n\t\t\t.slice(1)\n\t\t\t.map(/** @param {any} word */ (word) => word[0].toUpperCase() + word.slice(1))\n\t\t\t.join('')\n\t);\n}\n\n/**\n * @param {string} css\n * @returns {Keyframe}\n */\nfunction css_to_keyframe(css) {\n\t/** @type {Keyframe} */\n\tconst keyframe = {};\n\tconst parts = css.split(';');\n\tfor (const part of parts) {\n\t\tconst [property, value] = part.split(':');\n\t\tif (!property || value === undefined) break;\n\n\t\tconst formatted_property = css_style_from_camel_case(property.trim());\n\t\tkeyframe[formatted_property] = value.trim();\n\t}\n\treturn keyframe;\n}\n\nclass TickAnimation {\n\t/** @type {null | (() => void)} */\n\tonfinish;\n\n\t/** @type {(t: number, u: number) => string} */\n\t#tick_fn;\n\n\t/** @type {number} */\n\t#duration;\n\n\t/** @type {number} */\n\t#current;\n\n\t/** @type {number} */\n\t#delay;\n\n\t/** @type {number} */\n\t#previous;\n\n\t/** @type {boolean} */\n\tpaused;\n\n\t/** @type {boolean} */\n\t#reversed;\n\n\t/** @type {number} */\n\t#delay_current;\n\n\t/** @type {boolean} */\n\t#delayed_reverse;\n\n\t/**\n\t * @param {(t: number, u: number) => string} tick_fn\n\t * @param {number} duration\n\t * @param {number} delay\n\t * @param {boolean} out\n\t */\n\tconstructor(tick_fn, duration, delay, out) {\n\t\tthis.#duration = duration;\n\t\tthis.#delay = delay;\n\t\tthis.paused = false;\n\t\tthis.#tick_fn = tick_fn;\n\t\tthis.#reversed = out;\n\t\tthis.#delay_current = delay;\n\t\tthis.#current = out ? duration : 0;\n\t\tthis.#previous = 0;\n\t\tthis.#delayed_reverse = false;\n\t\tthis.onfinish = null;\n\t\tif (this.#delay) {\n\t\t\tif (!out) {\n\t\t\t\tthis.#tick_fn(0, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tpause() {\n\t\tthis.paused = true;\n\t}\n\n\tplay() {\n\t\tthis.paused = false;\n\t\tif (!active_tick_animations.has(this)) {\n\t\t\tthis.#previous = raf.now();\n\t\t\tif (active_tick_ref === undefined) {\n\t\t\t\tactive_tick_ref = raf.tick(handle_raf);\n\t\t\t}\n\t\t\tactive_tick_animations.add(this);\n\t\t}\n\t}\n\n\t#reverse() {\n\t\tthis.#reversed = !this.#reversed;\n\t\tif (this.paused) {\n\t\t\tif (this.#current === 0) {\n\t\t\t\tthis.#current = this.#duration;\n\t\t\t}\n\t\t\tthis.play();\n\t\t}\n\t}\n\n\treverse() {\n\t\tif (this.#delay === 0) {\n\t\t\tthis.#reverse();\n\t\t} else {\n\t\t\tthis.#delay_current = this.#delay;\n\t\t\tthis.#delayed_reverse = true;\n\t\t}\n\t}\n\n\tcancel() {\n\t\tconst t = this.#reversed ? 1 : 0;\n\t\tactive_tick_animations.delete(this);\n\t\tthis.#tick_fn(t, 1 - t);\n\t}\n\n\tfinish() {\n\t\tactive_tick_animations.delete(this);\n\t\tif (this.onfinish) {\n\t\t\tthis.onfinish();\n\t\t}\n\t}\n\n\t/** @param {number} time */\n\t_update(time) {\n\t\tlet diff = time - this.#previous;\n\t\tthis.#previous = time;\n\t\tif (this.#delay_current !== 0) {\n\t\t\tconst is_delayed = this.#delay_current === DELAY_NEXT_TICK;\n\t\t\tlet cancel = !this.#delayed_reverse;\n\t\t\tthis.#delay_current -= diff;\n\t\t\tif (this.#delay_current < 0 || is_delayed || (this.#delay_current === 0 && this.#reversed)) {\n\t\t\t\tconst delay_diff = is_delayed ? 0 : -this.#delay_current;\n\t\t\t\tthis.#delay_current = 0;\n\n\t\t\t\tif (this.#delayed_reverse) {\n\t\t\t\t\tthis.#delayed_reverse = false;\n\t\t\t\t\tthis.#reverse();\n\t\t\t\t} else if (delay_diff !== 0 || this.#reversed) {\n\t\t\t\t\tdiff = delay_diff;\n\t\t\t\t}\n\t\t\t\tcancel = false;\n\t\t\t} else if (this.#delay_current === 0) {\n\t\t\t\tthis.#delay_current = DELAY_NEXT_TICK;\n\t\t\t}\n\t\t\tif (cancel) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis.#current += this.#reversed ? -diff : diff;\n\t\tlet t = this.#current / this.#duration;\n\n\t\tif (t < 0) {\n\t\t\tt = 0;\n\t\t} else if (t > 1) {\n\t\t\tt = 1;\n\t\t}\n\n\t\tif ((this.#reversed && t <= 0) || (!this.#reversed && t >= 1)) {\n\t\t\tt = this.#reversed ? 0 : 1;\n\t\t\tif (this.#delay_current === 0) {\n\t\t\t\tactive_tick_animations.delete(this);\n\t\t\t\tif (this.onfinish) {\n\t\t\t\t\tthis.paused = true;\n\t\t\t\t\tthis.onfinish();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.#tick_fn(t, 1 - t);\n\t}\n}\n\n/** @param {number} time */\nfunction handle_raf(time) {\n\tfor (const animation of active_tick_animations) {\n\t\tif (!animation.paused) {\n\t\t\tanimation._update(time);\n\t\t}\n\t}\n\tif (active_tick_animations.size !== 0) {\n\t\tactive_tick_ref = raf.tick(handle_raf);\n\t} else {\n\t\tactive_tick_ref = undefined;\n\t}\n}\n\n/**\n * @param {HTMLElement} dom\n * @param {() => import('./types.js').TransitionPayload} init\n * @param {'in' | 'out' | 'both' | 'key'} direction\n * @param {import('./types.js').EffectSignal} effect\n * @returns {import('./types.js').Transition}\n */\nfunction create_transition(dom, init, direction, effect) {\n\tlet curr_direction = 'in';\n\n\t/** @type {Array<() => void>} */\n\tlet subs = [];\n\n\t/** @type {null | Animation | TickAnimation} */\n\tlet animation = null;\n\tlet cancelled = false;\n\n\tconst create_animation = () => {\n\t\tlet payload = /** @type {import('./types.js').TransitionPayload} */ (transition.payload);\n\t\tif (typeof payload === 'function') {\n\t\t\t// @ts-ignore\n\t\t\tpayload = payload({ direction: curr_direction });\n\t\t}\n\t\tconst duration = payload.duration ?? 300;\n\t\tconst delay = payload.delay ?? 0;\n\t\tconst css_fn = payload.css;\n\t\tconst tick_fn = payload.tick;\n\n\t\t/** @param {number} t */\n\t\tconst linear = (t) => t;\n\t\tconst easing_fn = payload.easing || linear;\n\n\t\t/** @type {Keyframe[]} */\n\t\tconst keyframes = [];\n\n\t\tif (typeof tick_fn === 'function') {\n\t\t\tanimation = new TickAnimation(tick_fn, duration, delay, direction === 'out');\n\t\t} else {\n\t\t\tif (typeof css_fn === 'function') {\n\t\t\t\t// We need at least two frames\n\t\t\t\tconst frame_time = 16.666;\n\t\t\t\tconst max_duration = Math.max(duration, frame_time);\n\t\t\t\t// Have a keyframe every fame for 60 FPS\n\t\t\t\tfor (let i = 0; i <= max_duration; i += frame_time) {\n\t\t\t\t\tlet time;\n\t\t\t\t\tif (i + frame_time > max_duration) {\n\t\t\t\t\t\ttime = 1;\n\t\t\t\t\t} else if (i === 0) {\n\t\t\t\t\t\ttime = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttime = i / max_duration;\n\t\t\t\t\t}\n\t\t\t\t\tconst t = easing_fn(time);\n\t\t\t\t\tkeyframes.push(css_to_keyframe(css_fn(t, 1 - t)));\n\t\t\t\t}\n\t\t\t\tif (direction === 'out') {\n\t\t\t\t\tkeyframes.reverse();\n\t\t\t\t}\n\t\t\t}\n\t\t\tanimation = dom.animate(keyframes, {\n\t\t\t\tduration,\n\t\t\t\tendDelay: delay,\n\t\t\t\tdelay,\n\t\t\t\tfill: 'both'\n\t\t\t});\n\t\t}\n\t\tanimation.pause();\n\n\t\tanimation.onfinish = () => {\n\t\t\tconst is_outro = curr_direction === 'out';\n\t\t\t/** @type {Animation | TickAnimation} */ (animation).pause();\n\t\t\tif (is_outro) {\n\t\t\t\tfor (const sub of subs) {\n\t\t\t\t\tsub();\n\t\t\t\t}\n\t\t\t\tsubs = [];\n\t\t\t}\n\t\t\tdispatch_event(dom, is_outro ? 'outroend' : 'introend');\n\t\t};\n\t};\n\n\t/** @type {import('./types.js').Transition} */\n\tconst transition = {\n\t\teffect,\n\t\tinit,\n\t\tpayload: null,\n\n\t\t/** @param {() => void} fn */\n\t\tfinished(fn) {\n\t\t\tsubs.push(fn);\n\t\t},\n\t\tin() {\n\t\t\tconst needs_reverse = curr_direction !== 'in';\n\t\t\tcurr_direction = 'in';\n\t\t\tif (animation === null || cancelled) {\n\t\t\t\tcancelled = false;\n\t\t\t\tcreate_animation();\n\t\t\t}\n\t\t\tdispatch_event(dom, 'introstart');\n\t\t\tif (needs_reverse) {\n\t\t\t\t/** @type {Animation | TickAnimation} */ (animation).reverse();\n\t\t\t}\n\t\t\t/** @type {Animation | TickAnimation} */ (animation).play();\n\t\t},\n\t\tout() {\n\t\t\tconst needs_reverse = direction === 'both' && curr_direction !== 'out';\n\t\t\tcurr_direction = 'out';\n\t\t\tif (animation === null || cancelled) {\n\t\t\t\tcancelled = false;\n\t\t\t\tcreate_animation();\n\t\t\t}\n\t\t\tdispatch_event(dom, 'outrostart');\n\t\t\tif (needs_reverse) {\n\t\t\t\t/** @type {Animation | TickAnimation} */ (animation).reverse();\n\t\t\t} else {\n\t\t\t\t/** @type {Animation | TickAnimation} */ (animation).play();\n\t\t\t}\n\t\t},\n\t\tcancel() {\n\t\t\t/** @type {Animation | TickAnimation} */ (animation).cancel();\n\t\t\tcancelled = true;\n\t\t},\n\t\tcleanup() {\n\t\t\tfor (const sub of subs) {\n\t\t\t\tsub();\n\t\t\t}\n\t\t\tsubs = [];\n\t\t},\n\t\tdirection,\n\t\tdom\n\t};\n\treturn transition;\n}\n\n/**\n * @param {import('./types.js').Block} block\n * @returns {boolean}\n */\nfunction is_transition_block(block) {\n\treturn (\n\t\tblock.type === IF_BLOCK ||\n\t\tblock.type === EACH_ITEM_BLOCK ||\n\t\tblock.type === KEY_BLOCK ||\n\t\tblock.type === AWAIT_BLOCK ||\n\t\tblock.type === DYNAMIC_COMPONENT_BLOCK ||\n\t\t(block.type === EACH_BLOCK && block.items.length === 0)\n\t);\n}\n\n/**\n * @template P\n * @param {HTMLElement} dom\n * @param {import('./types.js').TransitionFn<P | undefined> | import('./types.js').AnimateFn<P | undefined>} transition_fn\n * @param {(() => P) | null} props_fn\n * @param {'in' | 'out' | 'both' | 'key'} direction\n * @param {boolean} global\n * @returns {void}\n */\nexport function bind_transition(dom, transition_fn, props_fn, direction, global) {\n\tconst transition_effect = /** @type {import('./types.js').EffectSignal} */ (current_effect);\n\tconst block = current_block;\n\tconst props = props_fn === null ? {} : props_fn();\n\n\tlet skip_intro = true;\n\n\t/** @type {import('./types.js').Block | null} */\n\tlet transition_block = block;\n\twhile (transition_block !== null) {\n\t\tif (is_transition_block(transition_block)) {\n\t\t\tif (transition_block.type === EACH_ITEM_BLOCK) {\n\t\t\t\t// Lazily apply the each block transition\n\t\t\t\ttransition_block.transition = each_item_transition;\n\t\t\t\ttransition_block = transition_block.parent;\n\t\t\t} else if (transition_block.type === AWAIT_BLOCK && transition_block.pending) {\n\t\t\t\tskip_intro = false;\n\t\t\t}\n\t\t\tif (skip_intro) {\n\t\t\t\tskip_intro = transition_block.effect === null;\n\t\t\t}\n\t\t\tif (!skip_intro || !global) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (\n\t\t\ttransition_block.type === ROOT_BLOCK &&\n\t\t\t(transition_block.effect !== null || transition_block.intro)\n\t\t) {\n\t\t\tskip_intro = false;\n\t\t}\n\t\ttransition_block = transition_block.parent;\n\t}\n\n\t/** @type {import('./types.js').Transition} */\n\tlet transition;\n\n\teffect(() => {\n\t\t/** @param {DOMRect} [from] */\n\t\tconst init = (from) =>\n\t\t\tuntrack(() =>\n\t\t\t\tdirection === 'key'\n\t\t\t\t\t? /** @type {import('./types.js').AnimateFn<any>} */ (transition_fn)(\n\t\t\t\t\t\t\tdom,\n\t\t\t\t\t\t\t{ from: /** @type {DOMRect} */ (from), to: dom.getBoundingClientRect() },\n\t\t\t\t\t\t\tprops,\n\t\t\t\t\t\t\t{}\n\t\t\t\t\t  )\n\t\t\t\t\t: /** @type {import('./types.js').TransitionFn<any>} */ (transition_fn)(dom, props, {\n\t\t\t\t\t\t\tdirection\n\t\t\t\t\t  })\n\t\t\t);\n\n\t\ttransition = create_transition(dom, init, direction, transition_effect);\n\t\tconst is_intro = direction === 'in';\n\t\tconst show_intro = !skip_intro && (is_intro || direction === 'both');\n\n\t\tif (show_intro) {\n\t\t\ttransition.payload = transition.init();\n\t\t}\n\n\t\tconst effect = managed_pre_effect(() => {\n\t\t\tdestroy_signal(effect);\n\t\t\tdom.inert = false;\n\n\t\t\tif (show_intro) {\n\t\t\t\ttransition.in();\n\t\t\t}\n\n\t\t\t/** @type {import('./types.js').Block | null} */\n\t\t\tlet transition_block = block;\n\t\t\twhile (transition_block !== null) {\n\t\t\t\tconst parent = transition_block.parent;\n\t\t\t\tif (is_transition_block(transition_block)) {\n\t\t\t\t\tif (transition_block.transition !== null) {\n\t\t\t\t\t\ttransition_block.transition(transition);\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tparent === null ||\n\t\t\t\t\t\t(!global &&\n\t\t\t\t\t\t\t(transition_block.type !== IF_BLOCK || parent.type !== IF_BLOCK || parent.current))\n\t\t\t\t\t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttransition_block = parent;\n\t\t\t}\n\t\t}, false);\n\t});\n\n\tif (direction === 'key') {\n\t\teffect(() => {\n\t\t\treturn () => {\n\t\t\t\ttransition.cleanup();\n\t\t\t};\n\t\t});\n\t}\n}\n\n/**\n * @param {Set<import('./types.js').Transition>} transitions\n */\nexport function remove_in_transitions(transitions) {\n\tfor (let other of transitions) {\n\t\tif (other.direction === 'in') {\n\t\t\ttransitions.delete(other);\n\t\t}\n\t}\n}\n\n/**\n * @param {Set<import('./types.js').Transition>} transitions\n * @param {'in' | 'out' | 'key'} target_direction\n * @param {DOMRect} [from]\n * @returns {void}\n */\nexport function trigger_transitions(transitions, target_direction, from) {\n\t/** @type {Array<() => void>} */\n\tconst outros = [];\n\tfor (const transition of transitions) {\n\t\tconst direction = transition.direction;\n\t\tif (target_direction === 'in') {\n\t\t\tif (direction === 'in' || direction === 'both') {\n\t\t\t\ttransition.in();\n\t\t\t} else {\n\t\t\t\ttransition.cancel();\n\t\t\t}\n\t\t\ttransition.dom.inert = false;\n\t\t\tmark_subtree_inert(transition.effect, false);\n\t\t} else if (target_direction === 'key') {\n\t\t\tif (direction === 'key') {\n\t\t\t\ttransition.payload = transition.init(/** @type {DOMRect} */ (from));\n\t\t\t\ttransition.in();\n\t\t\t}\n\t\t} else {\n\t\t\tif (direction === 'out' || direction === 'both') {\n\t\t\t\ttransition.payload = transition.init();\n\t\t\t\toutros.push(transition.out);\n\t\t\t}\n\t\t\ttransition.dom.inert = true;\n\t\t\tmark_subtree_inert(transition.effect, true);\n\t\t}\n\t}\n\tif (outros.length > 0) {\n\t\t// Defer the outros to a microtask\n\t\tconst e = managed_pre_effect(() => {\n\t\t\tdestroy_signal(e);\n\t\t\tconst e2 = managed_effect(() => {\n\t\t\t\tdestroy_signal(e2);\n\t\t\t\toutros.forEach(/** @param {any} o */ (o) => o());\n\t\t\t});\n\t\t}, false);\n\t}\n}\n\n/**\n * @this {import('./types.js').EachItemBlock}\n * @param {import('./types.js').Transition} transition\n * @returns {void}\n */\nfunction each_item_transition(transition) {\n\tconst block = this;\n\tconst each_block = block.parent;\n\tconst is_controlled = (each_block.flags & EACH_IS_CONTROLLED) !== 0;\n\t// Disable optimization\n\tif (is_controlled) {\n\t\tconst anchor = empty();\n\t\teach_block.flags ^= EACH_IS_CONTROLLED;\n\t\tappend_child(/** @type {Element} */ (each_block.anchor), anchor);\n\t\teach_block.anchor = anchor;\n\t}\n\tif (transition.direction === 'key' && (each_block.flags & EACH_IS_ANIMATED) === 0) {\n\t\teach_block.flags |= EACH_IS_ANIMATED;\n\t}\n\tlet transitions = block.transitions;\n\tif (transitions === null) {\n\t\tblock.transitions = transitions = new Set();\n\t}\n\ttransition.finished(() => {\n\t\tif (transitions !== null) {\n\t\t\ttransitions.delete(transition);\n\t\t\tif (transition.direction !== 'key') {\n\t\t\t\tfor (let other of transitions) {\n\t\t\t\t\tif (other.direction === 'key' || other.direction === 'in') {\n\t\t\t\t\t\ttransitions.delete(other);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (transitions.size === 0) {\n\t\t\t\t\tblock.transitions = null;\n\t\t\t\t\tdestroy_each_item_block(block, null, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\ttransitions.add(transition);\n}\n", "import { DEV } from 'esm-env';\nimport {\n\tappend_child,\n\tchild,\n\tclone_node,\n\tcreate_element,\n\tinit_operations,\n\tmap_get,\n\tmap_set,\n\tset_class_name\n} from './operations.js';\nimport {\n\tcreate_root_block,\n\tcreate_each_item_block,\n\tcreate_each_block,\n\tcreate_if_block,\n\tcreate_key_block,\n\tcreate_await_block,\n\tcreate_dynamic_element_block,\n\tcreate_head_block,\n\tcreate_dynamic_component_block,\n\tcreate_snippet_block\n} from './block.js';\nimport {\n\tEACH_KEYED,\n\tEACH_IS_CONTROLLED,\n\tEACH_INDEX_REACTIVE,\n\tEACH_ITEM_REACTIVE,\n\tPassiveDelegatedEvents,\n\tDelegatedEvents\n} from '../../constants.js';\nimport {\n\tcreate_fragment_from_html,\n\tinsert,\n\treconcile_tracked_array,\n\treconcile_html,\n\tremove,\n\treconcile_indexed_array\n} from './reconciler.js';\nimport {\n\trender_effect,\n\tdestroy_signal,\n\tget,\n\tis_signal,\n\tpush_destroy_fn,\n\tset,\n\texecute_effect,\n\tUNINITIALIZED,\n\tderived,\n\tuntrack,\n\teffect,\n\tflushSync,\n\texpose,\n\tsafe_not_equal,\n\tcurrent_block,\n\tset_signal_value,\n\tsource,\n\tmanaged_effect,\n\tsafe_equal,\n\tpush,\n\tcurrent_component_context,\n\tpop,\n\tschedule_task\n} from './runtime.js';\nimport {\n\tcurrent_hydration_fragment,\n\tget_hydration_fragment,\n\thydrate_block_anchor,\n\tset_current_hydration_fragment\n} from './hydration.js';\nimport { array_from, define_property, get_descriptor, get_descriptors, is_array } from './utils.js';\nimport { is_promise } from '../common.js';\nimport { bind_transition, remove_in_transitions, trigger_transitions } from './transitions.js';\n\n/** @type {Set<string>} */\nconst all_registerd_events = new Set();\n\n/** @type {Set<(events: Array<string>) => void>} */\nconst root_event_handles = new Set();\n\n/** @returns {Text} */\nexport function empty() {\n\treturn document.createTextNode('');\n}\n\n/**\n * @param {string} html\n * @param {boolean} is_fragment\n * @returns {() => Node}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function template(html, is_fragment) {\n\t/** @type {undefined | Node} */\n\tlet cached_content;\n\treturn () => {\n\t\tif (cached_content === undefined) {\n\t\t\tconst content = create_fragment_from_html(html);\n\t\t\tcached_content = is_fragment ? content : /** @type {Node} */ (child(content));\n\t\t}\n\t\treturn cached_content;\n\t};\n}\n\n/**\n * @param {string} svg\n * @param {boolean} is_fragment\n * @returns {() => Node}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function svg_template(svg, is_fragment) {\n\t/** @type {undefined | Node} */\n\tlet cached_content;\n\treturn () => {\n\t\tif (cached_content === undefined) {\n\t\t\tconst content = /** @type {Node} */ (child(create_fragment_from_html(`<svg>${svg}</svg>`)));\n\t\t\tcached_content = is_fragment ? content : /** @type {Node} */ (child(content));\n\t\t}\n\t\treturn cached_content;\n\t};\n}\n\n/**\n * @param {Element} node\n * @returns {Element}\n */\nexport function svg_replace(node) {\n\tconst first_child = /** @type {Element} */ (node.firstChild);\n\tnode.replaceWith(first_child);\n\treturn first_child;\n}\n\n/**\n * @param {boolean} is_fragment\n * @param {boolean} use_clone_node\n * @param {null | Text | Comment | Element} anchor\n * @param {() => Element} [template_element_fn]\n * @returns {Element | DocumentFragment | Node[]}\n */\nfunction open_template(is_fragment, use_clone_node, anchor, template_element_fn) {\n\tif (current_hydration_fragment !== null) {\n\t\tif (anchor !== null) {\n\t\t\thydrate_block_anchor(anchor, false);\n\t\t}\n\t\t// In ssr+hydration optimization mode, we might remove the template_element,\n\t\t// so we need to is_fragment flag to properly handle hydrated content accordingly.\n\t\tconst fragment = current_hydration_fragment;\n\t\tif (fragment !== null) {\n\t\t\treturn is_fragment ? fragment : /** @type {Element} */ (fragment[0]);\n\t\t}\n\t}\n\treturn use_clone_node\n\t\t? clone_node(/** @type {() => Element} */ (template_element_fn)(), true)\n\t\t: document.importNode(/** @type {() => Element} */ (template_element_fn)(), true);\n}\n\n/**\n * @param {null | Text | Comment | Element} anchor\n * @param {boolean} use_clone_node\n * @param {() => Element} [template_element_fn]\n * @returns {Element | DocumentFragment | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function open(anchor, use_clone_node, template_element_fn) {\n\treturn open_template(false, use_clone_node, anchor, template_element_fn);\n}\n\n/**\n * @param {null | Text | Comment | Element} anchor\n * @param {boolean} use_clone_node\n * @param {() => Element} [template_element_fn]\n * @returns {Element | DocumentFragment | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function open_frag(anchor, use_clone_node, template_element_fn) {\n\treturn open_template(true, use_clone_node, anchor, template_element_fn);\n}\n\n/**\n * @param {Element | Text} dom\n * @param {boolean} is_fragment\n * @param {null | Text | Comment | Element} anchor\n * @returns {void}\n */\nfunction close_template(dom, is_fragment, anchor) {\n\tconst block = /** @type {import('./types.js').Block} */ (current_block);\n\n\t/** @type {import('./types.js').TemplateNode | Array<import('./types.js').TemplateNode>} */\n\tconst current = is_fragment\n\t\t? is_array(dom)\n\t\t\t? dom\n\t\t\t: /** @type {import('./types.js').TemplateNode[]} */ (Array.from(dom.childNodes))\n\t\t: dom;\n\tif (anchor !== null && current_hydration_fragment === null) {\n\t\tinsert(current, null, anchor);\n\t}\n\tblock.dom = current;\n}\n\n/**\n * @param {null | Text | Comment | Element} anchor\n * @param {Element | Text} dom\n * @returns {void}\n */\nexport function close(anchor, dom) {\n\tclose_template(dom, false, anchor);\n}\n\n/**\n * @param {null | Text | Comment | Element} anchor\n * @param {Element | Text} dom\n * @returns {void}\n */\nexport function close_frag(anchor, dom) {\n\tclose_template(dom, true, anchor);\n}\n\n/**\n * @param {import('./types.js').MaybeSignal<(event: Event, ...args: Array<unknown>) => void>} fn\n * @returns {(event: Event, ...args: unknown[]) => void}\n */\nexport function trusted(fn) {\n\treturn function (...args) {\n\t\tconst event = /** @type {Event} */ (args[0]);\n\t\tif (event.isTrusted) {\n\t\t\t// @ts-ignore\n\t\t\tunwrap(fn).apply(this, args);\n\t\t}\n\t};\n}\n\n/**\n * @param {import('./types.js').MaybeSignal<(event: Event, ...args: Array<unknown>) => void>} fn\n * @returns {(event: Event, ...args: unknown[]) => void}\n */\nexport function self(fn) {\n\treturn function (...args) {\n\t\tconst event = /** @type {Event} */ (args[0]);\n\t\t// @ts-ignore\n\t\tif (event.target === this) {\n\t\t\t// @ts-ignore\n\t\t\tunwrap(fn).apply(this, args);\n\t\t}\n\t};\n}\n\n/**\n * @param {import('./types.js').MaybeSignal<(event: Event, ...args: Array<unknown>) => void>} fn\n * @returns {(event: Event, ...args: unknown[]) => void}\n */\nexport function stopPropagation(fn) {\n\treturn function (...args) {\n\t\tconst event = /** @type {Event} */ (args[0]);\n\t\tevent.stopPropagation();\n\t\t// @ts-ignore\n\t\treturn unwrap(fn).apply(this, args);\n\t};\n}\n\n/**\n * @param {import('./types.js').MaybeSignal<(event: Event, ...args: Array<unknown>) => void>} fn\n * @returns {(event: Event, ...args: unknown[]) => void}\n */\nexport function once(fn) {\n\tlet ran = false;\n\treturn function (...args) {\n\t\tif (ran) {\n\t\t\treturn;\n\t\t}\n\t\tran = true;\n\t\t// @ts-ignore\n\t\treturn unwrap(fn).apply(this, args);\n\t};\n}\n\n/**\n * @param {import('./types.js').MaybeSignal<(event: Event, ...args: Array<unknown>) => void>} fn\n * @returns {(event: Event, ...args: unknown[]) => void}\n */\nexport function stopImmediatePropagation(fn) {\n\treturn function (...args) {\n\t\tconst event = /** @type {Event} */ (args[0]);\n\t\tevent.stopImmediatePropagation();\n\t\t// @ts-ignore\n\t\treturn unwrap(fn).apply(this, args);\n\t};\n}\n\n/**\n * @param {import('./types.js').MaybeSignal<(event: Event, ...args: Array<unknown>) => void>} fn\n * @returns {(event: Event, ...args: unknown[]) => void}\n */\nexport function preventDefault(fn) {\n\treturn function (...args) {\n\t\tconst event = /** @type {Event} */ (args[0]);\n\t\tevent.preventDefault();\n\t\t// @ts-ignore\n\t\treturn unwrap(fn).apply(this, args);\n\t};\n}\n\n/**\n * @param {string} event_name\n * @param {Element} dom\n * @param {EventListener} handler\n * @param {boolean} capture\n * @param {boolean} [passive]\n * @returns {void}\n */\nexport function event(event_name, dom, handler, capture, passive) {\n\tconst options = {\n\t\tcapture,\n\t\tpassive\n\t};\n\tconst target_handler = handler;\n\tdom.addEventListener(event_name, target_handler, options);\n\t// @ts-ignore\n\tif (dom === document.body || dom === window || dom === document) {\n\t\trender_effect(() => {\n\t\t\treturn () => {\n\t\t\t\tdom.removeEventListener(event_name, target_handler, options);\n\t\t\t};\n\t\t});\n\t}\n}\n\n/**\n * @param {Element} dom\n * @param {() => string} value\n * @returns {void}\n */\nexport function class_name_effect(dom, value) {\n\trender_effect(() => {\n\t\tconst string = value();\n\t\tclass_name(dom, string);\n\t});\n}\n\n/**\n * @param {Element} dom\n * @param {string} value\n * @returns {void}\n */\nexport function class_name(dom, value) {\n\t// @ts-expect-error need to add __className to patched prototype\n\tconst prev_class_name = dom.__className;\n\tconst next_class_name = to_class(value);\n\tconst is_hydrating = current_hydration_fragment !== null;\n\tif (is_hydrating && dom.className === next_class_name) {\n\t\t// In case of hydration don't reset the class as it's already correct.\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t} else if (\n\t\tprev_class_name !== next_class_name ||\n\t\t(is_hydrating && dom.className !== next_class_name)\n\t) {\n\t\tif (next_class_name === '') {\n\t\t\tdom.removeAttribute('class');\n\t\t} else {\n\t\t\tset_class_name(dom, next_class_name);\n\t\t}\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t}\n}\n\n/**\n * @param {Element} dom\n * @param {() => string} value\n * @returns {void}\n */\nexport function text_effect(dom, value) {\n\trender_effect(() => {\n\t\tconst string = value();\n\t\ttext(dom, string);\n\t});\n}\n\n/**\n * @param {Element} dom\n * @param {string} value\n * @returns {void}\n */\nexport function text(dom, value) {\n\t// @ts-expect-error need to add __value to patched prototype\n\tconst prev_node_value = dom.__nodeValue;\n\tconst next_node_value = stringify(value);\n\tif (current_hydration_fragment !== null && dom.nodeValue === next_node_value) {\n\t\t// In case of hydration don't reset the nodeValue as it's already correct.\n\t\t// @ts-expect-error need to add __nodeValue to patched prototype\n\t\tdom.__nodeValue = next_node_value;\n\t} else if (prev_node_value !== next_node_value) {\n\t\tdom.nodeValue = next_node_value;\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__nodeValue = next_node_value;\n\t}\n}\n\n/**\n * @param {HTMLElement} dom\n * @param {boolean} value\n * @returns {void}\n */\nexport function auto_focus(dom, value) {\n\tif (value) {\n\t\tconst body = document.body;\n\t\tdom.autofocus = true;\n\t\trender_effect(\n\t\t\t() => {\n\t\t\t\tif (document.activeElement === body) {\n\t\t\t\t\tdom.focus();\n\t\t\t\t}\n\t\t\t},\n\t\t\tcurrent_block,\n\t\t\ttrue,\n\t\t\tfalse\n\t\t);\n\t}\n}\n\n/**\n * @template V\n * @param {V} value\n * @returns {string | V}\n */\nexport function to_class(value) {\n\treturn value == null ? '' : value;\n}\n\n/**\n * @param {Element} dom\n * @param {string} class_name\n * @param {boolean} value\n * @returns {void}\n */\nexport function class_toggle(dom, class_name, value) {\n\tif (value) {\n\t\tdom.classList.add(class_name);\n\t} else {\n\t\tdom.classList.remove(class_name);\n\t}\n}\n/**\n * Selects the correct option(s) (depending on whether this is a multiple select)\n * @template V\n * @param {HTMLSelectElement} select\n * @param {V} value\n */\nexport function select_option(select, value) {\n\tif (select.multiple) {\n\t\treturn select_options(select, value);\n\t}\n\tfor (let i = 0; i < select.options.length; i += 1) {\n\t\tconst option = select.options[i];\n\t\tconst option_value = get_option_value(option);\n\t\tif (option_value === value) {\n\t\t\toption.selected = true;\n\t\t\treturn;\n\t\t}\n\t}\n\tselect.value = '';\n}\n\n/**\n * @template V\n * @param {HTMLSelectElement} select\n * @param {V} value\n */\nfunction select_options(select, value) {\n\tfor (let i = 0; i < select.options.length; i += 1) {\n\t\tconst option = select.options[i];\n\t\t// @ts-ignore\n\t\toption.selected = ~value.indexOf(get_option_value(option));\n\t}\n}\n\n/** @param {HTMLOptionElement} option */\nfunction get_option_value(option) {\n\t// __value only exists if the <option> has a value attribute\n\tif ('__value' in option) {\n\t\treturn option.__value;\n\t} else {\n\t\treturn option.value;\n\t}\n}\n\n/**\n * @param {(online: boolean) => void} update\n * @returns {void}\n */\nexport function bind_online(update) {\n\tconst status_changed = () => {\n\t\tupdate(navigator.onLine);\n\t};\n\tlisten_to_events(window, ['online', 'offline'], status_changed);\n}\n\n/** @param {TimeRanges} ranges */\nfunction time_ranges_to_array(ranges) {\n\tconst array = [];\n\tfor (let i = 0; i < ranges.length; i += 1) {\n\t\tarray.push({ start: ranges.start(i), end: ranges.end(i) });\n\t}\n\treturn array;\n}\n\n/**\n * @param {HTMLVideoElement | HTMLAudioElement} media\n * @param {() => number | undefined} get_value\n * @param {(value: number) => void} update\n * @returns {void}\n */\nexport function bind_current_time(media, get_value, update) {\n\t/** @type {number} */\n\tlet raf_id;\n\tlet updating = false;\n\t// Ideally, listening to timeupdate would be enough, but it fires too infrequently for the currentTime\n\t// binding, which is why we use a raf loop, too. We additionally still listen to timeupdate because\n\t// the user could be scrubbing through the video using the native controls when the media is paused.\n\tconst callback = () => {\n\t\tcancelAnimationFrame(raf_id);\n\t\tif (!media.paused) {\n\t\t\traf_id = requestAnimationFrame(callback);\n\t\t}\n\t\tupdating = true;\n\t\tupdate(media.currentTime);\n\t};\n\traf_id = requestAnimationFrame(callback);\n\tmedia.addEventListener('timeupdate', callback);\n\trender_effect(() => {\n\t\tconst value = get_value();\n\t\t// through isNaN we also allow number strings, which is more robust\n\t\tif (!updating && !isNaN(/** @type {any} */ (value))) {\n\t\t\tmedia.currentTime = /** @type {number} */ (value);\n\t\t}\n\t\tupdating = false;\n\t});\n\trender_effect(() => () => cancelAnimationFrame(raf_id));\n}\n\n/**\n * @param {HTMLVideoElement | HTMLAudioElement} media\n * @param {(array: Array<{ start: number; end: number }>) => void} update\n */\nexport function bind_buffered(media, update) {\n\tconst callback = () => {\n\t\tupdate(time_ranges_to_array(media.buffered));\n\t};\n\tlisten_to_events(media, ['loadedmetadata', 'progress'], callback);\n}\n\n/**\n * @param {HTMLVideoElement | HTMLAudioElement} media\n * @param {(array: Array<{ start: number; end: number }>) => void} update\n */\nexport function bind_seekable(media, update) {\n\tconst callback = () => {\n\t\tupdate(time_ranges_to_array(media.seekable));\n\t};\n\tlisten_to_events(media, ['loadedmetadata'], callback);\n}\n\n/**\n * @param {HTMLVideoElement | HTMLAudioElement} media\n * @param {(array: Array<{ start: number; end: number }>) => void} update\n */\nexport function bind_played(media, update) {\n\tconst callback = () => {\n\t\tupdate(time_ranges_to_array(media.played));\n\t};\n\tlisten_to_events(media, ['timeupdate'], callback);\n}\n\n/**\n * @param {HTMLVideoElement | HTMLAudioElement} media\n * @param {(seeking: boolean) => void} update\n */\nexport function bind_seeking(media, update) {\n\tconst callback = () => {\n\t\tupdate(media.seeking);\n\t};\n\tlisten_to_events(media, ['seeking', 'seeked'], callback);\n}\n\n/**\n * @param {HTMLVideoElement | HTMLAudioElement} media\n * @param {(seeking: boolean) => void} update\n */\nexport function bind_ended(media, update) {\n\tconst callback = () => {\n\t\tupdate(media.ended);\n\t};\n\tlisten_to_events(media, ['timeupdate', 'ended'], callback);\n}\n\n/**\n * @param {HTMLVideoElement | HTMLAudioElement} media\n * @param {(ready_state: number) => void} update\n */\nexport function bind_ready_state(media, update) {\n\tconst callback = () => {\n\t\tupdate(media.readyState);\n\t};\n\tlisten_to_events(\n\t\tmedia,\n\t\t['loadedmetadata', 'loadeddata', 'canplay', 'canplaythrough', 'playing', 'waiting', 'emptied'],\n\t\tcallback\n\t);\n}\n\n/**\n * @param {HTMLVideoElement | HTMLAudioElement} media\n * @param {() => number | undefined} get_value\n * @param {(playback_rate: number) => void} update\n */\nexport function bind_playback_rate(media, get_value, update) {\n\tlet updating = false;\n\tconst callback = () => {\n\t\tif (!updating) {\n\t\t\tupdate(media.playbackRate);\n\t\t}\n\t\tupdating = false;\n\t};\n\t// Needs to happen after the element is inserted into the dom, else playback will be set back to 1 by the browser.\n\t// For hydration we could do it immediately but the additional code is not worth the lost microtask.\n\n\t/** @type {import('./types.js').ComputationSignal | undefined} */\n\tlet render;\n\tlet destroyed = false;\n\tconst effect = managed_effect(() => {\n\t\tdestroy_signal(effect);\n\t\tif (destroyed) return;\n\t\tif (get_value() == null) {\n\t\t\tcallback();\n\t\t}\n\t\tlisten_to_events(media, ['ratechange'], callback, false);\n\t\trender = render_effect(() => {\n\t\t\tconst value = get_value();\n\t\t\t// through isNaN we also allow number strings, which is more robust\n\t\t\tif (!isNaN(/** @type {any} */ (value)) && value !== media.playbackRate) {\n\t\t\t\tupdating = true;\n\t\t\t\tmedia.playbackRate = /** @type {number} */ (value);\n\t\t\t}\n\t\t});\n\t});\n\trender_effect(() => () => {\n\t\tdestroyed = true;\n\t\tif (render) {\n\t\t\tdestroy_signal(render);\n\t\t}\n\t});\n}\n\n/**\n * @param {HTMLVideoElement | HTMLAudioElement} media\n * @param {() => boolean | undefined} get_value\n * @param {(paused: boolean) => void} update\n */\nexport function bind_paused(media, get_value, update) {\n\tlet mounted = current_hydration_fragment !== null;\n\tlet paused = get_value();\n\tconst callback = () => {\n\t\tif (paused !== media.paused) {\n\t\t\tpaused = media.paused;\n\t\t\tupdate((paused = media.paused));\n\t\t}\n\t};\n\tif (paused == null) {\n\t\tcallback();\n\t}\n\t// Defer listening if not mounted yet so that the first canplay event doesn't cause a potentially wrong update\n\tif (mounted) {\n\t\t// If someone switches the src while media is playing, the player will pause.\n\t\t// Listen to the canplay event to get notified of this situation.\n\t\tlisten_to_events(media, ['play', 'pause', 'canplay'], callback, false);\n\t}\n\trender_effect(() => {\n\t\tpaused = !!get_value();\n\t\tif (paused !== media.paused) {\n\t\t\tconst toggle = () => {\n\t\t\t\tmounted = true;\n\t\t\t\tif (paused) {\n\t\t\t\t\tmedia.pause();\n\t\t\t\t} else {\n\t\t\t\t\tmedia.play().catch(() => {\n\t\t\t\t\t\tupdate((paused = true));\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (mounted) {\n\t\t\t\ttoggle();\n\t\t\t} else {\n\t\t\t\t// If this is the first invocation in dom mode, the media element isn't mounted yet,\n\t\t\t\t// and therefore its resource isn't loaded yet. We need to wait for the canplay event\n\t\t\t\t// in this case or else we'll get a \"The play() request was interrupted by a new load request\" error.\n\t\t\t\tmedia.addEventListener(\n\t\t\t\t\t'canplay',\n\t\t\t\t\t() => {\n\t\t\t\t\t\tlisten_to_events(media, ['play', 'pause', 'canplay'], callback, false);\n\t\t\t\t\t\ttoggle();\n\t\t\t\t\t},\n\t\t\t\t\t{ once: true }\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t});\n}\n\n/**\n * @param {HTMLVideoElement | HTMLAudioElement} media\n * @param {() => number | undefined} get_value\n * @param {(volume: number) => void} update\n */\nexport function bind_volume(media, get_value, update) {\n\tlet updating = false;\n\tconst callback = () => {\n\t\tupdating = true;\n\t\tupdate(media.volume);\n\t};\n\tif (get_value() == null) {\n\t\tcallback();\n\t}\n\tlisten_to_events(media, ['volumechange'], callback, false);\n\trender_effect(() => {\n\t\tconst value = get_value();\n\t\t// through isNaN we also allow number strings, which is more robust\n\t\tif (!updating && !isNaN(/** @type {any} */ (value))) {\n\t\t\tmedia.volume = /** @type {number} */ (value);\n\t\t}\n\t\tupdating = false;\n\t});\n}\n\n/**\n * @param {HTMLVideoElement | HTMLAudioElement} media\n * @param {() => boolean | undefined} get_value\n * @param {(muted: boolean) => void} update\n */\nexport function bind_muted(media, get_value, update) {\n\tlet updating = false;\n\tconst callback = () => {\n\t\tupdating = true;\n\t\tupdate(media.muted);\n\t};\n\tif (get_value() == null) {\n\t\tcallback();\n\t}\n\tlisten_to_events(media, ['volumechange'], callback, false);\n\trender_effect(() => {\n\t\tconst value = get_value();\n\t\tif (!updating) {\n\t\t\tmedia.muted = !!value;\n\t\t}\n\t\tupdating = false;\n\t});\n}\n/**\n * Fires the handler once immediately (unless corresponding arg is set to `false`),\n * then listens to the given events until the render effect context is destroyed\n * @param {Element | Window} dom\n * @param {Array<string>} events\n * @param {() => void} handler\n * @param {any} call_handler_immediately\n */\nfunction listen_to_events(dom, events, handler, call_handler_immediately = true) {\n\tif (call_handler_immediately) {\n\t\thandler();\n\t}\n\tfor (const name of events) {\n\t\tdom.addEventListener(name, handler);\n\t}\n\trender_effect(() => {\n\t\treturn () => {\n\t\t\tfor (const name of events) {\n\t\t\t\tdom.removeEventListener(name, handler);\n\t\t\t}\n\t\t};\n\t});\n}\n/**\n * Resize observer singleton.\n * One listener per element only!\n * https://groups.google.com/a/chromium.org/g/blink-dev/c/z6ienONUb5A/m/F5-VcUZtBAAJ\n */\nclass ResizeObserverSingleton {\n\t/** */\n\t#listeners = new WeakMap();\n\n\t/** @type {ResizeObserver | undefined} */\n\t#observer;\n\n\t/** @type {ResizeObserverOptions} */\n\t#options;\n\n\t/** @static */\n\tstatic entries = new WeakMap();\n\n\t/** @param {ResizeObserverOptions} options */\n\tconstructor(options) {\n\t\tthis.#options = options;\n\t}\n\n\t/**\n\t * @param {Element} element\n\t * @param {(entry: ResizeObserverEntry) => any} listener\n\t */\n\tobserve(element, listener) {\n\t\tconst listeners = this.#listeners.get(element) || new Set();\n\t\tlisteners.add(listener);\n\t\tthis.#listeners.set(element, listeners);\n\t\tthis.#getObserver().observe(element, this.#options);\n\t\treturn () => {\n\t\t\tconst listeners = this.#listeners.get(element);\n\t\t\tlisteners.delete(listener);\n\t\t\tif (listeners.size === 0) {\n\t\t\t\tthis.#listeners.delete(element);\n\t\t\t\t/** @type {ResizeObserver} */ (this.#observer).unobserve(element);\n\t\t\t}\n\t\t};\n\t}\n\t#getObserver() {\n\t\treturn (\n\t\t\tthis.#observer ??\n\t\t\t(this.#observer = new ResizeObserver(\n\t\t\t\t/** @param {any} entries */ (entries) => {\n\t\t\t\t\tfor (const entry of entries) {\n\t\t\t\t\t\tResizeObserverSingleton.entries.set(entry.target, entry);\n\t\t\t\t\t\tfor (const listener of this.#listeners.get(entry.target) || []) {\n\t\t\t\t\t\t\tlistener(entry);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t))\n\t\t);\n\t}\n}\nconst resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'content-box'\n});\nconst resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'border-box'\n});\nconst resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'device-pixel-content-box'\n});\n\n/**\n * @param {Element} dom\n * @param {'contentRect' | 'contentBoxSize' | 'borderBoxSize' | 'devicePixelContentBoxSize'} type\n * @param {(entry: keyof ResizeObserverEntry) => void} update\n */\nexport function bind_resize_observer(dom, type, update) {\n\tconst observer =\n\t\ttype === 'contentRect' || type === 'contentBoxSize'\n\t\t\t? resize_observer_content_box\n\t\t\t: type === 'borderBoxSize'\n\t\t\t? resize_observer_border_box\n\t\t\t: resize_observer_device_pixel_content_box;\n\tconst unsub = observer.observe(dom, /** @param {any} entry */ (entry) => update(entry[type]));\n\trender_effect(() => unsub);\n}\n\n/**\n * @param {HTMLElement} dom\n * @param {'clientWidth' | 'clientHeight' | 'offsetWidth' | 'offsetHeight'} type\n * @param {(size: number) => void} update\n */\nexport function bind_element_size(dom, type, update) {\n\t// We need to wait a few ticks to be sure that the element has been inserted and rendered\n\t// The alternative would be a mutation observer on the document but that's way to expensive\n\trequestAnimationFrame(() => requestAnimationFrame(() => update(dom[type])));\n\tconst unsub = resize_observer_border_box.observe(dom, () => update(dom[type]));\n\trender_effect(() => unsub);\n}\n\n/**\n * @param {'innerWidth' | 'innerHeight' | 'outerWidth' | 'outerHeight'} type\n * @param {(size: number) => void} update\n */\nexport function bind_window_size(type, update) {\n\tconst callback = () => update(window[type]);\n\tlisten_to_events(window, ['resize'], callback);\n}\n\n/**\n * Finds the containing `<select>` element and potentially updates its `selected` state.\n * @param {HTMLOptionElement} dom\n * @returns {void}\n */\nexport function selected(dom) {\n\t// Inside an effect because the element might not be connected\n\t// to the parent <select> yet when this is called\n\teffect(() => {\n\t\tlet select = dom.parentNode;\n\t\twhile (select != null) {\n\t\t\tif (select.nodeName === 'SELECT') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tselect = select.parentNode;\n\t\t}\n\t\tif (select != null) {\n\t\t\t// @ts-ignore\n\t\t\tconst select_value = select.__value;\n\t\t\t// @ts-ignore\n\t\t\tconst option_value = dom.__value;\n\t\t\tconst selected = select_value === option_value;\n\t\t\tdom.selected = selected;\n\t\t\tdom.value = option_value;\n\t\t\t// Handle the edge case of new options being added to a select when its state is \"nothing selected\"\n\t\t\t// and keeping the selection state in sync (the DOM auto-selects the first option on insert)\n\t\t\t// @ts-ignore\n\t\t\tif (select.__value === null) {\n\t\t\t\t/** @type {HTMLSelectElement} */ (select).value = '';\n\t\t\t}\n\t\t}\n\t});\n}\n\n/**\n * @param {Element} dom\n * @param {() => unknown} get_value\n * @param {(value: unknown) => void} update\n * @returns {void}\n */\nexport function bind_value(dom, get_value, update) {\n\tdom.addEventListener('input', () => {\n\t\t// @ts-ignore\n\t\tlet value = dom.value;\n\t\t// @ts-ignore\n\t\tconst type = dom.type;\n\t\tif (type === 'number' || type === 'range') {\n\t\t\tvalue = value === '' ? null : +value;\n\t\t}\n\t\tupdate(value);\n\t});\n\trender_effect(() => {\n\t\tconst value = get_value();\n\t\tconst coerced_value = value == null ? null : value + '';\n\t\t// @ts-ignore\n\t\tdom.value = coerced_value;\n\t\t// @ts-ignore\n\t\tdom.__value = value;\n\t});\n}\n\n/**\n * @param {HTMLSelectElement} dom\n * @param {() => unknown} get_value\n * @param {(value: unknown) => void} update\n * @returns {void}\n */\nexport function bind_select_value(dom, get_value, update) {\n\tlet mounted = false;\n\tdom.addEventListener('change', () => {\n\t\t/** @type {unknown} */\n\t\tlet value;\n\t\tif (dom.multiple) {\n\t\t\tvalue = [].map.call(dom.querySelectorAll(':checked'), get_option_value);\n\t\t} else {\n\t\t\t/** @type {HTMLOptionElement | null} */\n\t\t\tconst selected_option = dom.querySelector(':checked');\n\t\t\tvalue = selected_option && get_option_value(selected_option);\n\t\t}\n\t\tupdate(value);\n\t});\n\t// Needs to be an effect, not a render_effect, so that in case of each loops the logic runs after the each block has updated\n\teffect(() => {\n\t\tconst value = get_value();\n\t\tif (value == null && !mounted) {\n\t\t\t/** @type {HTMLOptionElement | null} */\n\t\t\tlet selected_option = value === undefined ? dom.querySelector(':checked') : null;\n\t\t\tif (selected_option === null) {\n\t\t\t\tdom.value = '';\n\t\t\t\t// @ts-ignore\n\t\t\t\tdom.__value = null;\n\t\t\t}\n\t\t\tconst options = dom.querySelectorAll('option');\n\t\t\tfor (const option of options) {\n\t\t\t\tif (get_option_value(option) === value || option.hasAttribute('selected')) {\n\t\t\t\t\tif (option.disabled) {\n\t\t\t\t\t\toption.value = '';\n\t\t\t\t\t}\n\t\t\t\t\toption.selected = true;\n\t\t\t\t\tselected_option = option;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (selected_option != null) {\n\t\t\t\tconst non_null_value = get_option_value(selected_option);\n\t\t\t\tupdate(non_null_value);\n\t\t\t\tif (selected_option.hasAttribute('selected')) {\n\t\t\t\t\tselected_option.removeAttribute('selected');\n\t\t\t\t\tselected_option.selected = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tselect_option(dom, value);\n\t\t\t// @ts-ignore\n\t\t\tdom.__value = value;\n\t\t}\n\t\tmounted = true;\n\t});\n}\n\n/**\n * @param {'innerHTML' | 'textContent' | 'innerText'} property\n * @param {HTMLElement} dom\n * @param {() => unknown} get_value\n * @param {(value: unknown) => void} update\n * @returns {void}\n */\nexport function bind_content_editable(property, dom, get_value, update) {\n\tdom.addEventListener('input', () => {\n\t\t// @ts-ignore\n\t\tconst value = dom[property];\n\t\tupdate(value);\n\t});\n\trender_effect(() => {\n\t\tconst value = get_value();\n\t\tif (dom[property] !== value) {\n\t\t\tif (value === null) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tconst non_null_value = dom[property];\n\t\t\t\tupdate(non_null_value);\n\t\t\t} else {\n\t\t\t\t// @ts-ignore\n\t\t\t\tdom[property] = value + '';\n\t\t\t}\n\t\t}\n\t});\n}\n\n/**\n * @template V\n * @param {Array<HTMLInputElement>} group\n * @param {V} __value\n * @param {boolean} checked\n * @returns {V[]}\n */\nfunction get_binding_group_value(group, __value, checked) {\n\tconst value = new Set();\n\tfor (let i = 0; i < group.length; i += 1) {\n\t\tif (group[i].checked) {\n\t\t\t// @ts-ignore\n\t\t\tvalue.add(group[i].__value);\n\t\t}\n\t}\n\tif (!checked) {\n\t\tvalue.delete(__value);\n\t}\n\treturn Array.from(value);\n}\n\n/**\n * @param {Array<HTMLInputElement>} group\n * @param {null | [number]} group_index\n * @param {HTMLInputElement} dom\n * @param {() => unknown} get_value\n * @param {(value: unknown) => void} update\n * @returns {void}\n */\nexport function bind_group(group, group_index, dom, get_value, update) {\n\tconst is_checkbox = dom.getAttribute('type') === 'checkbox';\n\tlet binding_group = group;\n\tif (group_index !== null) {\n\t\tfor (const index of group_index) {\n\t\t\tconst group = binding_group;\n\t\t\t// @ts-ignore\n\t\t\tbinding_group = group[index];\n\t\t\tif (binding_group === undefined) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tbinding_group = group[index] = [];\n\t\t\t}\n\t\t}\n\t}\n\tbinding_group.push(dom);\n\tdom.addEventListener('change', () => {\n\t\t// @ts-ignore\n\t\tlet value = dom.__value;\n\t\tif (is_checkbox) {\n\t\t\tvalue = get_binding_group_value(binding_group, value, dom.checked);\n\t\t}\n\t\tupdate(value);\n\t});\n\trender_effect(() => {\n\t\tlet value = get_value();\n\t\tif (is_checkbox) {\n\t\t\tvalue = value || [];\n\t\t\t// @ts-ignore\n\t\t\tdom.checked = value.includes(dom.__value);\n\t\t} else {\n\t\t\t// @ts-ignore\n\t\t\tdom.checked = dom.__value === value;\n\t\t}\n\t});\n\trender_effect(() => {\n\t\treturn () => {\n\t\t\tconst index = binding_group.indexOf(dom);\n\t\t\tif (index !== -1) {\n\t\t\t\tbinding_group.splice(index, 1);\n\t\t\t}\n\t\t};\n\t});\n}\n\n/**\n * @param {HTMLInputElement} dom\n * @param {() => unknown} get_value\n * @param {(value: unknown) => void} update\n * @returns {void}\n */\nexport function bind_checked(dom, get_value, update) {\n\tdom.addEventListener('change', () => {\n\t\tconst value = dom.checked;\n\t\tupdate(value);\n\t});\n\t// eslint-disable-next-line eqeqeq\n\tif (get_value() == undefined) {\n\t\tupdate(false);\n\t}\n\trender_effect(() => {\n\t\tconst value = get_value();\n\t\tdom.checked = Boolean(value);\n\t});\n}\n\n/**\n * @param {'x' | 'y'} type\n * @param {() => number} get_value\n * @param {(value: number) => void} update\n * @returns {void}\n */\nexport function bind_window_scroll(type, get_value, update) {\n\tconst is_scrolling_x = type === 'x';\n\tconst target_handler = () => {\n\t\tscrolling = true;\n\t\tclearTimeout(timeout);\n\t\ttimeout = setTimeout(clear, 100);\n\t\tconst value = window[is_scrolling_x ? 'scrollX' : 'scrollY'];\n\t\tupdate(value);\n\t};\n\taddEventListener('scroll', target_handler, {\n\t\tpassive: true\n\t});\n\tlet latest_value = 0;\n\tlet scrolling = false;\n\n\t/** @type {ReturnType<typeof setTimeout>} */\n\tlet timeout;\n\tconst clear = () => {\n\t\tscrolling = false;\n\t};\n\trender_effect(() => {\n\t\tlatest_value = get_value() || 0;\n\t\tif (!scrolling) {\n\t\t\tscrolling = true;\n\t\t\tclearTimeout(timeout);\n\t\t\tif (is_scrolling_x) {\n\t\t\t\tscrollTo(latest_value, window.scrollY);\n\t\t\t} else {\n\t\t\t\tscrollTo(window.scrollX, latest_value);\n\t\t\t}\n\t\t\ttimeout = setTimeout(clear, 100);\n\t\t}\n\t});\n\trender_effect(() => {\n\t\treturn () => {\n\t\t\tremoveEventListener('scroll', target_handler);\n\t\t};\n\t});\n}\n\n/**\n * @param {string} property\n * @param {string} event_name\n * @param {'get' | 'set'} type\n * @param {Element} dom\n * @param {() => unknown} get_value\n * @param {(value: unknown) => void} update\n * @returns {void}\n */\nexport function bind_property(property, event_name, type, dom, get_value, update) {\n\tconst target_handler = () => {\n\t\t// @ts-ignore\n\t\tconst value = dom[property];\n\t\tupdate(value);\n\t};\n\tdom.addEventListener(event_name, target_handler);\n\tif (type === 'set') {\n\t\trender_effect(() => {\n\t\t\tconst value = get_value();\n\t\t\t// @ts-ignore\n\t\t\tdom[property] = value;\n\t\t});\n\t}\n\tif (type === 'get') {\n\t\t// @ts-ignore\n\t\tconst value = dom[property];\n\t\tupdate(value);\n\t}\n\trender_effect(() => {\n\t\t// @ts-ignore\n\t\tif (dom === document.body || dom === window || dom === document) {\n\t\t\treturn () => {\n\t\t\t\tdom.removeEventListener(event_name, target_handler);\n\t\t\t};\n\t\t}\n\t});\n}\n/**\n * Makes an `export`ed (non-prop) variable available on the `$$props` object\n * so that consumers can do `bind:x` on the component.\n * @template V\n * @param {import('./types.js').MaybeSignal<Record<string, unknown>>} props\n * @param {string} prop\n * @param {V} value\n * @returns {void}\n */\nexport function bind_prop(props, prop, value) {\n\t/** @param {V | null} value */\n\tconst update = (value) => {\n\t\tconst current_props = unwrap(props);\n\t\tconst signal = expose(() => current_props[prop]);\n\t\tif (is_signal(signal)) {\n\t\t\tset(signal, value);\n\t\t} else if (Object.getOwnPropertyDescriptor(current_props, prop)?.set !== undefined) {\n\t\t\tcurrent_props[prop] = value;\n\t\t}\n\t};\n\tupdate(value);\n\trender_effect(() => () => {\n\t\tupdate(null);\n\t});\n}\n\n/**\n * @param {Element} element_or_component\n * @param {(value: unknown) => void} update\n * @returns {void}\n */\nexport function bind_this(element_or_component, update) {\n\tuntrack(() => {\n\t\tupdate(element_or_component);\n\t\trender_effect(() => () => {\n\t\t\tuntrack(() => {\n\t\t\t\tupdate(null);\n\t\t\t});\n\t\t});\n\t});\n}\n\n/**\n * @param {Array<string>} events\n * @returns {void}\n */\nexport function delegate(events) {\n\tfor (let i = 0; i < events.length; i++) {\n\t\tall_registerd_events.add(events[i]);\n\t}\n\tfor (const fn of root_event_handles) {\n\t\tfn(events);\n\t}\n}\n\n/**\n * @param {Node} root_element\n * @param {Event} event\n * @returns {void}\n */\nfunction handle_event_propagation(root_element, event) {\n\tconst event_name = event.type;\n\tconst path = event.composedPath?.() || [];\n\tlet current_target = /** @type {null | Element} */ (path[0] || event.target);\n\tif (event.target !== current_target) {\n\t\tdefine_property(event, 'target', {\n\t\t\tconfigurable: true,\n\t\t\tvalue: current_target\n\t\t});\n\t}\n\n\t// composedPath contains list of nodes the event has propagated through.\n\t// We check __root to skip all nodes below it in case this is a\n\t// parent of the __root node, which indicates that there's nested\n\t// mounted apps. In this case we don't want to trigger events multiple times.\n\t// We're deliberately not skipping if the index is the same or higher, because\n\t// someone could create an event programmatically and emit it multiple times,\n\t// in which case we want to handle the whole propagation chain properly each time.\n\tlet path_idx = 0;\n\t// @ts-expect-error is added below\n\tconst handled_at = event.__root;\n\tif (handled_at) {\n\t\tconst at_idx = path.indexOf(handled_at);\n\t\tif (at_idx < path.indexOf(root_element)) {\n\t\t\tpath_idx = at_idx;\n\t\t}\n\t}\n\tcurrent_target = /** @type {Element} */ (path[path_idx] || event.target);\n\t// Proxy currentTarget to correct target\n\tdefine_property(event, 'currentTarget', {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\t// TODO: ensure correct document?\n\t\t\treturn current_target || document;\n\t\t}\n\t});\n\n\twhile (current_target !== null) {\n\t\t/** @type {null | Element} */\n\t\tconst parent_element =\n\t\t\tcurrent_target.parentNode || /** @type {any} */ (current_target).host || null;\n\t\tconst internal_prop_name = '__' + event_name;\n\t\t// @ts-ignore\n\t\tconst delegated = current_target[internal_prop_name];\n\t\tif (delegated !== undefined && !(/** @type {any} */ (current_target).disabled)) {\n\t\t\tif (is_array(delegated)) {\n\t\t\t\tconst [fn, ...data] = delegated;\n\t\t\t\tfn.apply(current_target, [event, ...data]);\n\t\t\t} else {\n\t\t\t\tdelegated.call(current_target, event);\n\t\t\t}\n\t\t}\n\t\tif (event.cancelBubble || parent_element === root_element) {\n\t\t\tbreak;\n\t\t}\n\t\tcurrent_target = parent_element;\n\t}\n\n\t// @ts-expect-error is used above\n\tevent.__root = root_element;\n}\n\n/**\n * @param {Comment} anchor_node\n * @param {void | ((anchor: Comment, slot_props: Record<string, unknown>) => void)} slot_fn\n * @param {Record<string, unknown>} slot_props\n * @param {null | ((anchor: Comment) => void)} fallback_fn\n */\nexport function slot(anchor_node, slot_fn, slot_props, fallback_fn) {\n\thydrate_block_anchor(anchor_node);\n\tif (slot_fn === undefined) {\n\t\tif (fallback_fn !== null) {\n\t\t\tfallback_fn(anchor_node);\n\t\t}\n\t} else {\n\t\tslot_fn(anchor_node, slot_props);\n\t}\n}\n\n/**\n * @param {Comment} anchor_node\n * @param {() => boolean} condition_fn\n * @param {(anchor: Node) => void} consequent_fn\n * @param {null | ((anchor: Node) => void)} alternate_fn\n * @returns {void}\n */\nfunction if_block(anchor_node, condition_fn, consequent_fn, alternate_fn) {\n\tconst block = create_if_block();\n\thydrate_block_anchor(anchor_node);\n\tconst consequent_transitions = new Set();\n\tconst alternate_transitions = new Set();\n\tconst previous_hydration_fragment = current_hydration_fragment;\n\n\t/** @type {null | import('./types.js').TemplateNode | Array<import('./types.js').TemplateNode>} */\n\tlet consequent_dom = null;\n\t/** @type {null | import('./types.js').TemplateNode | Array<import('./types.js').TemplateNode>} */\n\tlet alternate_dom = null;\n\tlet has_mounted = false;\n\tlet has_mounted_branch = false;\n\n\tblock.transition =\n\t\t/**\n\t\t * @param {import('./types.js').Transition} transition\n\t\t * @returns {void}\n\t\t */\n\t\t(transition) => {\n\t\t\tif (block.current) {\n\t\t\t\tconsequent_transitions.add(transition);\n\t\t\t\ttransition.finished(() => {\n\t\t\t\t\tconsequent_transitions.delete(transition);\n\t\t\t\t\tremove_in_transitions(consequent_transitions);\n\t\t\t\t\tif (consequent_transitions.size === 0) {\n\t\t\t\t\t\texecute_effect(consequent_effect);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\talternate_transitions.add(transition);\n\t\t\t\ttransition.finished(() => {\n\t\t\t\t\talternate_transitions.delete(transition);\n\t\t\t\t\tremove_in_transitions(alternate_transitions);\n\t\t\t\t\tif (alternate_transitions.size === 0) {\n\t\t\t\t\t\texecute_effect(alternate_effect);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\tconst if_effect = render_effect(\n\t\t() => {\n\t\t\tconst result = !!condition_fn();\n\t\t\tif (block.current !== result || !has_mounted) {\n\t\t\t\tblock.current = result;\n\t\t\t\tif (has_mounted) {\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tremove_in_transitions(alternate_transitions);\n\t\t\t\t\t\tif (alternate_transitions.size === 0) {\n\t\t\t\t\t\t\texecute_effect(alternate_effect);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttrigger_transitions(alternate_transitions, 'out');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (consequent_transitions.size === 0) {\n\t\t\t\t\t\t\texecute_effect(consequent_effect);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttrigger_transitions(consequent_transitions, 'in');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tremove_in_transitions(consequent_transitions);\n\t\t\t\t\t\tif (consequent_transitions.size === 0) {\n\t\t\t\t\t\t\texecute_effect(consequent_effect);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttrigger_transitions(consequent_transitions, 'out');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (alternate_transitions.size === 0) {\n\t\t\t\t\t\t\texecute_effect(alternate_effect);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttrigger_transitions(alternate_transitions, 'in');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (current_hydration_fragment !== null) {\n\t\t\t\t\tconst comment_text = /** @type {Comment} */ (current_hydration_fragment?.[0])?.data;\n\t\t\t\t\tif (\n\t\t\t\t\t\t(!comment_text &&\n\t\t\t\t\t\t\t// Can happen when a svelte:element that is turned into a void element has an if block inside\n\t\t\t\t\t\t\tcurrent_hydration_fragment[0] !== null) ||\n\t\t\t\t\t\t(comment_text === 'ssr:if:true' && !result) ||\n\t\t\t\t\t\t(comment_text === 'ssr:if:false' && result)\n\t\t\t\t\t) {\n\t\t\t\t\t\t// Hydration mismatch: remove everything inside the anchor and start fresh.\n\t\t\t\t\t\t// This could happen using when `{#if browser} .. {/if}` in SvelteKit.\n\t\t\t\t\t\tremove(current_hydration_fragment);\n\t\t\t\t\t\tset_current_hydration_fragment(null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Remove the ssr:if comment node or else it will confuse the subsequent hydration algorithm\n\t\t\t\t\t\tcurrent_hydration_fragment.shift();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\thas_mounted = true;\n\t\t\t}\n\t\t},\n\t\tblock,\n\t\tfalse\n\t);\n\t// Managed effect\n\tconst consequent_effect = render_effect(\n\t\t() => {\n\t\t\tif (consequent_dom !== null) {\n\t\t\t\tremove(consequent_dom);\n\t\t\t\tconsequent_dom = null;\n\t\t\t}\n\t\t\tif (block.current) {\n\t\t\t\tconsequent_fn(anchor_node);\n\t\t\t\tif (!has_mounted_branch) {\n\t\t\t\t\t// Restore previous fragment so that Svelte continues to operate in hydration mode\n\t\t\t\t\tset_current_hydration_fragment(previous_hydration_fragment);\n\t\t\t\t\thas_mounted_branch = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconsequent_dom = block.dom;\n\t\t\tblock.dom = null;\n\t\t},\n\t\tblock,\n\t\ttrue\n\t);\n\t// Managed effect\n\tconst alternate_effect = render_effect(\n\t\t() => {\n\t\t\tif (alternate_dom !== null) {\n\t\t\t\tremove(alternate_dom);\n\t\t\t\talternate_dom = null;\n\t\t\t}\n\t\t\tif (!block.current) {\n\t\t\t\tif (alternate_fn !== null) {\n\t\t\t\t\talternate_fn(anchor_node);\n\t\t\t\t}\n\t\t\t\tif (!has_mounted_branch) {\n\t\t\t\t\t// Restore previous fragment so that Svelte continues to operate in hydration mode\n\t\t\t\t\tset_current_hydration_fragment(previous_hydration_fragment);\n\t\t\t\t\thas_mounted_branch = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\talternate_dom = block.dom;\n\t\t\tblock.dom = null;\n\t\t},\n\t\tblock,\n\t\ttrue\n\t);\n\tpush_destroy_fn(if_effect, () => {\n\t\tif (consequent_dom !== null) {\n\t\t\tremove(consequent_dom);\n\t\t}\n\t\tif (alternate_dom !== null) {\n\t\t\tremove(alternate_dom);\n\t\t}\n\t\tdestroy_signal(consequent_effect);\n\t\tdestroy_signal(alternate_effect);\n\t});\n\tblock.effect = if_effect;\n}\nexport { if_block as if };\n\n/**\n * @param {(anchor: Node | null) => void} render_fn\n * @returns {void}\n */\nexport function head(render_fn) {\n\tconst block = create_head_block();\n\t// The head function may be called after the first hydration pass and ssr comment nodes may still be present,\n\t// therefore we need to skip that when we detect that we're not in hydration mode.\n\tconst hydration_fragment =\n\t\tcurrent_hydration_fragment !== null ? get_hydration_fragment(document.head.firstChild) : null;\n\tconst previous_hydration_fragment = current_hydration_fragment;\n\tset_current_hydration_fragment(hydration_fragment);\n\ttry {\n\t\tconst head_effect = render_effect(\n\t\t\t() => {\n\t\t\t\tconst current = block.dom;\n\t\t\t\tif (current !== null) {\n\t\t\t\t\tremove(current);\n\t\t\t\t\tblock.dom = null;\n\t\t\t\t}\n\t\t\t\tlet anchor = null;\n\t\t\t\tif (current_hydration_fragment === null) {\n\t\t\t\t\tanchor = empty();\n\t\t\t\t\tdocument.head.appendChild(anchor);\n\t\t\t\t}\n\t\t\t\trender_fn(anchor);\n\t\t\t},\n\t\t\tblock,\n\t\t\tfalse\n\t\t);\n\t\tpush_destroy_fn(head_effect, () => {\n\t\t\tconst current = block.dom;\n\t\t\tif (current !== null) {\n\t\t\t\tremove(current);\n\t\t\t}\n\t\t});\n\t\tblock.effect = head_effect;\n\t} finally {\n\t\tset_current_hydration_fragment(previous_hydration_fragment);\n\t}\n}\n\n/**\n * @param {import('./types.js').Block} block\n * @param {Element} from\n * @param {Element} to\n * @returns {void}\n */\nfunction swap_block_dom(block, from, to) {\n\tconst dom = block.dom;\n\tif (is_array(dom)) {\n\t\tfor (let i = 0; i < dom.length; i++) {\n\t\t\tif (dom[i] === from) {\n\t\t\t\tdom[i] = to;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (dom === from) {\n\t\tblock.dom = to;\n\t}\n}\n\n/**\n * @param {Comment} anchor_node\n * @param {() => string} tag_fn\n * @param {null | ((element: Element, anchor: Node) => void)} render_fn\n * @param {any} is_svg\n * @returns {void}\n */\nexport function element(anchor_node, tag_fn, render_fn, is_svg = false) {\n\tconst block = create_dynamic_element_block();\n\thydrate_block_anchor(anchor_node);\n\tlet has_mounted = false;\n\n\t/** @type {string} */\n\tlet tag;\n\n\t/** @type {null | HTMLElement | SVGElement} */\n\tlet element = null;\n\tconst element_effect = render_effect(\n\t\t() => {\n\t\t\ttag = tag_fn();\n\t\t\tif (has_mounted) {\n\t\t\t\texecute_effect(render_effect_signal);\n\t\t\t}\n\t\t\thas_mounted = true;\n\t\t},\n\t\tblock,\n\t\tfalse\n\t);\n\t// Managed effect\n\tconst render_effect_signal = render_effect(\n\t\t() => {\n\t\t\tconst next_element = tag\n\t\t\t\t? current_hydration_fragment !== null\n\t\t\t\t\t? /** @type {HTMLElement | SVGElement} */ (current_hydration_fragment[0])\n\t\t\t\t\t: is_svg\n\t\t\t\t\t? document.createElementNS('http://www.w3.org/2000/svg', tag)\n\t\t\t\t\t: document.createElement(tag)\n\t\t\t\t: null;\n\t\t\tconst prev_element = element;\n\t\t\tif (prev_element !== null) {\n\t\t\t\tblock.dom = null;\n\t\t\t}\n\t\t\telement = next_element;\n\t\t\tif (element !== null && render_fn !== null) {\n\t\t\t\tlet anchor;\n\t\t\t\tif (current_hydration_fragment !== null) {\n\t\t\t\t\t// Use the existing ssr comment as the anchor so that the inner open and close\n\t\t\t\t\t// methods can pick up the existing nodes correctly\n\t\t\t\t\tanchor = /** @type {Comment} */ (element.firstChild);\n\t\t\t\t} else {\n\t\t\t\t\tanchor = empty();\n\t\t\t\t\telement.appendChild(anchor);\n\t\t\t\t}\n\t\t\t\trender_fn(element, anchor);\n\t\t\t}\n\t\t\tconst has_prev_element = prev_element !== null;\n\t\t\tif (has_prev_element) {\n\t\t\t\tremove(prev_element);\n\t\t\t}\n\t\t\tif (element !== null) {\n\t\t\t\tinsert(element, null, anchor_node);\n\t\t\t\tif (has_prev_element) {\n\t\t\t\t\tconst parent_block = block.parent;\n\t\t\t\t\tswap_block_dom(parent_block, prev_element, element);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tblock,\n\t\ttrue\n\t);\n\tpush_destroy_fn(element_effect, () => {\n\t\tif (element !== null) {\n\t\t\tremove(element);\n\t\t\tblock.dom = null;\n\t\t\telement = null;\n\t\t}\n\t\tdestroy_signal(render_effect_signal);\n\t});\n\tblock.effect = element_effect;\n}\n\n/**\n * @template P\n * @param {Comment} anchor_node\n * @param {() => (props: P) => void} component_fn\n * @param {(component: (props: P) => void) => void} render_fn\n * @returns {void}\n */\nexport function component(anchor_node, component_fn, render_fn) {\n\tconst block = create_dynamic_component_block();\n\n\t/** @type {null | import('./types.js').Render} */\n\tlet current_render = null;\n\thydrate_block_anchor(anchor_node);\n\n\t/** @type {null | ((props: P) => void)} */\n\tlet component = null;\n\tblock.transition =\n\t\t/**\n\t\t * @param {import('./types.js').Transition} transition\n\t\t * @returns {void}\n\t\t */\n\t\t(transition) => {\n\t\t\tconst render = /** @type {import('./types.js').Render} */ (current_render);\n\t\t\tconst transitions = render.transitions;\n\t\t\ttransitions.add(transition);\n\t\t\ttransition.finished(() => {\n\t\t\t\ttransitions.delete(transition);\n\t\t\t\tremove_in_transitions(transitions);\n\t\t\t\tif (transitions.size === 0) {\n\t\t\t\t\tif (render.effect !== null) {\n\t\t\t\t\t\tif (render.dom !== null) {\n\t\t\t\t\t\t\tremove(render.dom);\n\t\t\t\t\t\t\trender.dom = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdestroy_signal(render.effect);\n\t\t\t\t\t\trender.effect = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\tconst create_render_effect = () => {\n\t\t/** @type {import('./types.js').Render} */\n\t\tconst render = {\n\t\t\tdom: null,\n\t\t\teffect: null,\n\t\t\ttransitions: new Set(),\n\t\t\tprev: current_render\n\t\t};\n\t\t// Managed effect\n\t\tconst effect = render_effect(\n\t\t\t() => {\n\t\t\t\tconst current = block.dom;\n\t\t\t\tif (current !== null) {\n\t\t\t\t\tremove(current);\n\t\t\t\t\tblock.dom = null;\n\t\t\t\t}\n\t\t\t\tif (component) {\n\t\t\t\t\trender_fn(component);\n\t\t\t\t}\n\t\t\t\trender.dom = block.dom;\n\t\t\t\tblock.dom = null;\n\t\t\t},\n\t\t\tblock,\n\t\t\ttrue\n\t\t);\n\t\trender.effect = effect;\n\t\tcurrent_render = render;\n\t};\n\tconst render = () => {\n\t\tconst render = current_render;\n\t\tif (render === null) {\n\t\t\tcreate_render_effect();\n\t\t\treturn;\n\t\t}\n\t\tconst transitions = render.transitions;\n\t\tif (transitions.size === 0) {\n\t\t\tif (render.dom !== null) {\n\t\t\t\tremove(render.dom);\n\t\t\t\trender.dom = null;\n\t\t\t}\n\t\t\tif (render.effect) {\n\t\t\t\texecute_effect(render.effect);\n\t\t\t} else {\n\t\t\t\tcreate_render_effect();\n\t\t\t}\n\t\t} else {\n\t\t\tcreate_render_effect();\n\t\t\ttrigger_transitions(transitions, 'out');\n\t\t}\n\t};\n\tconst component_effect = render_effect(\n\t\t() => {\n\t\t\tconst next_component = component_fn();\n\t\t\tif (component !== next_component) {\n\t\t\t\tcomponent = next_component;\n\t\t\t\trender();\n\t\t\t}\n\t\t},\n\t\tblock,\n\t\tfalse\n\t);\n\tpush_destroy_fn(component_effect, () => {\n\t\tlet render = current_render;\n\t\twhile (render !== null) {\n\t\t\tconst dom = render.dom;\n\t\t\tif (dom !== null) {\n\t\t\t\tremove(dom);\n\t\t\t}\n\t\t\tconst effect = render.effect;\n\t\t\tif (effect !== null) {\n\t\t\t\tdestroy_signal(effect);\n\t\t\t}\n\t\t\trender = render.prev;\n\t\t}\n\t});\n\tblock.effect = component_effect;\n}\n\n/**\n * @template V\n * @param {Comment} anchor_node\n * @param {import('./types.js').Signal<Promise<V>> | Promise<V> | (() => Promise<V>)} input\n * @param {null | ((anchor: Node) => void)} pending_fn\n * @param {null | ((anchor: Node, value: V) => void)} then_fn\n * @param {null | ((anchor: Node, error: unknown) => void)} catch_fn\n * @returns {void}\n */\nfunction await_block(anchor_node, input, pending_fn, then_fn, catch_fn) {\n\tconst block = create_await_block();\n\n\t/** @type {null | import('./types.js').Render} */\n\tlet current_render = null;\n\thydrate_block_anchor(anchor_node);\n\n\t/** @type {{}} */\n\tlet latest_token;\n\n\t/** @type {typeof UNINITIALIZED | V} */\n\tlet resolved_value = UNINITIALIZED;\n\n\t/** @type {unknown} */\n\tlet error = UNINITIALIZED;\n\tlet pending = false;\n\tblock.transition =\n\t\t/**\n\t\t * @param {import('./types.js').Transition} transition\n\t\t * @returns {void}\n\t\t */\n\t\t(transition) => {\n\t\t\tconst render = /** @type {import('./types.js').Render} */ (current_render);\n\t\t\tconst transitions = render.transitions;\n\t\t\ttransitions.add(transition);\n\t\t\ttransition.finished(() => {\n\t\t\t\ttransitions.delete(transition);\n\t\t\t\tremove_in_transitions(transitions);\n\t\t\t\tif (transitions.size === 0) {\n\t\t\t\t\tif (render.effect !== null) {\n\t\t\t\t\t\tif (render.dom !== null) {\n\t\t\t\t\t\t\tremove(render.dom);\n\t\t\t\t\t\t\trender.dom = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdestroy_signal(render.effect);\n\t\t\t\t\t\trender.effect = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\tconst create_render_effect = () => {\n\t\t/** @type {import('./types.js').Render} */\n\t\tconst render = {\n\t\t\tdom: null,\n\t\t\teffect: null,\n\t\t\ttransitions: new Set(),\n\t\t\tprev: current_render\n\t\t};\n\t\tconst effect = render_effect(\n\t\t\t() => {\n\t\t\t\tif (error === UNINITIALIZED) {\n\t\t\t\t\tif (resolved_value === UNINITIALIZED) {\n\t\t\t\t\t\tblock.pending = true;\n\t\t\t\t\t\tif (pending_fn !== null) {\n\t\t\t\t\t\t\tpending_fn(anchor_node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (then_fn !== null) {\n\t\t\t\t\t\tblock.pending = false;\n\t\t\t\t\t\tthen_fn(anchor_node, resolved_value);\n\t\t\t\t\t}\n\t\t\t\t} else if (catch_fn !== null) {\n\t\t\t\t\tblock.pending = false;\n\t\t\t\t\tcatch_fn(anchor_node, error);\n\t\t\t\t}\n\t\t\t\trender.dom = block.dom;\n\t\t\t\tblock.dom = null;\n\t\t\t},\n\t\t\tblock,\n\t\t\ttrue,\n\t\t\ttrue\n\t\t);\n\t\trender.effect = effect;\n\t\tcurrent_render = render;\n\t};\n\tconst render = () => {\n\t\tconst render = current_render;\n\t\tif (render === null) {\n\t\t\tcreate_render_effect();\n\t\t\treturn;\n\t\t}\n\t\tconst transitions = render.transitions;\n\t\tremove_in_transitions(transitions);\n\t\tif (transitions.size === 0) {\n\t\t\tif (render.dom !== null) {\n\t\t\t\tremove(render.dom);\n\t\t\t\trender.dom = null;\n\t\t\t}\n\t\t\tif (render.effect) {\n\t\t\t\texecute_effect(render.effect);\n\t\t\t} else {\n\t\t\t\tcreate_render_effect();\n\t\t\t}\n\t\t} else {\n\t\t\tcreate_render_effect();\n\t\t\ttrigger_transitions(transitions, 'out');\n\t\t}\n\t};\n\tconst await_effect = render_effect(\n\t\t() => {\n\t\t\tconst token = {};\n\t\t\tlatest_token = token;\n\t\t\tconst promise = is_signal(input) ? get(input) : typeof input === 'function' ? input() : input;\n\t\t\tif (is_promise(promise)) {\n\t\t\t\tpromise.then(\n\t\t\t\t\t/** @param {V} v */\n\t\t\t\t\t(v) => {\n\t\t\t\t\t\tif (latest_token === token) {\n\t\t\t\t\t\t\t// Ensure UI is in sync before resolving value.\n\t\t\t\t\t\t\tflushSync();\n\t\t\t\t\t\t\tresolved_value = v;\n\t\t\t\t\t\t\tpending = false;\n\t\t\t\t\t\t\trender();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t/** @param {unknown} _error */\n\t\t\t\t\t(_error) => {\n\t\t\t\t\t\terror = _error;\n\t\t\t\t\t\tpending = false;\n\t\t\t\t\t\trender();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tif (resolved_value !== UNINITIALIZED || error !== UNINITIALIZED) {\n\t\t\t\t\terror = UNINITIALIZED;\n\t\t\t\t\tresolved_value = UNINITIALIZED;\n\t\t\t\t}\n\t\t\t\tif (!pending) {\n\t\t\t\t\tpending = true;\n\t\t\t\t\trender();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terror = UNINITIALIZED;\n\t\t\t\tresolved_value = promise;\n\t\t\t\tpending = false;\n\t\t\t\trender();\n\t\t\t}\n\t\t},\n\t\tblock,\n\t\tfalse\n\t);\n\tpush_destroy_fn(await_effect, () => {\n\t\tlet render = current_render;\n\t\tlatest_token = {};\n\t\twhile (render !== null) {\n\t\t\tconst dom = render.dom;\n\t\t\tif (dom !== null) {\n\t\t\t\tremove(dom);\n\t\t\t}\n\t\t\tconst effect = render.effect;\n\t\t\tif (effect !== null) {\n\t\t\t\tdestroy_signal(effect);\n\t\t\t}\n\t\t\trender = render.prev;\n\t\t}\n\t});\n\tblock.effect = await_effect;\n}\nexport { await_block as await };\n\n/**\n * @template V\n * @param {Comment} anchor_node\n * @param {() => V} key\n * @param {(anchor: Node) => void} render_fn\n * @returns {void}\n */\nexport function key(anchor_node, key, render_fn) {\n\tconst block = create_key_block();\n\n\t/** @type {null | import('./types.js').Render} */\n\tlet current_render = null;\n\thydrate_block_anchor(anchor_node);\n\n\t/** @type {V | typeof UNINITIALIZED} */\n\tlet key_value = UNINITIALIZED;\n\tlet mounted = false;\n\tblock.transition =\n\t\t/**\n\t\t * @param {import('./types.js').Transition} transition\n\t\t * @returns {void}\n\t\t */\n\t\t(transition) => {\n\t\t\tconst render = /** @type {import('./types.js').Render} */ (current_render);\n\t\t\tconst transitions = render.transitions;\n\t\t\ttransitions.add(transition);\n\t\t\ttransition.finished(() => {\n\t\t\t\ttransitions.delete(transition);\n\t\t\t\tremove_in_transitions(transitions);\n\t\t\t\tif (transitions.size === 0) {\n\t\t\t\t\tif (render.effect !== null) {\n\t\t\t\t\t\tif (render.dom !== null) {\n\t\t\t\t\t\t\tremove(render.dom);\n\t\t\t\t\t\t\trender.dom = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdestroy_signal(render.effect);\n\t\t\t\t\t\trender.effect = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\tconst create_render_effect = () => {\n\t\t/** @type {import('./types.js').Render} */\n\t\tconst render = {\n\t\t\tdom: null,\n\t\t\teffect: null,\n\t\t\ttransitions: new Set(),\n\t\t\tprev: current_render\n\t\t};\n\t\tconst effect = render_effect(\n\t\t\t() => {\n\t\t\t\trender_fn(anchor_node);\n\t\t\t\trender.dom = block.dom;\n\t\t\t\tblock.dom = null;\n\t\t\t},\n\t\t\tblock,\n\t\t\ttrue,\n\t\t\ttrue\n\t\t);\n\t\trender.effect = effect;\n\t\tcurrent_render = render;\n\t};\n\tconst render = () => {\n\t\tconst render = current_render;\n\t\tif (render === null) {\n\t\t\tcreate_render_effect();\n\t\t\treturn;\n\t\t}\n\t\tconst transitions = render.transitions;\n\t\tremove_in_transitions(transitions);\n\t\tif (transitions.size === 0) {\n\t\t\tif (render.dom !== null) {\n\t\t\t\tremove(render.dom);\n\t\t\t\trender.dom = null;\n\t\t\t}\n\t\t\tif (render.effect) {\n\t\t\t\texecute_effect(render.effect);\n\t\t\t} else {\n\t\t\t\tcreate_render_effect();\n\t\t\t}\n\t\t} else {\n\t\t\ttrigger_transitions(transitions, 'out');\n\t\t\tcreate_render_effect();\n\t\t}\n\t};\n\tconst key_effect = render_effect(\n\t\t() => {\n\t\t\tconst prev_key_value = key_value;\n\t\t\tkey_value = key();\n\t\t\tif (mounted && safe_not_equal(prev_key_value, key_value)) {\n\t\t\t\trender();\n\t\t\t}\n\t\t},\n\t\tblock,\n\t\tfalse\n\t);\n\t// To ensure topological ordering of the key effect to the render effect,\n\t// we trigger the effect after.\n\trender();\n\tmounted = true;\n\tpush_destroy_fn(key_effect, () => {\n\t\tlet render = current_render;\n\t\twhile (render !== null) {\n\t\t\tconst dom = render.dom;\n\t\t\tif (dom !== null) {\n\t\t\t\tremove(dom);\n\t\t\t}\n\t\t\tconst effect = render.effect;\n\t\t\tif (effect !== null) {\n\t\t\t\tdestroy_signal(effect);\n\t\t\t}\n\t\t\trender = render.prev;\n\t\t}\n\t});\n\tblock.effect = key_effect;\n}\n\n/**\n * @param {import('./types.js').Block} block\n * @returns {Text | Element | Comment}\n */\nfunction get_first_element(block) {\n\tconst current = block.dom;\n\tif (is_array(current)) {\n\t\tfor (let i = 0; i < current.length; i++) {\n\t\t\tconst node = current[i];\n\t\t\tif (node.nodeType !== 8) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t}\n\treturn /** @type {Text | Element | Comment} */ (current);\n}\n\n/**\n * @param {import('./types.js').EachItemBlock} block\n * @param {any} item\n * @param {number} index\n * @param {number} type\n * @returns {void}\n */\nexport function update_each_item_block(block, item, index, type) {\n\tif ((type & EACH_ITEM_REACTIVE) !== 0) {\n\t\tset_signal_value(block.item, item);\n\t}\n\tconst transitions = block.transitions;\n\tconst index_is_reactive = (type & EACH_INDEX_REACTIVE) !== 0;\n\t// Handle each item animations\n\tif (transitions !== null && (type & EACH_KEYED) !== 0) {\n\t\tlet prev_index = block.index;\n\t\tif (index_is_reactive) {\n\t\t\tprev_index = /** @type {import('./types.js').Signal<number>} */ (prev_index).v;\n\t\t}\n\t\tconst items = block.parent.items;\n\t\tif (prev_index !== index && /** @type {number} */ (index) < items.length) {\n\t\t\tconst from_dom = /** @type {Element} */ (get_first_element(block));\n\t\t\tconst from = from_dom.getBoundingClientRect();\n\t\t\tschedule_task(() => {\n\t\t\t\ttrigger_transitions(transitions, 'key', from);\n\t\t\t});\n\t\t}\n\t}\n\tif (index_is_reactive) {\n\t\tset_signal_value(/** @type {import('./types.js').Signal<number>} */ (block.index), index);\n\t} else {\n\t\tblock.index = index;\n\t}\n}\n\n/**\n * @param {import('./types.js').EachItemBlock} block\n * @param {null | Array<import('./types.js').Block>} transition_block\n * @param {boolean} apply_transitions\n * @param {any} controlled\n * @returns {void}\n */\nexport function destroy_each_item_block(\n\tblock,\n\ttransition_block,\n\tapply_transitions,\n\tcontrolled = false\n) {\n\tconst transitions = block.transitions;\n\tif (apply_transitions && transitions !== null) {\n\t\ttrigger_transitions(transitions, 'out');\n\t\tif (transition_block !== null) {\n\t\t\ttransition_block.push(block);\n\t\t}\n\t} else {\n\t\tconst dom = block.dom;\n\t\tif (!controlled && dom !== null) {\n\t\t\tremove(dom);\n\t\t}\n\t\tdestroy_signal(/** @type {import('./types.js').EffectSignal} */ (block.effect));\n\t}\n}\n\n/**\n * @template V\n * @param {V} item\n * @param {unknown} key\n * @param {number} index\n * @param {(anchor: null, item: V, index: number | import('./types.js').Signal<number>) => void} render_fn\n * @param {number} flags\n * @returns {import('./types.js').EachItemBlock}\n */\nexport function each_item_block(item, key, index, render_fn, flags) {\n\tconst item_value = (flags & EACH_ITEM_REACTIVE) === 0 ? item : source(item);\n\tconst index_value = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);\n\tconst block = create_each_item_block(item_value, index_value, key);\n\tconst effect = render_effect(\n\t\t/** @param {import('./types.js').EachItemBlock} block */\n\t\t(block) => {\n\t\t\trender_fn(null, block.item, block.index);\n\t\t},\n\t\tblock,\n\t\ttrue\n\t);\n\tblock.effect = effect;\n\treturn block;\n}\n\n/**\n * @template V\n * @param {Element | Comment} anchor_node\n * @param {() => V[]} collection\n * @param {number} flags\n * @param {null | ((item: V) => string)} key_fn\n * @param {(anchor: null, item: V, index: import('./types.js').MaybeSignal<number>) => void} render_fn\n * @param {null | ((anchor: Node) => void)} fallback_fn\n * @param {typeof reconcile_indexed_array | reconcile_tracked_array} reconcile_fn\n * @returns {void}\n */\nfunction each(anchor_node, collection, flags, key_fn, render_fn, fallback_fn, reconcile_fn) {\n\tconst is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;\n\tconst block = create_each_block(flags, anchor_node);\n\n\t/** @type {null | import('./types.js').Render} */\n\tlet current_fallback = null;\n\thydrate_block_anchor(anchor_node, is_controlled);\n\n\t/** @type {V[]} */\n\tlet array;\n\n\t/** @type {Array<string> | null} */\n\tlet keys = null;\n\n\t/** @type {null | import('./types.js').EffectSignal} */\n\tlet render = null;\n\tblock.transition =\n\t\t/** @param {import('./types.js').Transition} transition */\n\t\t(transition) => {\n\t\t\tconst fallback = /** @type {import('./types.js').Render} */ (current_fallback);\n\t\t\tconst transitions = fallback.transitions;\n\t\t\ttransitions.add(transition);\n\t\t\ttransition.finished(() => {\n\t\t\t\ttransitions.delete(transition);\n\t\t\t\tremove_in_transitions(transitions);\n\t\t\t\tif (transitions.size === 0) {\n\t\t\t\t\tif (fallback.effect !== null) {\n\t\t\t\t\t\tif (fallback.dom !== null) {\n\t\t\t\t\t\t\tremove(fallback.dom);\n\t\t\t\t\t\t\tfallback.dom = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdestroy_signal(fallback.effect);\n\t\t\t\t\t\tfallback.effect = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\tconst create_fallback_effect = () => {\n\t\t/** @type {import('./types.js').Render} */\n\t\tconst fallback = {\n\t\t\tdom: null,\n\t\t\teffect: null,\n\t\t\ttransitions: new Set(),\n\t\t\tprev: current_fallback\n\t\t};\n\t\t// Managed effect\n\t\tconst effect = render_effect(\n\t\t\t() => {\n\t\t\t\tconst dom = block.dom;\n\t\t\t\tif (dom !== null) {\n\t\t\t\t\tremove(dom);\n\t\t\t\t\tblock.dom = null;\n\t\t\t\t}\n\t\t\t\tlet anchor = block.anchor;\n\t\t\t\tconst is_controlled = (block.flags & EACH_IS_CONTROLLED) !== 0;\n\t\t\t\tif (is_controlled) {\n\t\t\t\t\tanchor = empty();\n\t\t\t\t\tblock.anchor.appendChild(anchor);\n\t\t\t\t}\n\t\t\t\t/** @type {(anchor: Node) => void} */ (fallback_fn)(anchor);\n\t\t\t\tfallback.dom = block.dom;\n\t\t\t\tblock.dom = null;\n\t\t\t},\n\t\t\tblock,\n\t\t\ttrue\n\t\t);\n\t\tfallback.effect = effect;\n\t\tcurrent_fallback = fallback;\n\t};\n\tconst each = render_effect(\n\t\t() => {\n\t\t\t/** @type {V[]} */\n\t\t\tconst maybe_array = collection();\n\t\t\tarray = is_array(maybe_array)\n\t\t\t\t? maybe_array\n\t\t\t\t: maybe_array == null\n\t\t\t\t? []\n\t\t\t\t: Array.from(maybe_array);\n\t\t\tif (key_fn !== null) {\n\t\t\t\tkeys = array.map(key_fn);\n\t\t\t}\n\t\t\tif (fallback_fn !== null) {\n\t\t\t\tif (array.length === 0) {\n\t\t\t\t\tif (block.items.length !== 0 || render === null) {\n\t\t\t\t\t\tcreate_fallback_effect();\n\t\t\t\t\t}\n\t\t\t\t} else if (block.items.length === 0 && current_fallback !== null) {\n\t\t\t\t\tconst fallback = current_fallback;\n\t\t\t\t\tconst transitions = fallback.transitions;\n\t\t\t\t\tif (transitions.size === 0) {\n\t\t\t\t\t\tif (fallback.dom !== null) {\n\t\t\t\t\t\t\tremove(fallback.dom);\n\t\t\t\t\t\t\tfallback.dom = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttrigger_transitions(transitions, 'out');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (render !== null) {\n\t\t\t\texecute_effect(render);\n\t\t\t}\n\t\t},\n\t\tblock,\n\t\tfalse\n\t);\n\trender = render_effect(\n\t\t/** @param {import('./types.js').EachBlock} block */\n\t\t(block) => {\n\t\t\tconst flags = block.flags;\n\t\t\tconst is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;\n\t\t\tconst anchor_node = block.anchor;\n\t\t\treconcile_fn(array, block, anchor_node, is_controlled, render_fn, flags, true, keys);\n\t\t},\n\t\tblock,\n\t\ttrue\n\t);\n\tpush_destroy_fn(each, () => {\n\t\tconst flags = block.flags;\n\t\tconst is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;\n\t\tconst anchor_node = block.anchor;\n\t\tlet fallback = current_fallback;\n\t\twhile (fallback !== null) {\n\t\t\tconst dom = fallback.dom;\n\t\t\tif (dom !== null) {\n\t\t\t\tremove(dom);\n\t\t\t}\n\t\t\tconst effect = fallback.effect;\n\t\t\tif (effect !== null) {\n\t\t\t\tdestroy_signal(effect);\n\t\t\t}\n\t\t\tfallback = fallback.prev;\n\t\t}\n\t\t// Clear the array\n\t\treconcile_fn([], block, anchor_node, is_controlled, render_fn, flags, false, keys);\n\t\tdestroy_signal(/** @type {import('./types.js').EffectSignal} */ (render));\n\t});\n\tblock.effect = each;\n}\n\n/**\n * @template V\n * @param {Element | Comment} anchor_node\n * @param {() => V[]} collection\n * @param {number} flags\n * @param {null | ((item: V) => string)} key_fn\n * @param {(anchor: null, item: V, index: import('./types.js').MaybeSignal<number>) => void} render_fn\n * @param {null | ((anchor: Node) => void)} fallback_fn\n * @returns {void}\n */\nexport function each_keyed(anchor_node, collection, flags, key_fn, render_fn, fallback_fn) {\n\teach(anchor_node, collection, flags, key_fn, render_fn, fallback_fn, reconcile_tracked_array);\n}\n\n/**\n * @template V\n * @param {Element | Comment} anchor_node\n * @param {() => V[]} collection\n * @param {number} flags\n * @param {(anchor: null, item: V, index: import('./types.js').MaybeSignal<number>) => void} render_fn\n * @param {null | ((anchor: Node) => void)} fallback_fn\n * @returns {void}\n */\nexport function each_indexed(anchor_node, collection, flags, render_fn, fallback_fn) {\n\teach(anchor_node, collection, flags, null, render_fn, fallback_fn, reconcile_indexed_array);\n}\n\n/**\n * @param {Element | Text | Comment} anchor\n * @param {boolean} is_html\n * @param {() => Record<string, string>} props\n * @param {(anchor: Element | Text | Comment) => any} component\n * @returns {void}\n */\nexport function cssProps(anchor, is_html, props, component) {\n\thydrate_block_anchor(anchor);\n\n\t/** @type {HTMLElement | SVGElement} */\n\tlet tag;\n\n\t/** @type {Text | Comment} */\n\tlet component_anchor;\n\tif (current_hydration_fragment !== null) {\n\t\t// Hydration: css props element is surrounded by a ssr comment ...\n\t\ttag = /** @type {HTMLElement | SVGElement} */ (current_hydration_fragment[0]);\n\t\t// ... and the child(ren) of the css props element is also surround by a ssr comment\n\t\tcomponent_anchor = /** @type {Comment} */ (tag.firstChild);\n\t} else {\n\t\tif (is_html) {\n\t\t\ttag = document.createElement('div');\n\t\t\ttag.style.display = 'contents';\n\t\t} else {\n\t\t\ttag = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n\t\t}\n\t\tinsert(tag, null, anchor);\n\t\tcomponent_anchor = empty();\n\t\ttag.appendChild(component_anchor);\n\t}\n\tcomponent(component_anchor);\n\n\t/** @type {Record<string, string>} */\n\tlet current_props = {};\n\tconst effect = render_effect(() => {\n\t\tconst next_props = props();\n\t\tfor (const key in current_props) {\n\t\t\tif (!(key in next_props)) {\n\t\t\t\ttag.style.removeProperty(key);\n\t\t\t}\n\t\t}\n\t\tfor (const key in next_props) {\n\t\t\ttag.style.setProperty(key, next_props[key]);\n\t\t}\n\t\tcurrent_props = next_props;\n\t});\n\tpush_destroy_fn(effect, () => {\n\t\tremove(tag);\n\t});\n}\n\n/**\n * @param {unknown} value\n * @returns {string}\n */\nexport function stringify(value) {\n\treturn typeof value === 'string' ? value : value == null ? '' : value + '';\n}\n\n/**\n * @param {Element | Text | Comment} dom\n * @param {() => string} get_value\n * @param {boolean} svg\n * @returns {void}\n */\nexport function html(dom, get_value, svg) {\n\t/** @type {import('./types.js').TemplateNode | import('./types.js').TemplateNode[]} */\n\tlet html_dom;\n\t/** @type {string} */\n\tlet value;\n\tconst effect = render_effect(() => {\n\t\tif (value !== (value = get_value())) {\n\t\t\tif (html_dom) {\n\t\t\t\tremove(html_dom);\n\t\t\t}\n\t\t\thtml_dom = reconcile_html(dom, value, svg);\n\t\t}\n\t});\n\tpush_destroy_fn(effect, () => {\n\t\tif (html_dom) {\n\t\t\tremove(html_dom);\n\t\t}\n\t});\n}\n\n/**\n * @template P\n * @param {HTMLElement} dom\n * @param {import('./types.js').TransitionFn<P | undefined>} transition_fn\n * @param {(() => P) | null} props\n * @param {any} global\n * @returns {void}\n */\nexport function transition(dom, transition_fn, props, global = false) {\n\tbind_transition(dom, transition_fn, props, 'both', global);\n}\n\n/**\n * @template P\n * @param {HTMLElement} dom\n * @param {import('./types.js').TransitionFn<P | undefined>} transition_fn\n * @param {(() => P) | null} props\n * @returns {void}\n */\nexport function animate(dom, transition_fn, props) {\n\tbind_transition(dom, transition_fn, props, 'key', false);\n}\n\n/**\n * @template P\n * @param {HTMLElement} dom\n * @param {import('./types.js').TransitionFn<P | undefined>} transition_fn\n * @param {(() => P) | null} props\n * @param {any} global\n * @returns {void}\n */\nfunction in_fn(dom, transition_fn, props, global = false) {\n\tbind_transition(dom, transition_fn, props, 'in', global);\n}\nexport { in_fn as in };\n\n/**\n * @template P\n * @param {HTMLElement} dom\n * @param {import('./types.js').TransitionFn<P | undefined>} transition_fn\n * @param {(() => P) | null} props\n * @param {any} global\n * @returns {void}\n */\nexport function out(dom, transition_fn, props, global = false) {\n\tbind_transition(dom, transition_fn, props, 'out', global);\n}\n\n/**\n * @template P\n * @param {Element} dom\n * @param {(dom: Element, value?: P) => import('./types.js').ActionPayload<P>} action\n * @param {() => P} [value_fn]\n * @returns {void}\n */\nexport function action(dom, action, value_fn) {\n\t/** @type {undefined | import('./types.js').ActionPayload<P>} */\n\tlet payload = undefined;\n\t// Action could come from a prop, therefore could be a signal, therefore untrack\n\t// TODO we could take advantage of this and enable https://github.com/sveltejs/svelte/issues/6942\n\teffect(() => {\n\t\tif (value_fn) {\n\t\t\tconst value = value_fn();\n\t\t\tuntrack(() => {\n\t\t\t\tif (payload === undefined) {\n\t\t\t\t\tpayload = action(dom, value);\n\t\t\t\t} else {\n\t\t\t\t\tconst update = payload.update;\n\t\t\t\t\tif (typeof update === 'function') {\n\t\t\t\t\t\tupdate(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tuntrack(() => (payload = action(dom)));\n\t\t}\n\t});\n\teffect(() => {\n\t\tif (payload !== undefined) {\n\t\t\tconst destroy = payload.destroy;\n\t\t\tif (typeof destroy === 'function') {\n\t\t\t\treturn () => {\n\t\t\t\t\tdestroy();\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t});\n}\n/**\n * The value/checked attribute in the template actually corresponds to the defaultValue property, so we need\n * to remove it upon hydration to avoid a bug when someone resets the form value.\n * @param {HTMLInputElement | HTMLSelectElement} dom\n * @returns {void}\n */\nexport function remove_input_attr_defaults(dom) {\n\tif (current_hydration_fragment !== null) {\n\t\tattr(dom, 'value', null);\n\t\tattr(dom, 'checked', null);\n\t}\n}\n/**\n * The child of a textarea actually corresponds to the defaultValue property, so we need\n * to remove it upon hydration to avoid a bug when someone resets the form value.\n * @param {HTMLTextAreaElement} dom\n * @returns {void}\n */\nexport function remove_textarea_child(dom) {\n\tif (current_hydration_fragment !== null && dom.firstChild !== null) {\n\t\tdom.textContent = '';\n\t}\n}\n\n/**\n * @param {Element} dom\n * @param {string} attribute\n * @param {() => string} value\n */\nexport function attr_effect(dom, attribute, value) {\n\trender_effect(() => {\n\t\tconst string = value();\n\t\tattr(dom, attribute, string);\n\t});\n}\n\n/**\n * @param {Element} dom\n * @param {string} attribute\n * @param {string | null} value\n */\nexport function attr(dom, attribute, value) {\n\tvalue = value == null ? null : value + '';\n\n\tif (DEV) {\n\t\tcheck_src_in_dev_hydration(dom, attribute, value);\n\t}\n\n\tif (\n\t\tcurrent_hydration_fragment === null ||\n\t\t(dom.getAttribute(attribute) !== value &&\n\t\t\t// If we reset those, they would result in another network request, which we want to avoid.\n\t\t\t// We assume they are the same between client and server as checking if they are equal is expensive\n\t\t\t// (we can't just compare the strings as they can be different between client and server but result in the\n\t\t\t// same url, so we would need to create hidden anchor elements to compare them)\n\t\t\tattribute !== 'src' &&\n\t\t\tattribute !== 'srcset')\n\t) {\n\t\tif (value === null) {\n\t\t\tdom.removeAttribute(attribute);\n\t\t} else {\n\t\t\tdom.setAttribute(attribute, value);\n\t\t}\n\t}\n}\n\n/** @type {HTMLAnchorElement | undefined} */\nlet src_url_equal_anchor;\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nexport function src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\tif (!src_url_equal_anchor) {\n\t\tsrc_url_equal_anchor = document.createElement('a');\n\t}\n\t// This is actually faster than doing URL(..).href\n\tsrc_url_equal_anchor.href = url;\n\treturn element_src === src_url_equal_anchor.href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element_srcset\n * @param {string | undefined | null} srcset\n * @returns {boolean}\n */\nexport function srcset_url_equal(element_srcset, srcset) {\n\tconst element_urls = split_srcset(element_srcset.srcset);\n\tconst urls = split_srcset(srcset || '');\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n\n/**\n * @param {any} dom\n * @param {string} attribute\n * @param {string | null} value\n */\nfunction check_src_in_dev_hydration(dom, attribute, value) {\n\tif (current_hydration_fragment !== null && (attribute === 'src' || attribute === 'srcset')) {\n\t\tif (\n\t\t\t(attribute === 'src' && !src_url_equal(dom.getAttribute('src') || '', value || '')) ||\n\t\t\t(attribute === 'srcset' &&\n\t\t\t\t!srcset_url_equal(/** @type {HTMLImageElement | HTMLSourceElement} */ (dom), value || ''))\n\t\t) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.error(\n\t\t\t\t'Detected a src/srcset attribute value change during hydration. This will not be repaired during hydration, ' +\n\t\t\t\t\t'the src/srcset value that came from the server will be used. Related element:',\n\t\t\t\tdom,\n\t\t\t\t' Differing value:',\n\t\t\t\tvalue\n\t\t\t);\n\t\t}\n\t}\n}\n\n/**\n * @param {Element} dom\n * @param {string} attribute\n * @param {() => string} value\n */\nexport function xlink_attr_effect(dom, attribute, value) {\n\trender_effect(() => {\n\t\tconst string = value();\n\t\txlink_attr(dom, attribute, string);\n\t});\n}\n\n/**\n * @param {Element} dom\n * @param {string} attribute\n * @param {string} value\n */\nexport function xlink_attr(dom, attribute, value) {\n\tdom.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\n\n/**\n * @param {any} node\n * @param {string} prop\n * @param {() => any} value\n */\nexport function set_custom_element_data_effect(node, prop, value) {\n\trender_effect(() => {\n\t\tset_custom_element_data(node, prop, value());\n\t});\n}\n\n/**\n * @param {any} node\n * @param {string} prop\n * @param {any} value\n */\nexport function set_custom_element_data(node, prop, value) {\n\tif (prop in node) {\n\t\tnode[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n\t} else {\n\t\tattr(node, prop, value);\n\t}\n}\n\n/**\n * @param {HTMLElement} dom\n * @param {string} key\n * @param {string} value\n * @param {boolean} [important]\n */\nexport function style(dom, key, value, important) {\n\tif (value == null) {\n\t\tdom.style.removeProperty(key);\n\t} else {\n\t\tdom.style.setProperty(key, value, important ? 'important' : '');\n\t}\n}\n\n/**\n * List of attributes that should always be set through the attr method,\n * because updating them through the property setter doesn't work reliably.\n * In the example of `width`/`height`, the problem is that the setter only\n * accepts numeric values, but the attribute can also be set to a string like `50%`.\n * If this list becomes too big, rethink this approach.\n */\nconst always_set_through_set_attribute = ['width', 'height'];\n\n/** @type {Map<string, string[]>} */\nconst setters_cache = new Map();\n\n/** @param {Element} element */\nfunction get_setters(element) {\n\t/** @type {string[]} */\n\tconst setters = [];\n\t// @ts-expect-error\n\tconst descriptors = get_descriptors(element.__proto__);\n\tfor (const key in descriptors) {\n\t\tif (descriptors[key].set && !always_set_through_set_attribute.includes(key)) {\n\t\t\tsetters.push(key);\n\t\t}\n\t}\n\treturn setters;\n}\n\n/**\n * Spreads attributes onto a DOM element, taking into account the currently set attributes\n * @param {Element & ElementCSSInlineStyle} dom\n * @param {Record<string, unknown> | null} prev\n * @param {Record<string, unknown>[]} attrs\n * @param {string} css_hash\n * @returns {Record<string, unknown>}\n */\nexport function spread_attributes(dom, prev, attrs, css_hash) {\n\tconst next = Object.assign({}, ...attrs);\n\tconst has_hash = css_hash.length !== 0;\n\tfor (const key in prev) {\n\t\tif (!(key in next)) {\n\t\t\tnext[key] = null;\n\t\t}\n\t}\n\tif (has_hash && !next.class) {\n\t\tnext.class = '';\n\t}\n\n\tlet setters = map_get(setters_cache, dom.nodeName);\n\tif (!setters) map_set(setters_cache, dom.nodeName, (setters = get_setters(dom)));\n\n\tfor (const key in next) {\n\t\tlet value = next[key];\n\t\tif (value === prev?.[key]) continue;\n\n\t\tconst prefix = key.slice(0, 2);\n\t\tif (prefix === '$$') continue;\n\n\t\tif (prefix === 'on') {\n\t\t\t/** @type {{ capture?: true }} */\n\t\t\tconst opts = {};\n\t\t\tlet event_name = key.slice(2).toLowerCase();\n\t\t\tconst delegated = DelegatedEvents.includes(event_name);\n\n\t\t\tif (\n\t\t\t\tevent_name.endsWith('capture') &&\n\t\t\t\tevent_name !== 'ongotpointercapture' &&\n\t\t\t\tevent_name !== 'onlostpointercapture'\n\t\t\t) {\n\t\t\t\tevent_name = event_name.slice(0, -7);\n\t\t\t\topts.capture = true;\n\t\t\t}\n\t\t\tif (!delegated && prev?.[key]) {\n\t\t\t\tdom.removeEventListener(event_name, /** @type {any} */ (prev[key]), opts);\n\t\t\t}\n\t\t\tif (value != null) {\n\t\t\t\tif (!delegated) {\n\t\t\t\t\tdom.addEventListener(event_name, value, opts);\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tdom[`__${event_name}`] = value;\n\t\t\t\t\tdelegate([event_name]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (value == null) {\n\t\t\tdom.removeAttribute(key);\n\t\t} else if (key === 'style') {\n\t\t\tdom.style.cssText = value + '';\n\t\t} else if (key === 'autofocus') {\n\t\t\tauto_focus(/** @type {HTMLElement} */ (dom), Boolean(value));\n\t\t} else if (key === '__value' || key === 'value') {\n\t\t\t// @ts-ignore\n\t\t\tdom.value = dom[key] = dom.__value = value;\n\t\t} else if (setters.includes(key)) {\n\t\t\tif (DEV) {\n\t\t\t\tcheck_src_in_dev_hydration(dom, key, value);\n\t\t\t}\n\t\t\tif (\n\t\t\t\tcurrent_hydration_fragment === null ||\n\t\t\t\t//  @ts-ignore see attr method for an explanation of src/srcset\n\t\t\t\t(dom[key] !== value && key !== 'src' && key !== 'srcset')\n\t\t\t) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tdom[key] = value;\n\t\t\t}\n\t\t} else if (typeof value !== 'function') {\n\t\t\tif (has_hash && key === 'class') {\n\t\t\t\tif (value) value += ' ';\n\t\t\t\tvalue += css_hash;\n\t\t\t}\n\n\t\t\tattr(dom, key, value);\n\t\t}\n\t}\n\treturn next;\n}\n\n/**\n * @param {Element} node\n * @param {Record<string, unknown> | null} prev\n * @param {Record<string, unknown>[]} attrs\n * @param {string} css_hash\n */\nexport function spread_dynamic_element_attributes(node, prev, attrs, css_hash) {\n\tif (node.tagName.includes('-')) {\n\t\tconst next = Object.assign({}, ...attrs);\n\t\tif (prev !== null) {\n\t\t\tfor (const key in prev) {\n\t\t\t\tif (!(key in next)) {\n\t\t\t\t\tnext[key] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const key in next) {\n\t\t\tset_custom_element_data(node, key, next[key]);\n\t\t}\n\t\treturn next;\n\t} else {\n\t\treturn spread_attributes(\n\t\t\t/** @type {Element & ElementCSSInlineStyle} */ (node),\n\t\t\tprev,\n\t\t\tattrs,\n\t\t\tcss_hash\n\t\t);\n\t}\n}\n\n/**\n * @param {import('./types.js').Signal<Record<string, unknown>> | Record<string, unknown>} props_signal\n * @param {string[]} rest\n * @returns {Record<string, unknown>}\n */\nexport function rest_props(props_signal, rest) {\n\treturn derived(() => {\n\t\tvar props = unwrap(props_signal);\n\n\t\t/** @type {Record<string, unknown>} */\n\t\tvar rest_props = {};\n\n\t\tfor (var key in props) {\n\t\t\tif (rest.includes(key)) continue;\n\n\t\t\tconst { get, value, enumerable } = /** @type {PropertyDescriptor} */ (\n\t\t\t\tget_descriptor(props, key)\n\t\t\t);\n\n\t\t\tdefine_property(rest_props, key, get ? { get, enumerable } : { value, enumerable });\n\t\t}\n\n\t\treturn rest_props;\n\t});\n}\n\n/**\n * @param {Record<string, unknown>[] | (() => Record<string, unknown>[])} props\n * @returns {any}\n */\nexport function spread_props(props) {\n\tif (typeof props === 'function') {\n\t\treturn derived(() => {\n\t\t\treturn spread_props(props());\n\t\t});\n\t}\n\n\t/** @type {Record<string, unknown>} */\n\tconst merged_props = {};\n\tlet key;\n\tfor (let i = 0; i < props.length; i++) {\n\t\tconst obj = props[i];\n\t\tfor (key in obj) {\n\t\t\tconst desc = /** @type {PropertyDescriptor} */ (get_descriptor(obj, key));\n\t\t\tconst getter = desc.get;\n\t\t\tif (getter !== undefined) {\n\t\t\t\tdefine_property(merged_props, key, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tget: getter\n\t\t\t\t});\n\t\t\t} else if (desc.get !== undefined) {\n\t\t\t\tmerged_props[key] = obj[key];\n\t\t\t} else {\n\t\t\t\tdefine_property(merged_props, key, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tvalue: obj[key]\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\treturn merged_props;\n}\n\n/**\n * @template V\n * @param {V} value\n * @returns {import('./types.js').UnwrappedSignal<V>}\n */\nexport function unwrap(value) {\n\tif (is_signal(value)) {\n\t\t// @ts-ignore\n\t\treturn get(value);\n\t}\n\t// @ts-ignore\n\treturn value;\n}\n\n/**\n * Mounts the given component to the given target and returns a handle to the component's public accessors\n * as well as a `$set` and `$destroy` method to update the props of the component or destroy it.\n *\n * If you don't need to interact with the component after mounting, use `mount` instead to save some bytes.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any> | undefined} Exports\n * @template {Record<string, any>} Events\n * @param {import('../../main/public.js').SvelteComponent<Props, Events>} component\n * @param {{\n * \t\ttarget: Node;\n * \t\tprops?: Props;\n *  \tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t\timmutable?: boolean;\n * \t\trecover?: false;\n * \t}} options\n * @returns {Exports & { $destroy: () => void; $set: (props: Partial<Props>) => void; }}\n */\nexport function createRoot(component, options) {\n\t// The following definitions aren't duplicative. We need _sources to update single props and\n\t// _props in case the component uses $$props / $$restProps / const { x, ...rest } = $props().\n\t/** @type {any} */\n\tconst _props = {};\n\t/** @type {any} */\n\tconst _sources = {};\n\n\t/**\n\t * @param {string} name\n\t * @param {any} value\n\t */\n\tfunction add_prop(name, value) {\n\t\tconst prop = source(\n\t\t\tvalue,\n\t\t\toptions.immutable\n\t\t\t\t? /**\n\t\t\t\t   * @param {any} a\n\t\t\t\t   * @param {any} b\n\t\t\t\t   */ (a, b) => a === b\n\t\t\t\t: safe_equal\n\t\t);\n\t\t_sources[name] = prop;\n\t\tdefine_property(_props, name, {\n\t\t\tget() {\n\t\t\t\treturn get(prop);\n\t\t\t},\n\t\t\tenumerable: true\n\t\t});\n\t}\n\n\tfor (const prop in options.props || {}) {\n\t\tadd_prop(\n\t\t\tprop,\n\t\t\t// @ts-expect-error TS doesn't understand this properly\n\t\t\toptions.props[prop]\n\t\t);\n\t}\n\n\t// The proxy ensures that we can add new signals on the fly when a prop signal is accessed from within the component\n\t// but no corresponding prop value was set from the outside. The whole things becomes a _propsSignal\n\t// so that adding new props is reflected in the component if it uses $$props or $$restProps.\n\tconst props_proxy = new Proxy(_props, {\n\t\t/**\n\t\t * @param {any} target\n\t\t * @param {any} property\n\t\t */\n\t\tget: (target, property) => {\n\t\t\tif (typeof property !== 'string') return target[property];\n\t\t\tif (!(property in _sources)) {\n\t\t\t\tadd_prop(property, undefined);\n\t\t\t}\n\t\t\treturn _props[property];\n\t\t}\n\t});\n\tconst props_source = source(\n\t\tprops_proxy,\n\t\t// We're resetting the same proxy instance for updates, therefore bypass equality checks\n\t\t() => false\n\t);\n\n\tlet [accessors, $destroy] = mount(component, {\n\t\t...options,\n\t\t// @ts-expect-error We hide the \"the props object could be a signal\" fact from the public typings\n\t\tprops: props_source\n\t});\n\n\tconst result =\n\t\t/** @type {Exports & { $destroy: () => void; $set: (props: Partial<Props>) => void; }} */ ({\n\t\t\t$set: (props) => {\n\t\t\t\tfor (const [prop, value] of Object.entries(props)) {\n\t\t\t\t\tif (prop in _sources) {\n\t\t\t\t\t\tset(_sources[prop], value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tadd_prop(prop, value);\n\t\t\t\t\t\tset(props_source, props_proxy);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t$destroy\n\t\t});\n\n\tfor (const key of Object.keys(accessors || {})) {\n\t\tdefine_property(result, key, {\n\t\t\tget() {\n\t\t\t\t// @ts-expect-error TS doesn't know key exists on accessor\n\t\t\t\treturn accessors[key];\n\t\t\t},\n\t\t\t/** @param {any} value */\n\t\t\tset(value) {\n\t\t\t\t// @ts-expect-error TS doesn't know key exists on accessor\n\t\t\t\taccessors[key] = value;\n\t\t\t},\n\t\t\tenumerable: true\n\t\t});\n\t}\n\n\treturn result;\n}\n\n/**\n * Mounts the given component to the given target and returns the accessors of the component and a function to destroy it.\n *\n * If you need to interact with the component after mounting, use `create` instead.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any> | undefined} Exports\n * @template {Record<string, any>} Events\n * @param {import('../../main/public.js').SvelteComponent<Props, Events>} component\n * @param {{\n * \t\ttarget: Node;\n * \t\tprops?: Props;\n * \t\tevents?: Events;\n *  \tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t\timmutable?: boolean;\n * \t\trecover?: false;\n * \t}} options\n * @returns {[Exports, () => void]}\n */\nexport function mount(component, options) {\n\tinit_operations();\n\tconst registered_events = new Set();\n\tconst container = options.target;\n\tconst block = create_root_block(container, options.intro || false);\n\tconst first_child = /** @type {ChildNode} */ (container.firstChild);\n\tconst hydration_fragment = get_hydration_fragment(first_child);\n\tconst previous_hydration_fragment = current_hydration_fragment;\n\n\t/** @type {Exports} */\n\t// @ts-expect-error will be defined because the render effect runs synchronously\n\tlet accessors = undefined;\n\n\ttry {\n\t\t/** @type {null | Text} */\n\t\tlet anchor = null;\n\t\tif (hydration_fragment === null) {\n\t\t\tanchor = empty();\n\t\t\tcontainer.appendChild(anchor);\n\t\t}\n\t\tset_current_hydration_fragment(hydration_fragment);\n\t\tconst effect = render_effect(\n\t\t\t() => {\n\t\t\t\tif (options.context) {\n\t\t\t\t\tpush({});\n\t\t\t\t\t/** @type {import('../client/types.js').ComponentContext} */ (\n\t\t\t\t\t\tcurrent_component_context\n\t\t\t\t\t).context = options.context;\n\t\t\t\t}\n\t\t\t\t// @ts-expect-error the public typings are not what the actual function looks like\n\t\t\t\taccessors = component(anchor, options.props || {}, options.events || {});\n\t\t\t\tif (options.context) {\n\t\t\t\t\tpop();\n\t\t\t\t}\n\t\t\t},\n\t\t\tblock,\n\t\t\ttrue\n\t\t);\n\t\tblock.effect = effect;\n\t} catch (error) {\n\t\tif (options.recover !== false && hydration_fragment !== null) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.error(\n\t\t\t\t'Hydration failed because the initial UI does not match what was rendered on the server.',\n\t\t\t\terror\n\t\t\t);\n\t\t\tremove(hydration_fragment);\n\t\t\tfirst_child.remove();\n\t\t\thydration_fragment.at(-1)?.nextSibling?.remove();\n\t\t\treturn mount(component, options);\n\t\t} else {\n\t\t\tthrow error;\n\t\t}\n\t} finally {\n\t\tset_current_hydration_fragment(previous_hydration_fragment);\n\t}\n\tconst bound_event_listener = handle_event_propagation.bind(null, container);\n\n\t/** @param {Array<string>} events */\n\tconst event_handle = (events) => {\n\t\tfor (let i = 0; i < events.length; i++) {\n\t\t\tconst event_name = events[i];\n\t\t\tif (!registered_events.has(event_name)) {\n\t\t\t\tregistered_events.add(event_name);\n\t\t\t\tcontainer.addEventListener(\n\t\t\t\t\tevent_name,\n\t\t\t\t\tbound_event_listener,\n\t\t\t\t\tPassiveDelegatedEvents.includes(event_name)\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tpassive: true\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t: undefined\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t};\n\tevent_handle(array_from(all_registerd_events));\n\troot_event_handles.add(event_handle);\n\n\treturn [\n\t\taccessors,\n\t\t() => {\n\t\t\tfor (const event_name of registered_events) {\n\t\t\t\tcontainer.removeEventListener(event_name, bound_event_listener);\n\t\t\t}\n\t\t\troot_event_handles.delete(event_handle);\n\t\t\tconst dom = block.dom;\n\t\t\tif (dom !== null) {\n\t\t\t\tremove(dom);\n\t\t\t}\n\t\t\tif (hydration_fragment !== null) {\n\t\t\t\tremove(hydration_fragment);\n\t\t\t}\n\t\t\tdestroy_signal(/** @type {import('./types.js').EffectSignal} */ (block.effect));\n\t\t}\n\t];\n}\n\n/**\n * @param {Record<string, unknown>} props\n * @returns {void}\n */\nexport function access_props(props) {\n\tfor (const prop in props) {\n\t\t// eslint-disable-next-line no-unused-expressions\n\t\tprops[prop];\n\t}\n}\n\n/**\n * @param {import('./types.js').MaybeSignal<Record<string, any>>} props\n * @returns {Record<string, any>}\n */\nexport function sanitize_slots(props) {\n\tprops = unwrap(props);\n\tconst sanitized = { ...props.$$slots };\n\tif (props.children) sanitized.default = props.children;\n\treturn sanitized;\n}\n\n/**\n * @param {() => void} create_snippet\n * @returns {void}\n */\nexport function snippet_effect(create_snippet) {\n\tconst block = create_snippet_block();\n\trender_effect(() => {\n\t\tcreate_snippet();\n\t\treturn () => {\n\t\t\tif (block.dom !== null) {\n\t\t\t\tremove(block.dom);\n\t\t\t}\n\t\t};\n\t}, block);\n}\n\n/**\n * @param {Node} target\n * @param {string} style_sheet_id\n * @param {string} styles\n */\nexport async function append_styles(target, style_sheet_id, styles) {\n\t// Wait a tick so that the template is added to the dom, else getRootNode() will yield wrong results\n\t// If it turns out that this results in noticeable flickering, we need to do something like doing the\n\t// append outside and adding code in mount that appends all stylesheets (similar to how we do it with event delegation)\n\tawait Promise.resolve();\n\tconst append_styles_to = get_root_for_style(target);\n\tif (!append_styles_to.getElementById(style_sheet_id)) {\n\t\tconst style = create_element('style');\n\t\tstyle.id = style_sheet_id;\n\t\tstyle.textContent = styles;\n\t\tappend_child(/** @type {Document} */ (append_styles_to).head || append_styles_to, style);\n\t}\n}\n\n/**\n * @param {Node} node\n */\nfunction get_root_for_style(node) {\n\tif (!node) return document;\n\tconst root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n\tif (root && /** @type {ShadowRoot} */ (root).host) {\n\t\treturn /** @type {ShadowRoot} */ (root);\n\t}\n\treturn /** @type {Document} */ (node.ownerDocument);\n}\n\n/**\n * @param {string} message\n * @param {string} filename\n * @param {Array<{ line: number; highlight: boolean; source: string }>} [code_highlights]\n * @returns {void}\n */\nexport function compile_error(message, filename, code_highlights) {\n\t// Construct error page\n\tconst page = document.createElement('div');\n\tconst container = document.createElement('div');\n\tconst pre = document.createElement('pre');\n\tconst h1 = document.createElement('h1');\n\tconst h2 = document.createElement('h2');\n\tconst p = document.createElement('p');\n\th1.textContent = 'Compilation Error';\n\th2.textContent = message;\n\tp.textContent = filename;\n\tpre.appendChild(h1);\n\tpre.appendChild(h2);\n\tif (code_highlights) {\n\t\tconst code_container = document.createElement('div');\n\t\tfor (const line of code_highlights) {\n\t\t\tconst code_line = document.createElement('div');\n\t\t\tconst code_line_number = document.createElement('span');\n\t\t\tcode_line_number.textContent = String(line.line);\n\t\t\tconst code_source = document.createElement('span');\n\t\t\tcode_source.textContent = line.source;\n\t\t\tif (line.highlight) {\n\t\t\t\tcode_line.style.cssText = 'padding:8px;background:#333;color:#fff';\n\t\t\t} else {\n\t\t\t\tcode_line.style.cssText = 'padding:8px;background:#000;color:#999';\n\t\t\t}\n\t\t\tcode_line_number.style.cssText = 'color:#888;padding:0 15px 0 5px;text-align:right;';\n\t\t\tcode_line.appendChild(code_line_number);\n\t\t\tcode_line.appendChild(code_source);\n\t\t\tcode_container.appendChild(code_line);\n\t\t}\n\t\tpre.appendChild(code_container);\n\t}\n\th1.style.cssText = 'color:#ff5555;font-weight:normal;margin-top:0;padding:0;font-size:20px;';\n\th2.style.cssText =\n\t\t'color:#ccc;font-weight:normal;margin-top:0;padding:0;font-size:16px;white-space:normal;';\n\tp.style.cssText = 'color: #999;';\n\tpage.style.cssText =\n\t\t'z-index:9999;margin:0;position:fixed;top: 0;left: 0;height:100%;width:100%;background:rgba(0,0,0,0.66)';\n\tcontainer.style.cssText = `background:#181818;margin:30px auto;padding:25px 40px;position:relative;color:#d8d8d8;border-radius:6px 6px 8px 8px;width:800px;font-family:'SF Mono', SFMono-Regular, ui-monospace,'DejaVu Sans Mono', Menlo, Consolas, monospace;;border-top:8px solid #ff5555;`;\n\tpre.appendChild(p);\n\tcontainer.appendChild(pre);\n\tpage.appendChild(container);\n\tdocument.body.appendChild(page);\n\t// eslint-disable-next-line no-console\n\tconsole.error('[Compilation Error] ' + message);\n}\n", "import { subscribe_to_store } from '../../store/utils.js';\nimport { EMPTY_FUNC } from '../common.js';\nimport { unwrap } from './render.js';\nimport { is_array } from './utils.js';\n\nexport const SOURCE = 1;\nexport const DERIVED = 1 << 1;\nexport const EFFECT = 1 << 2;\nexport const PRE_EFFECT = 1 << 3;\nexport const RENDER_EFFECT = 1 << 4;\nexport const SYNC_EFFECT = 1 << 5;\nconst MANAGED = 1 << 6;\nconst UNOWNED = 1 << 7;\nexport const CLEAN = 1 << 8;\nexport const DIRTY = 1 << 9;\nexport const MAYBE_DIRTY = 1 << 10;\nexport const INERT = 1 << 11;\nexport const DESTROYED = 1 << 12;\n\nconst IS_EFFECT = EFFECT | PRE_EFFECT | RENDER_EFFECT | SYNC_EFFECT;\n\nconst FLUSH_MICROTASK = 0;\nconst FLUSH_SYNC = 1;\nconst MAX_SAFE_INT = Number.MAX_SAFE_INTEGER;\n\nexport const UNINITIALIZED = Symbol();\n\n// Used for controlling the flush of effects.\nlet current_scheduler_mode = FLUSH_MICROTASK;\n// Used for handling scheduling\nlet is_micro_task_queued = false;\nlet is_task_queued = false;\n// Used for exposing signals\nlet is_signal_exposed = false;\n// Handle effect queues\n\n/** @type {import('./types.js').EffectSignal[]} */\nlet current_queued_pre_and_render_effects = [];\n\n/** @type {import('./types.js').EffectSignal[]} */\nlet current_queued_effects = [];\n\n/** @type {Array<() => void>} */\nlet current_queued_tasks = [];\nlet flush_count = 0;\n// Handle signal reactivity tree dependencies and consumer\n\n/** @type {null | import('./types.js').ComputationSignal} */\nlet current_consumer = null;\n\n/** @type {null | import('./types.js').EffectSignal} */\nexport let current_effect = null;\n\n/** @type {null | import('./types.js').Signal[]} */\nlet current_dependencies = null;\nlet current_dependencies_index = 0;\n// Handling capturing of signals from object property getters\nlet current_should_capture_signal = false;\n/** If `true`, `get`ting the signal should not register it as a dependency */\nexport let current_untracking = false;\n/** Exists to opt out of the mutation validation for stores which may be set for the first time during a derivation */\nlet ignore_mutation_validation = false;\n\n/** @type {null | import('./types.js').Signal} */\nlet current_captured_signal = null;\n// If we are working with a get() chain that has no active container,\n// to prevent memory leaks, we skip adding the consumer.\nlet current_skip_consumer = false;\n// Handle collecting all signals which are read during a specific time frame\nlet is_signals_recorded = false;\nlet captured_signals = new Set();\n// Handle rendering tree blocks and anchors\n\n/** @type {null | import('./types.js').Block} */\nexport let current_block = null;\n// Handling runtime component context\n\n/** @type {import('./types.js').ComponentContext | null} */\nexport let current_component_context = null;\nexport let is_ssr = false;\n\n/**\n * @param {boolean} ssr\n * @returns {void}\n */\nexport function set_is_ssr(ssr) {\n\tis_ssr = ssr;\n}\n\n/**\n * @param {import('./types.js').MaybeSignal<Record<string, unknown>>} props\n * @returns {import('./types.js').ComponentContext}\n */\nexport function create_component_context(props) {\n\tconst parent = current_component_context;\n\treturn {\n\t\teffects: null,\n\t\tprops,\n\t\tparent,\n\t\taccessors: null,\n\t\tcontext: null,\n\t\timmutable: false,\n\t\tmounted: false,\n\t\trunes: false,\n\t\tupdate_callbacks: null\n\t};\n}\n\n/**\n * @param {null | import('./types.js').ComponentContext} context\n * @returns {boolean}\n */\nfunction is_runes(context) {\n\tconst component_context = context || current_component_context;\n\treturn component_context !== null && component_context.runes;\n}\n\n/**\n * @param {null | import('./types.js').ComponentContext} context_stack_item\n * @returns {void}\n */\nexport function set_current_component_context(context_stack_item) {\n\tcurrent_component_context = context_stack_item;\n}\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nfunction default_equals(a, b) {\n\treturn a === b;\n}\n\n/**\n * @template V\n * @param {import('./types.js').SignalFlags} flags\n * @param {V} value\n * @returns {import('./types.js').SourceSignal<V>}\n */\nfunction create_source_signal(flags, value) {\n\treturn {\n\t\tc: null,\n\t\t// We can remove this if we get rid of beforeUpdate/afterUpdate\n\t\tx: null,\n\t\te: null,\n\t\tf: flags,\n\t\tv: value\n\t};\n}\n\n/**\n * @template V\n * @param {import('./types.js').SignalFlags} flags\n * @param {V} value\n * @param {import('./types.js').Block | null} block\n * @returns {import('./types.js').ComputationSignal<V>}\n */\nfunction create_computation_signal(flags, value, block) {\n\treturn {\n\t\tb: block,\n\t\tc: null,\n\t\tx: null,\n\t\td: null,\n\t\ty: null,\n\t\te: null,\n\t\tf: flags,\n\t\ti: null,\n\t\tr: null,\n\t\tv: value\n\t};\n}\n\n/**\n * @param {import('./types.js').ComputationSignal} target_signal\n * @param {import('./types.js').ComputationSignal} ref_signal\n * @returns {void}\n */\nfunction push_reference(target_signal, ref_signal) {\n\tconst references = target_signal.r;\n\tif (references === null) {\n\t\ttarget_signal.r = [ref_signal];\n\t} else {\n\t\treferences.push(ref_signal);\n\t}\n}\n\n/**\n * @template V\n * @param {import('./types.js').Signal<V>} signal\n * @returns {boolean}\n */\nfunction is_signal_dirty(signal) {\n\tconst flags = signal.f;\n\tif ((flags & DIRTY) !== 0 || signal.v === UNINITIALIZED) {\n\t\treturn true;\n\t}\n\tif ((flags & MAYBE_DIRTY) !== 0) {\n\t\tconst dependencies = /** @type {import('./types.js').ComputationSignal<V>} **/ (signal).d;\n\t\tif (dependencies !== null) {\n\t\t\tconst length = dependencies.length;\n\t\t\tlet i;\n\t\t\tfor (i = 0; i < length; i++) {\n\t\t\t\tconst dependency = dependencies[i];\n\n\t\t\t\tif ((dependency.f & MAYBE_DIRTY) !== 0 && !is_signal_dirty(dependency)) {\n\t\t\t\t\tset_signal_status(dependency, CLEAN);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// The flags can be marked as dirty from the above is_signal_dirty call.\n\t\t\t\tif ((dependency.f & DIRTY) !== 0) {\n\t\t\t\t\tif ((dependency.f & DERIVED) !== 0) {\n\t\t\t\t\t\tupdate_derived(\n\t\t\t\t\t\t\t/** @type {import('./types.js').ComputationSignal<V>} **/ (dependency),\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// Might have been mutated from above get.\n\t\t\t\t\t\tif ((signal.f & DIRTY) !== 0) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * @template V\n * @param {import('./types.js').ComputationSignal<V>} signal\n * @returns {V}\n */\nfunction execute_signal_fn(signal) {\n\tconst init = signal.i;\n\tconst previous_dependencies = current_dependencies;\n\tconst previous_dependencies_index = current_dependencies_index;\n\tconst previous_consumer = current_consumer;\n\tconst previous_block = current_block;\n\tconst previous_component_context = current_component_context;\n\tconst previous_skip_consumer = current_skip_consumer;\n\tconst is_render_effect = (signal.f & RENDER_EFFECT) !== 0;\n\tconst previous_untracking = current_untracking;\n\tcurrent_dependencies = /** @type {null | import('./types.js').Signal[]} */ (null);\n\tcurrent_dependencies_index = 0;\n\tcurrent_consumer = signal;\n\tcurrent_block = signal.b;\n\tcurrent_component_context = signal.x;\n\tcurrent_skip_consumer = current_effect === null && (signal.f & UNOWNED) !== 0;\n\tcurrent_untracking = false;\n\n\t// Render effects are invoked when the UI is about to be updated - run beforeUpdate at that point\n\tif (is_render_effect && current_component_context?.update_callbacks != null) {\n\t\tcurrent_component_context.update_callbacks.execute();\n\t}\n\n\ttry {\n\t\tlet res;\n\t\tif (is_render_effect) {\n\t\t\tres = /** @type {(block: import('./types.js').Block) => V} */ (init)(\n\t\t\t\t/** @type {import('./types.js').Block} */ (signal.b)\n\t\t\t);\n\t\t} else {\n\t\t\tres = /** @type {() => V} */ (init)();\n\t\t}\n\t\tlet dependencies = /** @type {import('./types.js').Signal<unknown>[]} **/ (signal.d);\n\n\t\tif (current_dependencies !== null) {\n\t\t\tlet i;\n\t\t\tremove_consumer(signal, current_dependencies_index, false);\n\n\t\t\tif (dependencies !== null && current_dependencies_index > 0) {\n\t\t\t\tdependencies.length = current_dependencies_index + current_dependencies.length;\n\t\t\t\tfor (i = 0; i < current_dependencies.length; i++) {\n\t\t\t\t\tdependencies[current_dependencies_index + i] = current_dependencies[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsignal.d = /** @type {import('./types.js').Signal<V>[]} **/ (\n\t\t\t\t\tdependencies = current_dependencies\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (!current_skip_consumer) {\n\t\t\t\tfor (i = current_dependencies_index; i < dependencies.length; i++) {\n\t\t\t\t\tconst dependency = dependencies[i];\n\n\t\t\t\t\tif (dependency.c === null) {\n\t\t\t\t\t\tdependency.c = [signal];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdependency.c.push(signal);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (dependencies !== null && current_dependencies_index < dependencies.length) {\n\t\t\tremove_consumer(signal, current_dependencies_index, false);\n\t\t\tdependencies.length = current_dependencies_index;\n\t\t}\n\t\treturn res;\n\t} finally {\n\t\tcurrent_dependencies = previous_dependencies;\n\t\tcurrent_dependencies_index = previous_dependencies_index;\n\t\tcurrent_consumer = previous_consumer;\n\t\tcurrent_block = previous_block;\n\t\tcurrent_component_context = previous_component_context;\n\t\tcurrent_skip_consumer = previous_skip_consumer;\n\t\tcurrent_untracking = previous_untracking;\n\t}\n}\n\n/**\n * @template V\n * @param {import('./types.js').ComputationSignal<V>} signal\n * @param {number} start_index\n * @param {boolean} remove_unowned\n * @returns {void}\n */\nfunction remove_consumer(signal, start_index, remove_unowned) {\n\tconst dependencies = signal.d;\n\tif (dependencies !== null) {\n\t\tlet i;\n\t\tfor (i = start_index; i < dependencies.length; i++) {\n\t\t\tconst dependency = dependencies[i];\n\t\t\tconst consumers = dependency.c;\n\t\t\tlet consumers_length = 0;\n\t\t\tif (consumers !== null) {\n\t\t\t\tconsumers_length = consumers.length - 1;\n\t\t\t\tif (consumers_length === 0) {\n\t\t\t\t\tdependency.c = null;\n\t\t\t\t} else {\n\t\t\t\t\tconst index = consumers.indexOf(signal);\n\t\t\t\t\t// Swap with last element and then remove.\n\t\t\t\t\tconsumers[index] = consumers[consumers_length];\n\t\t\t\t\tconsumers.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (remove_unowned && consumers_length === 0 && (dependency.f & UNOWNED) !== 0) {\n\t\t\t\tremove_consumer(\n\t\t\t\t\t/** @type {import('./types.js').ComputationSignal<V>} **/ (dependency),\n\t\t\t\t\t0,\n\t\t\t\t\ttrue\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @template V\n * @param {import('./types.js').ComputationSignal<V>} signal\n * @returns {void}\n */\nfunction destroy_references(signal) {\n\tconst references = signal.r;\n\tsignal.r = null;\n\tif (references !== null) {\n\t\tlet i;\n\t\tfor (i = 0; i < references.length; i++) {\n\t\t\tconst reference = references[i];\n\t\t\tif ((reference.f & IS_EFFECT) !== 0) {\n\t\t\t\tdestroy_signal(reference);\n\t\t\t} else {\n\t\t\t\tremove_consumer(reference, 0, true);\n\t\t\t\treference.d = null;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./types.js').Block} block\n * @param {unknown} error\n * @returns {void}\n */\nfunction report_error(block, error) {\n\t/** @type {import('./types.js').Block | null} */\n\tlet current_block = block;\n\n\tif (current_block !== null) {\n\t\tthrow error;\n\t}\n}\n\n/**\n * @param {import('./types.js').EffectSignal} signal\n * @returns {void}\n */\nexport function execute_effect(signal) {\n\tif ((signal.f & DESTROYED) !== 0) {\n\t\treturn;\n\t}\n\tconst teardown = signal.v;\n\tconst previous_effect = current_effect;\n\tcurrent_effect = signal;\n\n\ttry {\n\t\tdestroy_references(signal);\n\t\tif (teardown !== null) {\n\t\t\tteardown();\n\t\t}\n\t\tconst possible_teardown = execute_signal_fn(signal);\n\t\tif (typeof possible_teardown === 'function') {\n\t\t\tsignal.v = possible_teardown;\n\t\t}\n\t} catch (error) {\n\t\tconst block = signal.b;\n\t\tif (block !== null) {\n\t\t\treport_error(block, error);\n\t\t} else {\n\t\t\tthrow error;\n\t\t}\n\t} finally {\n\t\tcurrent_effect = previous_effect;\n\t}\n\tconst component_context = signal.x;\n\tif (\n\t\tis_runes(component_context) && // Don't rerun pre effects more than once to accomodate for \"$: only runs once\" behavior\n\t\t(signal.f & PRE_EFFECT) !== 0 &&\n\t\tcurrent_queued_pre_and_render_effects.length > 0\n\t) {\n\t\tflush_local_pre_effects(component_context);\n\t}\n}\n\n/**\n * @param {Array<import('./types.js').EffectSignal>} effects\n * @returns {void}\n */\nfunction flush_queued_effects(effects) {\n\tconst length = effects.length;\n\tif (length > 0) {\n\t\tif (flush_count > 100) {\n\t\t\tthrow new Error(\n\t\t\t\t'Maximum update depth exceeded. This can happen when a reactive block or effect ' +\n\t\t\t\t\t'repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops.'\n\t\t\t);\n\t\t}\n\t\tflush_count++;\n\t\tlet i;\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tconst signal = effects[i];\n\t\t\tconst flags = signal.f;\n\t\t\tif ((flags & (DESTROYED | INERT)) === 0) {\n\t\t\t\tif (is_signal_dirty(signal)) {\n\t\t\t\t\tset_signal_status(signal, CLEAN);\n\t\t\t\t\texecute_effect(signal);\n\t\t\t\t} else if ((flags & MAYBE_DIRTY) !== 0) {\n\t\t\t\t\tset_signal_status(signal, CLEAN);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\teffects.length = 0;\n\t}\n}\n\nfunction process_microtask() {\n\tis_micro_task_queued = false;\n\tif (flush_count > 101) {\n\t\treturn;\n\t}\n\tconst previous_queued_pre_and_render_effects = current_queued_pre_and_render_effects;\n\tconst previous_queued_effects = current_queued_effects;\n\tcurrent_queued_pre_and_render_effects = [];\n\tcurrent_queued_effects = [];\n\tflush_queued_effects(previous_queued_pre_and_render_effects);\n\tflush_queued_effects(previous_queued_effects);\n\tif (!is_micro_task_queued) {\n\t\tflush_count = 0;\n\t}\n}\n\n/**\n * @param {import('./types.js').EffectSignal} signal\n * @param {boolean} sync\n * @returns {void}\n */\nexport function schedule_effect(signal, sync) {\n\tconst flags = signal.f;\n\tif (sync || (flags & SYNC_EFFECT) !== 0) {\n\t\texecute_effect(signal);\n\t\tset_signal_status(signal, CLEAN);\n\t} else {\n\t\tif (current_scheduler_mode === FLUSH_MICROTASK) {\n\t\t\tif (!is_micro_task_queued) {\n\t\t\t\tis_micro_task_queued = true;\n\t\t\t\tqueueMicrotask(process_microtask);\n\t\t\t}\n\t\t}\n\t\tif ((flags & EFFECT) !== 0) {\n\t\t\tcurrent_queued_effects.push(signal);\n\t\t} else {\n\t\t\tcurrent_queued_pre_and_render_effects.push(signal);\n\t\t}\n\t}\n}\n\nfunction process_task() {\n\tis_task_queued = false;\n\tconst tasks = current_queued_tasks.slice();\n\tcurrent_queued_tasks = [];\n\tfor (let i = 0; i < tasks.length; i++) {\n\t\ttasks[i]();\n\t}\n}\n\n/**\n * @param {() => void} fn\n * @returns {void}\n */\nexport function schedule_task(fn) {\n\tif (!is_task_queued) {\n\t\tis_task_queued = true;\n\t\tsetTimeout(process_task, 0);\n\t}\n\tcurrent_queued_tasks.push(fn);\n}\n\n/**\n * @returns {void}\n */\nexport function flush_local_render_effects() {\n\tconst effects = [];\n\tfor (let i = 0; i < current_queued_pre_and_render_effects.length; i++) {\n\t\tconst effect = current_queued_pre_and_render_effects[i];\n\t\tif ((effect.f & RENDER_EFFECT) !== 0 && effect.x === current_component_context) {\n\t\t\teffects.push(effect);\n\t\t\tcurrent_queued_pre_and_render_effects.splice(i, 1);\n\t\t\ti--;\n\t\t}\n\t}\n\tflush_queued_effects(effects);\n}\n\n/**\n * @param {null | import('./types.js').ComponentContext} context\n * @returns {void}\n */\nexport function flush_local_pre_effects(context) {\n\tconst effects = [];\n\tfor (let i = 0; i < current_queued_pre_and_render_effects.length; i++) {\n\t\tconst effect = current_queued_pre_and_render_effects[i];\n\t\tif ((effect.f & PRE_EFFECT) !== 0 && effect.x === context) {\n\t\t\teffects.push(effect);\n\t\t\tcurrent_queued_pre_and_render_effects.splice(i, 1);\n\t\t\ti--;\n\t\t}\n\t}\n\tflush_queued_effects(effects);\n}\n\n/**\n * Synchronously flushes any pending state changes and those that result from it.\n * @param {() => void} [fn]\n * @returns {void}\n */\nexport function flushSync(fn) {\n\tconst previous_scheduler_mode = current_scheduler_mode;\n\tconst previous_queued_pre_and_render_effects = current_queued_pre_and_render_effects;\n\tconst previous_queued_effects = current_queued_effects;\n\ttry {\n\t\t/** @type {import('./types.js').EffectSignal[]} */\n\t\tconst pre_and_render_effects = [];\n\n\t\t/** @type {import('./types.js').EffectSignal[]} */\n\t\tconst effects = [];\n\t\tcurrent_scheduler_mode = FLUSH_SYNC;\n\t\tflush_count = 0;\n\t\tcurrent_queued_pre_and_render_effects = pre_and_render_effects;\n\t\tcurrent_queued_effects = effects;\n\t\tflush_queued_effects(previous_queued_pre_and_render_effects);\n\t\tflush_queued_effects(previous_queued_effects);\n\t\tif (fn !== undefined) {\n\t\t\tfn();\n\t\t}\n\t\tif (current_queued_pre_and_render_effects.length > 0 || effects.length > 0) {\n\t\t\tflushSync();\n\t\t}\n\t\tif (is_task_queued) {\n\t\t\tprocess_task();\n\t\t}\n\t} finally {\n\t\tcurrent_scheduler_mode = previous_scheduler_mode;\n\t\tcurrent_queued_pre_and_render_effects = previous_queued_pre_and_render_effects;\n\t\tcurrent_queued_effects = previous_queued_effects;\n\t}\n}\n\n/**\n * Returns a promise that resolves once any pending state changes have been applied.\n * @returns {Promise<void>}\n */\nexport async function tick() {\n\tawait Promise.resolve();\n\t// By calling flushSync we guarantee that any pending state changes are applied after one tick.\n\t// TODO look into whether we can make flushing subsequent updates synchronously in the future.\n\tflushSync();\n}\n\n/**\n * @template V\n * @param {import('./types.js').ComputationSignal<V>} signal\n * @param {boolean} force_schedule\n * @returns {void}\n */\nfunction update_derived(signal, force_schedule) {\n\tconst value = execute_signal_fn(signal);\n\tconst status =\n\t\tcurrent_skip_consumer || (current_effect === null && (signal.f & UNOWNED) !== 0)\n\t\t\t? DIRTY\n\t\t\t: CLEAN;\n\tset_signal_status(signal, status);\n\tconst equals = /** @type {import('./types.js').EqualsFunctions} */ (signal.e);\n\tif (!equals(value, signal.v)) {\n\t\tsignal.v = value;\n\t\tmark_signal_consumers(signal, DIRTY, force_schedule);\n\t}\n}\n\n/**\n * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy\n * signal that will be updated when the store is. The store references container is needed to\n * track reassignments to stores and to track the correct component context.\n * @template V\n * @param {import('./types.js').Store<V> | null | undefined} store\n * @param {string} store_name\n * @param {import('./types.js').StoreReferencesContainer} stores\n * @returns {V}\n */\nexport function store_get(store, store_name, stores) {\n\t/** @type {import('./types.js').StoreReferencesContainer[''] | undefined} */\n\tlet entry = stores[store_name];\n\tconst is_new = entry === undefined;\n\n\tif (is_new) {\n\t\tentry = {\n\t\t\tstore: null,\n\t\t\tlast_value: null,\n\t\t\tvalue: source(UNINITIALIZED),\n\t\t\tunsubscribe: EMPTY_FUNC\n\t\t};\n\t\t// TODO: can we remove this code? it was refactored out when we split up source/comptued signals\n\t\t// push_destroy_fn(entry.value, () => {\n\t\t// \t/** @type {import('./types.js').StoreReferencesContainer['']} */ (entry).last_value =\n\t\t// \t\t/** @type {import('./types.js').StoreReferencesContainer['']} */ (entry).value.value;\n\t\t// });\n\t\tstores[store_name] = entry;\n\t}\n\n\tif (is_new || entry.store !== store) {\n\t\tentry.unsubscribe();\n\t\tentry.store = store ?? null;\n\t\tentry.unsubscribe = connect_store_to_signal(store, entry.value);\n\t}\n\n\tconst value = get(entry.value);\n\t// This could happen if the store was cleaned up because the component was destroyed and there's a leak on the user side.\n\t// In that case we don't want to fail with a cryptic Symbol error, but rather return the last value we got.\n\treturn value === UNINITIALIZED ? entry.last_value : value;\n}\n\n/**\n * @template V\n * @param {import('./types.js').Store<V> | null | undefined} store\n * @param {import('./types.js').Signal<V>} source\n */\nfunction connect_store_to_signal(store, source) {\n\tif (store == null) {\n\t\tset(source, undefined);\n\t\treturn EMPTY_FUNC;\n\t}\n\n\t/** @param {V} v */\n\tconst run = (v) => {\n\t\tignore_mutation_validation = true;\n\t\tset(source, v);\n\t\tignore_mutation_validation = false;\n\t};\n\treturn subscribe_to_store(store, run);\n}\n\n/**\n * Sets the new value of a store and returns that value.\n * @template V\n * @param {import('./types.js').Store<V>} store\n * @param {V} value\n * @returns {V}\n */\nexport function store_set(store, value) {\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * Unsubscribes from all auto-subscribed stores on destroy\n * @param {import('./types.js').StoreReferencesContainer} stores\n */\nexport function unsubscribe_on_destroy(stores) {\n\tonDestroy(() => {\n\t\tlet store_name;\n\t\tfor (store_name in stores) {\n\t\t\tconst ref = stores[store_name];\n\t\t\tref.unsubscribe();\n\t\t\t// TODO: can we remove this code? it was refactored out when we split up source/comptued signals\n\t\t\t// destroy_signal(ref.value);\n\t\t}\n\t});\n}\n\n/**\n * Wraps a function and marks execution context so that the last signal read from can be captured\n * using the `expose` function.\n * @template V\n * @param {() => V} fn\n * @returns {V}\n */\nexport function exposable(fn) {\n\tconst previous_is_signal_exposed = is_signal_exposed;\n\ttry {\n\t\tis_signal_exposed = true;\n\t\treturn fn();\n\t} finally {\n\t\tis_signal_exposed = previous_is_signal_exposed;\n\t}\n}\n\n/**\n * @template V\n * @param {import('./types.js').Signal<V>} signal\n * @returns {V}\n */\nexport function get(signal) {\n\tconst flags = signal.f;\n\tif ((flags & DESTROYED) !== 0) {\n\t\treturn signal.v;\n\t}\n\n\tif (is_signal_exposed && current_should_capture_signal) {\n\t\tcurrent_captured_signal = signal;\n\t}\n\n\tif (is_signals_recorded) {\n\t\tcaptured_signals.add(signal);\n\t}\n\n\t// Register the dependency on the current consumer signal.\n\tif (current_consumer !== null && (current_consumer.f & MANAGED) === 0 && !current_untracking) {\n\t\tconst unowned = (current_consumer.f & UNOWNED) !== 0;\n\t\tconst dependencies = current_consumer.d;\n\t\tif (\n\t\t\tcurrent_dependencies === null &&\n\t\t\tdependencies !== null &&\n\t\t\tdependencies[current_dependencies_index] === signal &&\n\t\t\t!(unowned && current_effect !== null)\n\t\t) {\n\t\t\tcurrent_dependencies_index++;\n\t\t} else if (current_dependencies === null) {\n\t\t\tcurrent_dependencies = [signal];\n\t\t} else if (signal !== current_dependencies[current_dependencies.length - 1]) {\n\t\t\tcurrent_dependencies.push(signal);\n\t\t}\n\t}\n\n\tif ((flags & DERIVED) !== 0 && is_signal_dirty(signal)) {\n\t\tupdate_derived(/** @type {import('./types.js').ComputationSignal<V>} **/ (signal), false);\n\t}\n\treturn signal.v;\n}\n\n/**\n * @template V\n * @param {import('./types.js').Signal<V>} signal\n * @param {V} value\n * @returns {V}\n */\nexport function set(signal, value) {\n\tset_signal_value(signal, value);\n\treturn value;\n}\n\n/**\n * @template V\n * @param {import('./types.js').Signal<V>} signal\n * @param {V} value\n * @returns {void}\n */\nexport function set_sync(signal, value) {\n\tflushSync(() => set_signal_value(signal, value));\n}\n\n/**\n * Invokes a function and captures the last signal that is read during the invocation\n * if that signal is read within the `exposable` function context.\n * If a signal is captured, it returns the signal instead of the read value.\n * @template V\n * @param {() => V} possible_signal_fn\n * @returns {any}\n */\nexport function expose(possible_signal_fn) {\n\tconst previous_captured_signal = current_captured_signal;\n\tconst previous_should_capture_signal = current_should_capture_signal;\n\tcurrent_captured_signal = null;\n\tcurrent_should_capture_signal = true;\n\ttry {\n\t\tconst value = possible_signal_fn();\n\t\tif (current_captured_signal === null) {\n\t\t\treturn value;\n\t\t}\n\t\treturn current_captured_signal;\n\t} finally {\n\t\tcurrent_captured_signal = previous_captured_signal;\n\t\tcurrent_should_capture_signal = previous_should_capture_signal;\n\t}\n}\n\n/**\n * Invokes a function and captures all signals that are read during the invocation,\n * then invalidates them.\n * @param {() => any} fn\n * @returns {Set<import('./types.js').Signal>}\n */\nexport function invalidate_inner_signals(fn) {\n\tconst previous_is_signals_recorded = is_signals_recorded;\n\tconst previous_captured_signals = captured_signals;\n\tis_signals_recorded = true;\n\tcaptured_signals = new Set();\n\ttry {\n\t\tuntrack(fn);\n\t} finally {\n\t\tis_signals_recorded = previous_is_signals_recorded;\n\t\tlet signal;\n\t\tfor (signal of captured_signals) {\n\t\t\tprevious_captured_signals.add(signal);\n\t\t}\n\t\tcaptured_signals = previous_captured_signals;\n\t}\n\tlet signal;\n\tfor (signal of captured_signals) {\n\t\tmutate(signal, null /* doesnt matter */);\n\t}\n\treturn captured_signals;\n}\n\n/**\n * @template V\n * @param {import('./types.js').Signal<V>} source\n * @param {V} value\n */\nexport function mutate(source, value) {\n\tset_signal_value(\n\t\tsource,\n\t\tuntrack(() => get(source))\n\t);\n\treturn value;\n}\n\n/**\n * Updates a store with a new value.\n * @param {import('./types.js').Store<V>} store  the store to update\n * @param {any} expression  the expression that mutates the store\n * @param {V} new_value  the new store value\n * @template V\n */\nexport function mutate_store(store, expression, new_value) {\n\tstore.set(new_value);\n\treturn expression;\n}\n\n/**\n * @param {import('./types.js').ComputationSignal} signal\n * @param {boolean} inert\n * @returns {void}\n */\nexport function mark_subtree_inert(signal, inert) {\n\tconst flags = signal.f;\n\tconst is_already_inert = (flags & INERT) !== 0;\n\tif (is_already_inert !== inert) {\n\t\tsignal.f ^= INERT;\n\t\tif (!inert && (flags & IS_EFFECT) !== 0 && (flags & CLEAN) === 0) {\n\t\t\tschedule_effect(/** @type {import('./types.js').EffectSignal} */ (signal), false);\n\t\t}\n\t}\n\tconst references = signal.r;\n\tif (references !== null) {\n\t\tlet i;\n\t\tfor (i = 0; i < references.length; i++) {\n\t\t\tmark_subtree_inert(references[i], inert);\n\t\t}\n\t}\n}\n\n/**\n * @template V\n * @param {import('./types.js').Signal<V>} signal\n * @param {number} to_status\n * @param {boolean} force_schedule\n * @returns {void}\n */\nfunction mark_signal_consumers(signal, to_status, force_schedule) {\n\tconst runes = is_runes(signal.x);\n\tconst consumers = signal.c;\n\tif (consumers !== null) {\n\t\tconst length = consumers.length;\n\t\tlet i;\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tconst consumer = consumers[i];\n\t\t\tconst flags = consumer.f;\n\t\t\tconst unowned = (flags & UNOWNED) !== 0;\n\t\t\tconst dirty = (flags & DIRTY) !== 0;\n\t\t\t// We skip any effects that are already dirty (but not unowned). Additionally, we also\n\t\t\t// skip if the consumer is the same as the current effect (except if we're not in runes or we\n\t\t\t// are in force schedule mode).\n\t\t\tif ((dirty && !unowned) || ((!force_schedule || !runes) && consumer === current_effect)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tset_signal_status(consumer, to_status);\n\t\t\t// If the signal is not clean, then skip over it  with the exception of unowned signals that\n\t\t\t// are already dirty. Unowned signals might be dirty because they are not captured as part of an\n\t\t\t// effect.\n\t\t\tif ((flags & CLEAN) !== 0 || (dirty && unowned)) {\n\t\t\t\tif ((consumer.f & IS_EFFECT) !== 0) {\n\t\t\t\t\tschedule_effect(/** @type {import('./types.js').EffectSignal} */ (consumer), false);\n\t\t\t\t} else {\n\t\t\t\t\tmark_signal_consumers(consumer, MAYBE_DIRTY, force_schedule);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @template V\n * @param {import('./types.js').Signal<V>} signal\n * @param {V} value\n * @returns {void}\n */\nexport function set_signal_value(signal, value) {\n\tif (\n\t\t!current_untracking &&\n\t\t!ignore_mutation_validation &&\n\t\tcurrent_consumer !== null &&\n\t\tis_runes(signal.x) &&\n\t\t(current_consumer.f & DERIVED) !== 0\n\t) {\n\t\tthrow new Error(\n\t\t\t\"Unsafe mutations during Svelte's render or derived phase are not permitted in runes mode. \" +\n\t\t\t\t'This can lead to unexpected errors and possibly cause infinite loops.\\n\\nIf this mutation is not meant ' +\n\t\t\t\t'to be reactive do not use the \"$state\" rune for that declaration.'\n\t\t);\n\t}\n\tif (\n\t\t(signal.f & SOURCE) !== 0 &&\n\t\t!(/** @type {import('./types.js').EqualsFunctions} */ (signal.e)(value, signal.v))\n\t) {\n\t\tconst component_context = signal.x;\n\t\tsignal.v = value;\n\t\t// If the current signal is running for the first time, it won't have any\n\t\t// consumers as we only allocate and assign the consumers after the signal\n\t\t// has fully executed. So in the case of ensuring it registers the consumer\n\t\t// properly for itself, we need to ensure the current effect actually gets\n\t\t// scheduled. i.e:\n\t\t//\n\t\t// $effect(() => x++)\n\t\t//\n\t\tif (\n\t\t\tis_runes(component_context) &&\n\t\t\tcurrent_effect !== null &&\n\t\t\tcurrent_effect.c === null &&\n\t\t\t(current_effect.f & CLEAN) !== 0 &&\n\t\t\tcurrent_dependencies !== null &&\n\t\t\tcurrent_dependencies.includes(signal)\n\t\t) {\n\t\t\tset_signal_status(current_effect, DIRTY);\n\t\t\tschedule_effect(current_effect, false);\n\t\t}\n\t\tmark_signal_consumers(signal, DIRTY, true);\n\t\t// If we have afterUpdates locally on the component, but we're within a render effect\n\t\t// then we will need to manually invoke the beforeUpdate/afterUpdate logic.\n\t\t// TODO: should we put this being a is_runes check and only run it in non-runes mode?\n\t\tif (current_effect === null && current_queued_pre_and_render_effects.length === 0) {\n\t\t\tconst update_callbacks = component_context?.update_callbacks;\n\t\t\tif (update_callbacks != null) {\n\t\t\t\tupdate_callbacks.before.forEach(/** @param {any} c */ (c) => c());\n\t\t\t\tconst managed = managed_effect(() => {\n\t\t\t\t\tdestroy_signal(managed);\n\t\t\t\t\tupdate_callbacks.after.forEach(/** @param {any} c */ (c) => c());\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @template V\n * @param {import('./types.js').ComputationSignal<V>} signal\n * @returns {void}\n */\nexport function destroy_signal(signal) {\n\tconst teardown = /** @type {null | (() => void)} */ (signal.v);\n\tconst destroy = signal.y;\n\tconst flags = signal.f;\n\tdestroy_references(signal);\n\tremove_consumer(signal, 0, true);\n\tsignal.i = null;\n\tsignal.r = null;\n\tsignal.y = null;\n\tsignal.x = null;\n\tsignal.b = null;\n\tsignal.v = /** @type {V} */ (null);\n\tsignal.d = null;\n\tsignal.c = null;\n\tset_signal_status(signal, DESTROYED);\n\tif (destroy !== null) {\n\t\tif (is_array(destroy)) {\n\t\t\tlet i;\n\t\t\tfor (i = 0; i < destroy.length; i++) {\n\t\t\t\tdestroy[i]();\n\t\t\t}\n\t\t} else {\n\t\t\tdestroy();\n\t\t}\n\t}\n\tif (teardown !== null && (flags & IS_EFFECT) !== 0) {\n\t\tteardown();\n\t}\n}\n\n/**\n * @template V\n * @param {() => V} init\n * @param {import('./types.js').EqualsFunctions} [equals]\n * @returns {import('./types.js').ComputationSignal<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function derived(init, equals) {\n\tconst is_unowned = current_effect === null;\n\tconst flags = is_unowned ? DERIVED | UNOWNED : DERIVED;\n\tconst signal = /** @type {import('./types.js').ComputationSignal<V>} */ (\n\t\tcreate_computation_signal(flags | CLEAN, UNINITIALIZED, current_block)\n\t);\n\tsignal.i = init;\n\tsignal.x = current_component_context;\n\tsignal.e = get_equals_method(equals);\n\tif (!is_unowned) {\n\t\tpush_reference(/** @type {import('./types.js').EffectSignal} */ (current_effect), signal);\n\t}\n\treturn signal;\n}\n\n/**\n * @template V\n * @param {V} initial_value\n * @param {import('./types.js').EqualsFunctions<V>} [equals]\n * @returns {import('./types.js').SourceSignal<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function source(initial_value, equals) {\n\tconst source = create_source_signal(SOURCE | CLEAN, initial_value);\n\tsource.x = current_component_context;\n\tsource.e = get_equals_method(equals);\n\treturn source;\n}\n\n/**\n * @param {import('./types.js').EqualsFunctions} [equals]\n * @returns {import('./types.js').EqualsFunctions}\n */\nfunction get_equals_method(equals) {\n\tif (equals !== undefined) {\n\t\treturn equals;\n\t}\n\tconst context = current_component_context;\n\tif (context && !context.immutable) {\n\t\treturn safe_equal;\n\t}\n\treturn default_equals;\n}\n\n/**\n * Use `untrack` to prevent something from being treated as an `$effect`/`$derived` dependency.\n *\n * https://svelte-5-preview.vercel.app/docs/functions#untrack\n * @template T\n * @param {() => T} fn\n * @returns {T}\n */\nexport function untrack(fn) {\n\tconst previous_untracking = current_untracking;\n\ttry {\n\t\tcurrent_untracking = true;\n\t\treturn fn();\n\t} finally {\n\t\tcurrent_untracking = previous_untracking;\n\t}\n}\n\n/**\n * @param {import('./types.js').EffectType} type\n * @param {(() => void | (() => void)) | ((b: import('./types.js').Block) => void | (() => void))} init\n * @param {boolean} sync\n * @param {null | import('./types.js').Block} block\n * @param {boolean} schedule\n * @returns {import('./types.js').EffectSignal}\n */\nfunction internal_create_effect(type, init, sync, block, schedule) {\n\tconst signal = create_computation_signal(type | DIRTY, null, block);\n\tsignal.i = init;\n\tsignal.x = current_component_context;\n\tif (schedule) {\n\t\tschedule_effect(signal, sync);\n\t}\n\tif (current_effect !== null && (type & MANAGED) === 0) {\n\t\tpush_reference(current_effect, signal);\n\t}\n\treturn signal;\n}\n\n/**\n * @param {() => void | (() => void)} init\n * @returns {import('./types.js').EffectSignal}\n */\nexport function user_effect(init) {\n\tif (current_effect === null) {\n\t\tthrow new Error('The Svelte $effect rune can only be used during component initialisation.');\n\t}\n\tconst apply_component_effect_heuristics =\n\t\tcurrent_effect.f & RENDER_EFFECT &&\n\t\tcurrent_component_context !== null &&\n\t\t!current_component_context.mounted;\n\tconst effect = internal_create_effect(\n\t\tEFFECT,\n\t\tinit,\n\t\tfalse,\n\t\tcurrent_block,\n\t\t!apply_component_effect_heuristics\n\t);\n\tif (apply_component_effect_heuristics) {\n\t\tlet effects = /** @type {import('./types.js').ComponentContext} */ (current_component_context)\n\t\t\t.effects;\n\t\tif (effects === null) {\n\t\t\teffects = /** @type {import('./types.js').ComponentContext} */ (\n\t\t\t\tcurrent_component_context\n\t\t\t).effects = [];\n\t\t}\n\t\teffects.push(effect);\n\t}\n\treturn effect;\n}\n\n/**\n * @param {() => void | (() => void)} init\n * @returns {import('./types.js').EffectSignal}\n */\nexport function effect(init) {\n\treturn internal_create_effect(EFFECT, init, false, current_block, true);\n}\n\n/**\n * @param {() => void | (() => void)} init\n * @returns {import('./types.js').EffectSignal}\n */\nexport function managed_effect(init) {\n\treturn internal_create_effect(EFFECT | MANAGED, init, false, current_block, true);\n}\n\n/**\n * @param {() => void | (() => void)} init\n * @param {boolean} sync\n * @returns {import('./types.js').EffectSignal}\n */\nexport function managed_pre_effect(init, sync) {\n\treturn internal_create_effect(PRE_EFFECT | MANAGED, init, sync, current_block, true);\n}\n\n/**\n * @param {() => void | (() => void)} init\n * @returns {import('./types.js').EffectSignal}\n */\nexport function pre_effect(init) {\n\tif (current_effect === null) {\n\t\tthrow new Error(\n\t\t\t'The Svelte $effect.pre rune can only be used during component initialisation.'\n\t\t);\n\t}\n\tconst sync = current_effect !== null && (current_effect.f & RENDER_EFFECT) !== 0;\n\treturn internal_create_effect(\n\t\tPRE_EFFECT,\n\t\t() => {\n\t\t\tconst val = init();\n\t\t\tflush_local_render_effects();\n\t\t\treturn val;\n\t\t},\n\t\tsync,\n\t\tcurrent_block,\n\t\ttrue\n\t);\n}\n\n/**\n * @param {() => void | (() => void)} init\n * @returns {import('./types.js').EffectSignal}\n */\nfunction sync_effect(init) {\n\treturn internal_create_effect(SYNC_EFFECT, init, true, current_block, true);\n}\n\n/**\n * @template {import('./types.js').Block} B\n * @param {(block: B) => void | (() => void)} init\n * @param {any} block\n * @param {any} managed\n * @param {any} sync\n * @returns {import('./types.js').EffectSignal}\n */\nexport function render_effect(init, block = current_block, managed = false, sync = true) {\n\tlet flags = RENDER_EFFECT;\n\tif (managed) {\n\t\tflags |= MANAGED;\n\t}\n\treturn internal_create_effect(flags, /** @type {any} */ (init), sync, block, true);\n}\n\n/**\n * @template {import('./types.js').Block} B\n * @param {(block: B) => void | (() => void)} init\n * @param {any} block\n * @param {any} sync\n * @returns {import('./types.js').EffectSignal}\n */\nexport function managed_render_effect(init, block = current_block, sync = true) {\n\tconst flags = RENDER_EFFECT | MANAGED;\n\treturn internal_create_effect(flags, /** @type {any} */ (init), sync, block, true);\n}\n\n/**\n * @template V\n * @param {import('./types.js').ComputationSignal<V>} signal\n * @param {() => void} destroy_fn\n * @returns {void}\n */\nexport function push_destroy_fn(signal, destroy_fn) {\n\tlet destroy = signal.y;\n\tif (destroy === null) {\n\t\tsignal.y = destroy_fn;\n\t} else if (is_array(destroy)) {\n\t\tdestroy.push(destroy_fn);\n\t} else {\n\t\tsignal.y = [destroy, destroy_fn];\n\t}\n}\n\n/**\n * @template V\n * @param {import('./types.js').Signal<V>} signal\n * @param {number} status\n * @returns {void}\n */\nexport function set_signal_status(signal, status) {\n\tconst flags = signal.f;\n\tif ((flags & status) === 0) {\n\t\tif ((flags & MAYBE_DIRTY) !== 0) {\n\t\t\tsignal.f ^= MAYBE_DIRTY;\n\t\t} else if ((flags & CLEAN) !== 0) {\n\t\t\tsignal.f ^= CLEAN;\n\t\t} else if ((flags & DIRTY) !== 0) {\n\t\t\tsignal.f ^= DIRTY;\n\t\t}\n\t\tsignal.f ^= status;\n\t}\n}\n\n/**\n * @template V\n * @param {V | import('./types.js').Signal<V>} val\n * @returns {val is import('./types.js').Signal<V>}\n */\nexport function is_signal(val) {\n\treturn (\n\t\ttypeof val === 'object' &&\n\t\tval !== null &&\n\t\ttypeof (/** @type {import('./types.js').Signal<V>} */ (val).f) === 'number'\n\t);\n}\n\n/**\n * @template V\n * @param {unknown} val\n * @returns {val is import('./types.js').Store<V>}\n */\nexport function is_store(val) {\n\treturn (\n\t\ttypeof val === 'object' &&\n\t\tval !== null &&\n\t\ttypeof (/** @type {import('./types.js').Store<V>} */ (val).subscribe) === 'function'\n\t);\n}\n\n/**\n * This function is responsible for synchronizing a possibly bound prop with the inner component state.\n * It is used whenever the compiler sees that the component writes to the prop.\n *\n * - If the parent passes down a prop without binding, like `<Component prop={value} />`, then create a signal\n *   that updates whenever the value is updated from the parent or from within the component itself\n * - If the parent passes down a prop with a binding, like `<Component bind:prop={value} />`, then\n *   - if the thing that is passed along is the original signal (not a property on it), and the equality functions\n *\t are equal, then just use that signal, no need to create an intermediate one\n *   - otherwise create a signal that updates whenever the value is updated from the parent, and when it's updated\n *\t from within the component itself, call the setter of the parent which will propagate the value change back\n * @template V\n * @param {import('./types.js').MaybeSignal<Record<string, unknown>>} props_obj\n * @param {string} key\n * @param {V | (() => V)} [default_value]\n * @param {boolean} [call_default_value]\n * @returns {import('./types.js').Signal<V> | (() => V)}\n */\nexport function prop_source(props_obj, key, default_value, call_default_value) {\n\tconst props = is_signal(props_obj) ? get(props_obj) : props_obj;\n\tconst possible_signal = /** @type {import('./types.js').MaybeSignal<V>} */ (\n\t\texpose(() => props[key])\n\t);\n\tconst update_bound_prop = Object.getOwnPropertyDescriptor(props, key)?.set;\n\tlet value = props[key];\n\tconst should_set_default_value = value === undefined && default_value !== undefined;\n\n\tif (\n\t\tis_signal(possible_signal) &&\n\t\tpossible_signal.v === value &&\n\t\tupdate_bound_prop === undefined &&\n\t\tget_equals_method() === possible_signal.e\n\t) {\n\t\tif (should_set_default_value) {\n\t\t\tset(\n\t\t\t\tpossible_signal,\n\t\t\t\t// @ts-expect-error would need a cumbersome method overload to type this\n\t\t\t\tcall_default_value ? default_value() : default_value\n\t\t\t);\n\t\t}\n\t\treturn possible_signal;\n\t}\n\n\tif (should_set_default_value) {\n\t\tvalue =\n\t\t\t// @ts-expect-error would need a cumbersome method overload to type this\n\t\t\tcall_default_value ? default_value() : default_value;\n\t}\n\n\tconst source_signal = source(value);\n\n\t// Synchronize prop changes with source signal.\n\t// Needs special equality checking because the prop in the\n\t// parent could be changed through `foo.bar = 'new value'`.\n\tconst immutable = /** @type {import('./types.js').ComponentContext} */ (current_component_context)\n\t\t.immutable;\n\tlet ignore_next1 = false;\n\tlet ignore_next2 = false;\n\n\tlet mount = true;\n\tsync_effect(() => {\n\t\tconst props = is_signal(props_obj) ? get(props_obj) : props_obj;\n\t\t// Before if to ensure signal dependency is registered\n\t\tconst propagating_value = props[key];\n\t\tif (mount) {\n\t\t\tmount = false;\n\t\t\treturn;\n\t\t}\n\t\tif (ignore_next1) {\n\t\t\tignore_next1 = false;\n\t\t\treturn;\n\t\t}\n\n\t\tif (not_equal(immutable, propagating_value, source_signal.v)) {\n\t\t\tignore_next2 = true;\n\t\t\t// TODO figure out why we need it this way and the explain in a comment;\n\t\t\t// some tests fail is we just do set_signal_value(source_signal, propagating_value)\n\t\t\tuntrack(() => set_signal_value(source_signal, propagating_value));\n\t\t}\n\t});\n\n\tif (is_signal(possible_signal) && update_bound_prop !== undefined) {\n\t\tlet ignore_first = !should_set_default_value;\n\t\tsync_effect(() => {\n\t\t\t// Before if to ensure signal dependency is registered\n\t\t\tconst propagating_value = get(source_signal);\n\t\t\tif (ignore_first) {\n\t\t\t\tignore_first = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (ignore_next2) {\n\t\t\t\tignore_next2 = false;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (not_equal(immutable, propagating_value, possible_signal.v)) {\n\t\t\t\tignore_next1 = true;\n\t\t\t\tuntrack(() => update_bound_prop(propagating_value));\n\t\t\t}\n\t\t});\n\t}\n\n\treturn /** @type {import('./types.js').Signal<V>} */ (source_signal);\n}\n\n/**\n * If the prop is readonly and has no fallback value, we can use this function, else we need to use `prop_source`.\n * @template V\n * @param {import('./types.js').MaybeSignal<Record<string, unknown>>} props_obj\n * @param {string} key\n * @returns {any}\n */\nexport function prop(props_obj, key) {\n\treturn () => {\n\t\tconst props = is_signal(props_obj) ? get(props_obj) : props_obj;\n\t\treturn /** @type {V} */ (props[key]);\n\t};\n}\n\n/**\n * @param {boolean} immutable\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nfunction not_equal(immutable, a, b) {\n\treturn immutable ? immutable_not_equal(a, b) : safe_not_equal(a, b);\n}\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nfunction immutable_not_equal(a, b) {\n\t// eslint-disable-next-line eqeqeq\n\treturn a != a ? b == b : a !== b;\n}\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nexport function safe_not_equal(a, b) {\n\t// eslint-disable-next-line eqeqeq\n\treturn a != a\n\t\t? // eslint-disable-next-line eqeqeq\n\t\t  b == b\n\t\t: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';\n}\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nexport function safe_equal(a, b) {\n\treturn !safe_not_equal(a, b);\n}\n\n/** @returns {Map<unknown, unknown>} */\nexport function get_or_init_context_map() {\n\tconst component_context = current_component_context;\n\tif (component_context === null) {\n\t\tthrow new Error('Context can only be used during component initialisation.');\n\t}\n\tlet context_map = component_context.context;\n\tif (context_map === null) {\n\t\tconst parent_context = get_parent_context(component_context);\n\t\tcontext_map = component_context.context = new Map(parent_context || undefined);\n\t}\n\treturn context_map;\n}\n\n/**\n * @param {import('./types.js').ComponentContext} component_context\n * @returns {Map<unknown, unknown> | null}\n */\nfunction get_parent_context(component_context) {\n\tlet parent = component_context.parent;\n\twhile (parent !== null) {\n\t\tconst context_map = parent.context;\n\t\tif (context_map !== null) {\n\t\t\treturn context_map;\n\t\t}\n\t\tparent = parent.parent;\n\t}\n\treturn null;\n}\n\n/**\n * @this {any}\n * @param {import('./types.js').MaybeSignal<Record<string, unknown>>} $$props\n * @param {Event} event\n * @returns {void}\n */\nexport function bubble_event($$props, event) {\n\tconst events = /** @type {Record<string, Function[] | Function>} */ (unwrap($$props).$$events)?.[\n\t\tevent.type\n\t];\n\tconst callbacks = is_array(events) ? events.slice() : [events];\n\tlet fn;\n\tfor (fn of callbacks) {\n\t\t// Preserve \"this\" context\n\t\tif (is_signal(fn)) {\n\t\t\tget(fn).call(this, event);\n\t\t} else {\n\t\t\tfn.call(this, event);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./types.js').Signal<number>} signal\n * @returns {number}\n */\nexport function increment(signal) {\n\tconst value = get(signal);\n\tset_signal_value(signal, value + 1);\n\treturn value;\n}\n\n/**\n * @param {import('./types.js').Store<number>} store\n * @param {number} store_value\n * @returns {number}\n */\nexport function increment_store(store, store_value) {\n\tstore.set(store_value + 1);\n\treturn store_value;\n}\n\n/**\n * @param {import('./types.js').Signal<number>} signal\n * @returns {number}\n */\nexport function decrement(signal) {\n\tconst value = get(signal);\n\tset_signal_value(signal, value - 1);\n\treturn value;\n}\n\n/**\n * @param {import('./types.js').Store<number>} store\n * @param {number} store_value\n * @returns {number}\n */\nexport function decrement_store(store, store_value) {\n\tstore.set(store_value - 1);\n\treturn store_value;\n}\n\n/**\n * @param {import('./types.js').Signal<number>} signal\n * @returns {number}\n */\nexport function increment_pre(signal) {\n\tconst value = get(signal) + 1;\n\tset_signal_value(signal, value);\n\treturn value;\n}\n\n/**\n * @param {import('./types.js').Store<number>} store\n * @param {number} store_value\n * @returns {number}\n */\nexport function increment_pre_store(store, store_value) {\n\tconst value = store_value + 1;\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * @param {import('./types.js').Signal<number>} signal\n * @returns {number}\n */\nexport function decrement_pre(signal) {\n\tconst value = get(signal) - 1;\n\tset_signal_value(signal, value);\n\treturn value;\n}\n\n/**\n * @param {import('./types.js').Store<number>} store\n * @param {number} store_value\n * @returns {number}\n */\nexport function decrement_pre_store(store, store_value) {\n\tconst value = store_value - 1;\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * Under some circumstances, imports may be reactive in legacy mode. In that case,\n * they should be using `reactive_import` as part of the transformation\n * @param {() => any} fn\n */\nexport function reactive_import(fn) {\n\tconst s = source(0);\n\treturn function () {\n\t\tif (arguments.length === 1) {\n\t\t\tset(s, get(s) + 1);\n\t\t\treturn arguments[0];\n\t\t} else {\n\t\t\tget(s);\n\t\t\treturn fn();\n\t\t}\n\t};\n}\n\n/**\n * @param {Record<string, unknown>} obj\n * @param {string[]} keys\n * @returns {Record<string, unknown>}\n */\nexport function exclude_from_object(obj, keys) {\n\tobj = { ...obj };\n\tlet key;\n\tfor (key of keys) {\n\t\tdelete obj[key];\n\t}\n\treturn obj;\n}\n\n/**\n * @template V\n * @param {V} value\n * @param {V} fallback\n * @returns {V}\n */\nexport function value_or_fallback(value, fallback) {\n\treturn value === undefined ? fallback : value;\n}\n\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs/svelte#ondestroy\n * @param {() => any} fn\n * @returns {void}\n */\nexport function onDestroy(fn) {\n\tif (!is_ssr) {\n\t\tuser_effect(() => () => untrack(fn));\n\t}\n}\n\n/**\n * @param {import('./types.js').MaybeSignal<Record<string, unknown>>} props\n * @param {any} runes\n * @param {any} immutable\n * @returns {void}\n */\nexport function push(props, runes = false, immutable = false) {\n\tconst context_stack_item = create_component_context(props);\n\tcontext_stack_item.runes = runes;\n\tcontext_stack_item.immutable = immutable;\n\tcurrent_component_context = context_stack_item;\n}\n\n/**\n * @param {Record<string, any>} [accessors]\n * @returns {void}\n */\nexport function pop(accessors) {\n\tconst context_stack_item = current_component_context;\n\tif (context_stack_item !== null) {\n\t\tif (accessors !== undefined) {\n\t\t\tcontext_stack_item.accessors = accessors;\n\t\t}\n\t\tconst effects = context_stack_item.effects;\n\t\tif (effects !== null) {\n\t\t\tcontext_stack_item.effects = null;\n\t\t\tfor (let i = 0; i < effects.length; i++) {\n\t\t\t\tschedule_effect(effects[i], false);\n\t\t\t}\n\t\t}\n\t\tcurrent_component_context = context_stack_item.parent;\n\t\tcontext_stack_item.mounted = true;\n\t}\n}\n", "import { is_array } from './utils.js';\n\n/** regex of all html void element names */\nconst void_element_names =\n\t/^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;\n\n/** @param {string} tag */\nfunction is_void(tag) {\n\treturn void_element_names.test(tag) || tag.toLowerCase() === '!doctype';\n}\n\n/**\n * @param {any} store\n * @param {string} name\n */\nexport function validate_store(store, name) {\n\tif (store != null && typeof store.subscribe !== 'function') {\n\t\tthrow new Error(`'${name}' is not a store with a 'subscribe' method`);\n\t}\n}\n\n/**\n * @param {() => any} component_fn\n * @returns {any}\n */\nexport function validate_dynamic_component(component_fn) {\n\tconst error_message = 'this={...} of <svelte:component> should specify a Svelte component.';\n\ttry {\n\t\tconst instance = component_fn();\n\t\tif (instance !== undefined && typeof instance !== 'object') {\n\t\t\tthrow new Error(error_message);\n\t\t}\n\t\treturn instance;\n\t} catch (err) {\n\t\tconst { message } = /** @type {Error} */ (err);\n\t\tif (typeof message === 'string' && message.indexOf('is not a function') !== -1) {\n\t\t\tthrow new Error(error_message);\n\t\t} else {\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\n/**\n * @param {() => string} tag_fn\n * @returns {void}\n */\nexport function validate_void_dynamic_element(tag_fn) {\n\tconst tag = tag_fn();\n\tif (tag && is_void(tag)) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.warn(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n\t}\n}\n\n/** @param {() => unknown} tag_fn */\nexport function validate_dynamic_element_tag(tag_fn) {\n\tconst tag = tag_fn();\n\tconst is_string = typeof tag === 'string';\n\tif (tag && !is_string) {\n\t\tthrow new Error('<svelte:element> expects \"this\" attribute to be a string.');\n\t}\n}\n\n/**\n * @param {() => any} collection\n * @param {(item: any) => string} key_fn\n * @returns {void}\n */\nexport function validate_each_keys(collection, key_fn) {\n\tconst keys = new Map();\n\tconst maybe_array = collection();\n\tconst array = is_array(maybe_array)\n\t\t? maybe_array\n\t\t: maybe_array == null\n\t\t? []\n\t\t: Array.from(maybe_array);\n\tconst length = array.length;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst key = key_fn(array[i]);\n\t\tif (keys.has(key)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(\n\t\t\t\t\tkey\n\t\t\t\t)} and ${i} with value '${array[i]}' are duplicates`\n\t\t\t);\n\t\t}\n\t\tkeys.set(key, i);\n\t}\n}\n\n/**\n * @param {number} timeout\n * @returns {() => void}\n * */\nexport function loop_guard(timeout) {\n\tconst start = Date.now();\n\treturn () => {\n\t\tif (Date.now() - start > timeout) {\n\t\t\tthrow new Error('Infinite loop detected');\n\t\t}\n\t};\n}\n\nconst snippet_symbol = Symbol.for('svelte.snippet');\n\n/**\n * @param {any} fn\n */\nexport function add_snippet_symbol(fn) {\n\tfn[snippet_symbol] = true;\n\treturn fn;\n}\n\n/**\n * Validate that the function handed to `{@render ...}` is a snippet function, and not some other kind of function.\n * @param {any} snippet_fn\n */\nexport function validate_snippet(snippet_fn) {\n\tif (snippet_fn[snippet_symbol] !== true) {\n\t\tthrow new Error(\n\t\t\t'The argument to `{@render ...}` must be a snippet function, not a component or some other kind of function. ' +\n\t\t\t\t'If you want to dynamically render one snippet or another, use `$derived` and pass its result to `{@render ...}`.'\n\t\t);\n\t}\n\treturn snippet_fn;\n}\n\n/**\n * Validate that the function behind `<Component />` isn't a snippet.\n * @param {any} component_fn\n */\nexport function validate_component(component_fn) {\n\tif (component_fn?.[snippet_symbol] === true) {\n\t\tthrow new Error('A snippet must be rendered with `{@render ...}`');\n\t}\n\treturn component_fn;\n}\n", "import { createClassComponent } from '../../legacy/legacy-client.js';\nimport { render_effect, destroy_signal } from './runtime.js';\nimport { open, close } from './render.js';\nimport { define_property } from './utils.js';\n\n/**\n * @typedef {Object} CustomElementPropDefinition\n * @property {string} [attribute]\n * @property {boolean} [reflect]\n * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]\n */\n\n/** @type {any} */\nlet SvelteElement;\n\nif (typeof HTMLElement === 'function') {\n\tSvelteElement = class extends HTMLElement {\n\t\t/** The Svelte component constructor */\n\t\t$$ctor;\n\t\t/** Slots */\n\t\t$$s;\n\t\t/** @type {any} The Svelte component instance */\n\t\t$$c;\n\t\t/** Whether or not the custom element is connected */\n\t\t$$cn = false;\n\t\t/** @type {Record<string, any>} Component props data */\n\t\t$$d = {};\n\t\t/** `true` if currently in the process of reflecting component props back to attributes */\n\t\t$$r = false;\n\t\t/** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */\n\t\t$$p_d = {};\n\t\t/** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */\n\t\t$$l = {};\n\t\t/** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */\n\t\t$$l_u = new Map();\n\t\t/** @type {any} The managed render effect for reflecting attributes */\n\t\t$$me;\n\n\t\t/**\n\t\t * @param {*} $$componentCtor\n\t\t * @param {*} $$slots\n\t\t * @param {*} use_shadow_dom\n\t\t */\n\t\tconstructor($$componentCtor, $$slots, use_shadow_dom) {\n\t\t\tsuper();\n\t\t\tthis.$$ctor = $$componentCtor;\n\t\t\tthis.$$s = $$slots;\n\t\t\tif (use_shadow_dom) {\n\t\t\t\tthis.attachShadow({ mode: 'open' });\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} type\n\t\t * @param {EventListenerOrEventListenerObject} listener\n\t\t * @param {boolean | AddEventListenerOptions} [options]\n\t\t */\n\t\taddEventListener(type, listener, options) {\n\t\t\t// We can't determine upfront if the event is a custom event or not, so we have to\n\t\t\t// listen to both. If someone uses a custom event with the same name as a regular\n\t\t\t// browser event, this fires twice - we can't avoid that.\n\t\t\tthis.$$l[type] = this.$$l[type] || [];\n\t\t\tthis.$$l[type].push(listener);\n\t\t\tif (this.$$c) {\n\t\t\t\tconst unsub = this.$$c.$on(type, listener);\n\t\t\t\tthis.$$l_u.set(listener, unsub);\n\t\t\t}\n\t\t\tsuper.addEventListener(type, listener, options);\n\t\t}\n\n\t\t/**\n\t\t * @param {string} type\n\t\t * @param {EventListenerOrEventListenerObject} listener\n\t\t * @param {boolean | AddEventListenerOptions} [options]\n\t\t */\n\t\tremoveEventListener(type, listener, options) {\n\t\t\tsuper.removeEventListener(type, listener, options);\n\t\t\tif (this.$$c) {\n\t\t\t\tconst unsub = this.$$l_u.get(listener);\n\t\t\t\tif (unsub) {\n\t\t\t\t\tunsub();\n\t\t\t\t\tthis.$$l_u.delete(listener);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tasync connectedCallback() {\n\t\t\tthis.$$cn = true;\n\t\t\tif (!this.$$c) {\n\t\t\t\t// We wait one tick to let possible child slot elements be created/mounted\n\t\t\t\tawait Promise.resolve();\n\t\t\t\tif (!this.$$cn) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t/** @param {string} name */\n\t\t\t\tfunction create_slot(name) {\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Element} anchor\n\t\t\t\t\t */\n\t\t\t\t\treturn (anchor) => {\n\t\t\t\t\t\tconst node = open(anchor, true, () => {\n\t\t\t\t\t\t\tconst slot = document.createElement('slot');\n\t\t\t\t\t\t\tif (name !== 'default') {\n\t\t\t\t\t\t\t\tslot.name = name;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn slot;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tclose(anchor, /** @type {Element} */ (node));\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t/** @type {Record<string, any>} */\n\t\t\t\tconst $$slots = {};\n\t\t\t\tconst existing_slots = get_custom_elements_slots(this);\n\t\t\t\tfor (const name of this.$$s) {\n\t\t\t\t\tif (name in existing_slots) {\n\t\t\t\t\t\tif (name === 'default') {\n\t\t\t\t\t\t\tthis.$$d.children = create_slot(name);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$$slots[name] = create_slot(name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const attribute of this.attributes) {\n\t\t\t\t\t// this.$$data takes precedence over this.attributes\n\t\t\t\t\tconst name = this.$$g_p(attribute.name);\n\t\t\t\t\tif (!(name in this.$$d)) {\n\t\t\t\t\t\tthis.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, 'toProp');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$$c = createClassComponent({\n\t\t\t\t\tcomponent: this.$$ctor,\n\t\t\t\t\ttarget: this.shadowRoot || this,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\t...this.$$d,\n\t\t\t\t\t\t$$slots\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Reflect component props as attributes\n\t\t\t\tthis.$$me = render_effect(() => {\n\t\t\t\t\tthis.$$r = true;\n\t\t\t\t\tfor (const key of Object.keys(this.$$c)) {\n\t\t\t\t\t\tif (!this.$$p_d[key]?.reflect) continue;\n\t\t\t\t\t\tthis.$$d[key] = this.$$c[key];\n\t\t\t\t\t\tconst attribute_value = get_custom_element_value(\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tthis.$$d[key],\n\t\t\t\t\t\t\tthis.$$p_d,\n\t\t\t\t\t\t\t'toAttribute'\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (attribute_value == null) {\n\t\t\t\t\t\t\tthis.removeAttribute(this.$$p_d[key].attribute || key);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.setAttribute(this.$$p_d[key].attribute || key, attribute_value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.$$r = false;\n\t\t\t\t});\n\n\t\t\t\tfor (const type in this.$$l) {\n\t\t\t\t\tfor (const listener of this.$$l[type]) {\n\t\t\t\t\t\tconst unsub = this.$$c.$on(type, listener);\n\t\t\t\t\t\tthis.$$l_u.set(listener, unsub);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$$l = {};\n\t\t\t}\n\t\t}\n\n\t\t// We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte\n\t\t// and setting attributes through setAttribute etc, this is helpful\n\n\t\t/**\n\t\t * @param {string} attr\n\t\t * @param {string} _oldValue\n\t\t * @param {string} newValue\n\t\t */\n\t\tattributeChangedCallback(attr, _oldValue, newValue) {\n\t\t\tif (this.$$r) return;\n\t\t\tattr = this.$$g_p(attr);\n\t\t\tthis.$$d[attr] = get_custom_element_value(attr, newValue, this.$$p_d, 'toProp');\n\t\t\tthis.$$c?.$set({ [attr]: this.$$d[attr] });\n\t\t}\n\n\t\tdisconnectedCallback() {\n\t\t\tthis.$$cn = false;\n\t\t\t// In a microtask, because this could be a move within the DOM\n\t\t\tPromise.resolve().then(() => {\n\t\t\t\tif (!this.$$cn) {\n\t\t\t\t\tthis.$$c.$destroy();\n\t\t\t\t\tdestroy_signal(this.$$me);\n\t\t\t\t\tthis.$$c = undefined;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * @param {string} attribute_name\n\t\t */\n\t\t$$g_p(attribute_name) {\n\t\t\treturn (\n\t\t\t\tObject.keys(this.$$p_d).find(\n\t\t\t\t\t(key) =>\n\t\t\t\t\t\tthis.$$p_d[key].attribute === attribute_name ||\n\t\t\t\t\t\t(!this.$$p_d[key].attribute && key.toLowerCase() === attribute_name)\n\t\t\t\t) || attribute_name\n\t\t\t);\n\t\t}\n\t};\n}\n\n/**\n * @param {string} prop\n * @param {any} value\n * @param {Record<string, CustomElementPropDefinition>} props_definition\n * @param {'toAttribute' | 'toProp'} [transform]\n */\nfunction get_custom_element_value(prop, value, props_definition, transform) {\n\tconst type = props_definition[prop]?.type;\n\tvalue = type === 'Boolean' && typeof value !== 'boolean' ? value != null : value;\n\tif (!transform || !props_definition[prop]) {\n\t\treturn value;\n\t} else if (transform === 'toAttribute') {\n\t\tswitch (type) {\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn value == null ? null : JSON.stringify(value);\n\t\t\tcase 'Boolean':\n\t\t\t\treturn value ? '' : null;\n\t\t\tcase 'Number':\n\t\t\t\treturn value == null ? null : value;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t} else {\n\t\tswitch (type) {\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn value && JSON.parse(value);\n\t\t\tcase 'Boolean':\n\t\t\t\treturn value; // conversion already handled above\n\t\t\tcase 'Number':\n\t\t\t\treturn value != null ? +value : value;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t}\n}\n\n/**\n * @param {HTMLElement} element\n */\nfunction get_custom_elements_slots(element) {\n\t/** @type {Record<string, true>} */\n\tconst result = {};\n\telement.childNodes.forEach((node) => {\n\t\tresult[/** @type {Element} node */ (node).slot || 'default'] = true;\n\t});\n\treturn result;\n}\n\n/**\n * @internal\n *\n * Turn a Svelte component into a custom element.\n * @param {any} Component  A Svelte component function\n * @param {Record<string, CustomElementPropDefinition>} props_definition  The props to observe\n * @param {string[]} slots  The slots to create\n * @param {string[]} accessors  Other accessors besides the ones for props the component has\n * @param {boolean} use_shadow_dom  Whether to use shadow DOM\n * @param {(ce: new () => HTMLElement) => new () => HTMLElement} [extend]\n */\nexport function create_custom_element(\n\tComponent,\n\tprops_definition,\n\tslots,\n\taccessors,\n\tuse_shadow_dom,\n\textend\n) {\n\tlet Class = class extends SvelteElement {\n\t\tconstructor() {\n\t\t\tsuper(Component, slots, use_shadow_dom);\n\t\t\tthis.$$p_d = props_definition;\n\t\t}\n\t\tstatic get observedAttributes() {\n\t\t\treturn Object.keys(props_definition).map((key) =>\n\t\t\t\t(props_definition[key].attribute || key).toLowerCase()\n\t\t\t);\n\t\t}\n\t};\n\tObject.keys(props_definition).forEach((prop) => {\n\t\tdefine_property(Class.prototype, prop, {\n\t\t\tget() {\n\t\t\t\treturn this.$$c && prop in this.$$c ? this.$$c[prop] : this.$$d[prop];\n\t\t\t},\n\t\t\tset(value) {\n\t\t\t\tvalue = get_custom_element_value(prop, value, props_definition);\n\t\t\t\tthis.$$d[prop] = value;\n\t\t\t\tthis.$$c?.$set({ [prop]: value });\n\t\t\t}\n\t\t});\n\t});\n\taccessors.forEach((accessor) => {\n\t\tdefine_property(Class.prototype, accessor, {\n\t\t\tget() {\n\t\t\t\treturn this.$$c?.[accessor];\n\t\t\t}\n\t\t});\n\t});\n\tif (extend) {\n\t\t// @ts-expect-error - assigning here is fine\n\t\tClass = extend(Class);\n\t}\n\tComponent.element = /** @type {any} */ Class;\n\treturn Class;\n}\n", "import { define_property } from '../internal/client/utils.js';\nimport * as $ from '../internal/index.js';\n\n/**\n * Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.\n *\n * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @template {Record<string, any>} Events\n * @template {Record<string, any>} Slots\n *\n * @param {import('../main/public.js').ComponentConstructorOptions<Props> & {\n * \tcomponent: import('../main/public.js').SvelteComponent<Props, Events, Slots>;\n * \timmutable?: boolean;\n * \trecover?: false;\n * }} options\n * @returns {import('../main/public.js').SvelteComponent<Props, Events, Slots> & Exports}\n */\nexport function createClassComponent(options) {\n\t// @ts-expect-error $$prop_def etc are not actually defined\n\treturn new Svelte4Component(options);\n}\n\n/**\n * Takes the component function and returns a Svelte 4 compatible component constructor.\n *\n * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @template {Record<string, any>} Events\n * @template {Record<string, any>} Slots\n *\n * @param {import('../main/public.js').SvelteComponent<Props, Events, Slots>} component\n * @returns {typeof import('../main/public.js').SvelteComponent<Props, Events, Slots> & Exports}\n */\nexport function asClassComponent(component) {\n\t// @ts-expect-error $$prop_def etc are not actually defined\n\treturn class extends Svelte4Component {\n\t\t/** @param {any} options */\n\t\tconstructor(options) {\n\t\t\tsuper({\n\t\t\t\tcomponent,\n\t\t\t\t...options\n\t\t\t});\n\t\t}\n\t};\n}\n\nclass Svelte4Component {\n\t/** @type {any} */\n\t#events = {};\n\n\t/** @type {ReturnType<typeof $.createRoot>} */\n\t#instance;\n\n\t/**\n\t * @param {import('../main/public.js').ComponentConstructorOptions & {\n\t *  component: any;\n\t * \timmutable?: boolean;\n\t * \trecover?: false;\n\t * }} options\n\t */\n\tconstructor(options) {\n\t\tthis.#instance = $.createRoot(options.component, {\n\t\t\ttarget: options.target,\n\t\t\tprops: { ...options.props, $$events: this.#events },\n\t\t\tcontext: options.context,\n\t\t\timmutable: options.immutable,\n\t\t\tintro: options.intro,\n\t\t\trecover: options.recover\n\t\t});\n\n\t\tfor (const key of Object.keys(this.#instance)) {\n\t\t\tif (key === '$set' || key === '$destroy') continue;\n\n\t\t\tdefine_property(this, key, {\n\t\t\t\tget() {\n\t\t\t\t\treturn this.#instance[key];\n\t\t\t\t},\n\t\t\t\t/** @param {any} value */\n\t\t\t\tset(value) {\n\t\t\t\t\tthis.#instance[key] = value;\n\t\t\t\t},\n\t\t\t\tenumerable: true\n\t\t\t});\n\t\t}\n\t}\n\n\t/** @param {Record<string, any>} props */\n\t$set(props) {\n\t\tthis.#instance.$set(props);\n\t}\n\n\t/**\n\t * @param {string} event\n\t * @param {(...args: any[]) => any} callback\n\t * @returns {any}\n\t */\n\t$on(event, callback) {\n\t\tthis.#events[event] = this.#events[event] || [];\n\n\t\t/** @param {any[]} args */\n\t\tconst cb = (...args) => callback.call(this, ...args);\n\t\tthis.#events[event].push(cb);\n\t\treturn () => {\n\t\t\tthis.#events[event] = this.#events[event].filter(/** @param {any} fn */ (fn) => fn !== cb);\n\t\t};\n\t}\n\n\t$destroy() {\n\t\tthis.#instance.$destroy();\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAEO,IAAM,aAAa;AACnB,IAAM,YAAY;AAElB,IAAM,WAAW,UAAU;AAC3B,IAAM,aAAa,UAAU;AAC7B,IAAM,kBAAkB,WAAW;AACnC,IAAM,iBAAiB,WAAW;AAClC,IAAM,kBAAkB,WAAW;;;ACNnC,IAAI,6BAA6B;AAMjC,SAAS,+BAA+B,UAAU;AACxD,+BAA6B;AAC9B;AAOO,SAAS,uBAAuB,MAAM;AAE5C,QAAM,WAAW,CAAC;AAGlB,MAAI,eAAe;AAGnB,MAAI,eAAe;AACnB,SAAO,iBAAiB,MAAM;AAC7B,UAAM,YAAY,aAAa;AAC/B,UAAM,eAAe,aAAa;AAClC,QAAI,cAAc,GAAG;AACpB,YAAM;AAAA;AAAA,QAA+B,aAAc;AAAA;AACnD,UAAI,KAAK,WAAW,MAAM,GAAG;AAC5B,cAAM,QAAQ,KAAK,MAAM,CAAC;AAC1B,YAAI,iBAAiB,MAAM;AAC1B,yBAAe;AAAA,QAChB,WAAW,UAAU,cAAc;AAClC,iBAAO;AAAA,QACR,OAAO;AACN,mBAAS;AAAA;AAAA,YAA8C;AAAA,UAAa;AAAA,QACrE;AACA,uBAAe;AACf;AAAA,MACD;AAAA,IACD;AACA,QAAI,iBAAiB,MAAM;AAC1B,eAAS;AAAA;AAAA,QAA8C;AAAA,MAAa;AAAA,IACrE;AACA,mBAAe;AAAA,EAChB;AACA,SAAO;AACR;AAOO,SAAS,qBAAqB,aAAa,eAAe;AAEhE,MAAI,cAAc;AAClB,MAAI,+BAA+B,MAAM;AACxC,QAAI,eAAe;AAClB;AAAA,MAAmC,YAAY;AAAA,IAChD;AACA,QAAI,YAAY,aAAa,GAAG;AAE/B,UAAI,WAAW,YAAY;AAC3B,UAAI,aAAa,QAAW;AAC3B,mBAAW,uBAAuB,WAAW;AAE7C,oBAAY,aAAa;AAAA,MAC1B;AACA,qCAA+B,QAAQ;AAAA,IACxC,OAAO;AACN,qCAA+B;AAAA;AAAA,QAAyB,YAAY;AAAA,MAAW,CAAC;AAAA,IACjF;AAAA,EACD;AACD;;;ACvEA,IAAI;AAGJ,IAAI;AAGJ,IAAI;AAGJ,IAAI;AAGJ,IAAI;AAGJ,IAAI;AAGJ,IAAI;AAGJ,IAAI;AAGJ,IAAI;AAGJ,IAAI;AAGJ,IAAI;AAGJ,IAAI;AAGJ,IAAI;AAMG,IAAI;AAIJ,IAAI;AAMJ,SAAS,kBAAkB;AACjC,MAAI,mBAAmB,QAAW;AACjC;AAAA,EACD;AAEA,mBAAiB,KAAK;AACtB,sBAAoB,QAAQ;AAC5B,mBAAiB,KAAK;AACtB,kBAAgB,IAAI;AAEpB,wBAAsB,eAAe;AACrC,sBAAoB,eAAe;AACnC,mBAAiB,cAAc;AAC/B,mBAAiB,cAAc;AAC/B,sBAAoB,cAAc;AAElC,YAAU;AACV,cAAY;AAIZ,oBAAkB,UAAU;AAE5B,iBAAe,cAAc;AAE7B,oBAAkB,cAAc;AAEhC;AAAA;AAAA,EAEC,eAAe,gBAAgB,YAAY,EAAE;AAG9C;AAAA;AAAA,EAEC,eAAe,gBAAgB,aAAa,EAAE;AAG/C;AAAA;AAAA,EAEC,eAAe,gBAAgB,aAAa,EAAE;AAG/C;AAAA;AAAA,EAEC,eAAe,mBAAmB,WAAW,EAAE;AAEjD;AAQO,SAAS,aAAaA,UAASC,QAAO;AAC5C,sBAAoB,KAAKD,UAASC,MAAK;AACxC;AASO,SAAS,QAAQ,KAAKC,MAAK,OAAO;AACxC,iBAAe,KAAK,KAAKA,MAAK,KAAK;AACpC;AAmBO,SAAS,QAAQ,KAAKC,MAAK;AACjC,SAAO,eAAe,KAAK,KAAKA,IAAG;AACpC;AASO,SAAS,WAAW,MAAM,MAAM;AACtC;AAAA;AAAA,IAAyB,kBAAkB,KAAK,MAAM,IAAI;AAAA;AAC3D;AAQO,SAAS,MAAM,MAAM;AAC3B,QAAMC,SAAQ,gBAAgB,KAAK,IAAI;AACvC,MAAI,+BAA+B,MAAM;AAExC,QAAIA,WAAU,MAAM;AACnB,YAAMC,QAAO,SAAS,eAAe,EAAE;AACvC,WAAK,YAAYA,KAAI;AACrB,aAAOA;AAAA,IACR,OAAO;AACN,aAAO,2BAA2BD,MAAK;AAAA,IACxC;AAAA,EACD;AACA,SAAOA;AACR;AAQO,SAAS,WAAW,MAAM;AAChC,MAAI,+BAA+B,MAAM;AACxC,UAAM;AAAA;AAAA,MAAoC,KAAM,CAAC;AAAA;AACjD,QAAI,+BAA+B,QAAQ,eAAe,MAAM;AAC/D,aAAO,2BAA2B,UAAU;AAAA,IAC7C;AACA,WAAO;AAAA,EACR;AACA,SAAO,gBAAgB;AAAA;AAAA,IAA0B;AAAA,EAAK;AACvD;AAQO,SAAS,QAAQ,MAAM;AAC7B,QAAM,eAAe,iBAAiB,KAAK,IAAI;AAC/C,MAAI,+BAA+B,QAAQ,iBAAiB,MAAM;AACjE,WAAO,2BAA2B,YAAY;AAAA,EAC/C;AACA,SAAO;AACR;AAQO,SAAS,eAAe,MAAME,aAAY;AAChD,iBAAe,KAAK,MAAMA,WAAU;AACrC;AAOO,SAAS,mBAAmB,MAAM;AACxC,mBAAiB,KAAK,MAAM,EAAE;AAC/B;AAIO,SAAS,eAAe,MAAM;AACpC,SAAO,SAAS,cAAc,IAAI;AACnC;AAMA,SAAS,2BAA2B,MAAM;AACzC,MACC,KAAK,aAAa;AAAA,EACM,KAAM,KAAK,WAAW,MAAM;AAAA,EACJ,2BAA4B,GAAG,EAAE,MAAM,MACtF;AACD,UAAM;AAAA;AAAA,MAA2D,uBAAuB,IAAI;AAAA;AAC5F,UAAM,aAAa,SAAS,GAAG,EAAE,KAAK;AACtC,UAAM;AAAA;AAAA,MAA8B,WAAW;AAAA;AAE/C,WAAO,aAAa;AACpB,WAAO;AAAA,EACR;AACA,SAAO;AACR;;;AC7PO,IAAM,aAAa;AACnB,IAAM,WAAW;AACjB,IAAM,aAAa;AACnB,IAAM,kBAAkB;AACxB,IAAM,cAAc;AACpB,IAAM,YAAY;AAClB,IAAM,aAAa;AACnB,IAAM,0BAA0B;AAChC,IAAM,wBAAwB;AAC9B,IAAM,gBAAgB;AAOtB,SAAS,kBAAkB,WAAW,OAAO;AACnD,SAAO;AAAA,IACN,KAAK;AAAA,IACL,QAAQ;AAAA,IACR;AAAA,IACA;AAAA,IACA,QAAQ;AAAA,IACR,YAAY;AAAA,IACZ,MAAM;AAAA,EACP;AACD;AAGO,SAAS,kBAAkB;AACjC,SAAO;AAAA,IACN,SAAS;AAAA,IACT,KAAK;AAAA,IACL,QAAQ;AAAA,IACR;AAAA;AAAA,MAAmD;AAAA;AAAA,IACnD,YAAY;AAAA,IACZ,MAAM;AAAA,EACP;AACD;AAGO,SAAS,mBAAmB;AAClC,SAAO;AAAA,IACN,KAAK;AAAA,IACL,QAAQ;AAAA,IACR;AAAA;AAAA,MAAmD;AAAA;AAAA,IACnD,YAAY;AAAA,IACZ,MAAM;AAAA,EACP;AACD;AAGO,SAAS,oBAAoB;AACnC,SAAO;AAAA,IACN,KAAK;AAAA,IACL,QAAQ;AAAA,IACR;AAAA;AAAA,MAAmD;AAAA;AAAA,IACnD,YAAY;AAAA,IACZ,MAAM;AAAA,EACP;AACD;AAGO,SAAS,+BAA+B;AAC9C,SAAO;AAAA,IACN,KAAK;AAAA,IACL,QAAQ;AAAA,IACR;AAAA;AAAA,MAAmD;AAAA;AAAA,IACnD,YAAY;AAAA,IACZ,MAAM;AAAA,EACP;AACD;AAGO,SAAS,iCAAiC;AAChD,SAAO;AAAA,IACN,KAAK;AAAA,IACL,QAAQ;AAAA,IACR;AAAA;AAAA,MAAmD;AAAA;AAAA,IACnD,YAAY;AAAA,IACZ,MAAM;AAAA,EACP;AACD;AAGO,SAAS,qBAAqB;AACpC,SAAO;AAAA,IACN,KAAK;AAAA,IACL,QAAQ;AAAA,IACR;AAAA;AAAA,MAAmD;AAAA;AAAA,IACnD,SAAS;AAAA,IACT,YAAY;AAAA,IACZ,MAAM;AAAA,EACP;AACD;AAOO,SAAS,kBAAkB,OAAO,QAAQ;AAChD,SAAO;AAAA,IACN;AAAA,IACA,KAAK;AAAA,IACL;AAAA,IACA,OAAO,CAAC;AAAA,IACR,QAAQ;AAAA,IACR;AAAA;AAAA,MAAmD;AAAA;AAAA,IACnD,YAAY;AAAA,IACZ,aAAa,CAAC;AAAA,IACd,MAAM;AAAA,EACP;AACD;AAQO,SAAS,uBAAuB,MAAM,OAAOC,MAAK;AACxD,SAAO;AAAA,IACN,KAAK;AAAA,IACL,QAAQ;AAAA,IACR;AAAA,IACA,KAAAA;AAAA,IACA;AAAA,IACA;AAAA;AAAA,MAAuD;AAAA;AAAA,IACvD,YAAY;AAAA,IACZ,aAAa;AAAA,IACb,MAAM;AAAA,EACP;AACD;AAGO,SAAS,uBAAuB;AACtC,SAAO;AAAA,IACN,KAAK;AAAA,IACL;AAAA;AAAA,MAAmD;AAAA;AAAA,IACnD,QAAQ;AAAA,IACR,YAAY;AAAA,IACZ,MAAM;AAAA,EACP;AACD;;;AClJO,IAAM,qBAAqB;AAC3B,IAAM,sBAAsB,KAAK;AACjC,IAAM,aAAa,KAAK;AACxB,IAAM,qBAAqB,KAAK;AAChC,IAAM,mBAAmB,KAAK;AAG9B,IAAM,kBAAkB;AAAA,EAC9B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACD;AAGO,IAAM,yBAAyB,CAAC,cAAc,aAAa,UAAU;;;ACtB5E,IAAM,YAAY;AAClB,IAAM,cAAc;AACpB,IAAM,YAAY;AAGX,SAAS,0BAA0BC,OAAM;AAC/C,MAAI,OAAO,SAAS,cAAc,UAAU;AAC5C,OAAK,YAAYA;AACjB,SAAO,KAAK;AACb;AAQO,SAAS,OAAO,SAAS,gBAAgBC,UAAS;AACxD,MAAI,SAAS,OAAO,GAAG;AACtB,QAAI,IAAI;AACR,QAAI;AACJ,WAAO,IAAI,QAAQ,QAAQ,KAAK;AAC/B,aAAO,QAAQ,CAAC;AAChB,UAAIA,aAAY,MAAM;AACrB;AAAA;AAAA,UAAqC;AAAA;AAAA,UAAsC;AAAA,QAAK;AAAA,MACjF,OAAO;AACN,QAAAA,SAAQ;AAAA;AAAA,UAA4B;AAAA,QAAK;AAAA,MAC1C;AAAA,IACD;AACA,WAAO,QAAQ,CAAC;AAAA,EACjB,WAAW,YAAY,MAAM;AAC5B,QAAIA,aAAY,MAAM;AACrB;AAAA;AAAA,QAAqC;AAAA;AAAA,QAAsC;AAAA,MAAQ;AAAA,IACpF,OAAO;AACN,MAAAA,SAAQ;AAAA;AAAA,QAA4B;AAAA,MAAQ;AAAA,IAC7C;AAAA,EACD;AACA;AAAA;AAAA,IAAgD;AAAA;AACjD;AAMO,SAAS,OAAO,SAAS;AAC/B,MAAI,aAAa;AACjB,MAAI,SAAS,OAAO,GAAG;AACtB,QAAI,IAAI;AACR,QAAI;AACJ,WAAO,IAAI,QAAQ,QAAQ,KAAK;AAC/B,aAAO,QAAQ,CAAC;AAChB,UAAI,MAAM,GAAG;AACZ,qBAAa;AAAA,MACd;AACA,UAAI,KAAK,aAAa;AACrB,aAAK,OAAO;AAAA,MACb;AAAA,IACD;AAAA,EACD,WAAW,QAAQ,aAAa;AAC/B,YAAQ,OAAO;AAAA,EAChB;AACA;AAAA;AAAA,IAAgD;AAAA;AACjD;AASO,SAAS,eAAe,KAAK,OAAO,KAAK;AAC/C,uBAAqB,GAAG;AACxB,MAAI,+BAA+B,MAAM;AACxC,WAAO;AAAA,EACR;AACA,MAAID,QAAO,QAAQ;AAInB,MAAI,SAAS;AACb,MAAI;AACJ,MAAI,KAAK;AACR,IAAAA,QAAO,QAAQA,KAAI;AAAA,EACpB;AACA,MAAI,UAAU,0BAA0BA,KAAI;AAC5C,MAAI,KAAK;AACR;AAAA;AAAA,IAAmE,QAAQ;AAAA,EAC5E;AACA,MAAI,QAAQ,QAAQ,UAAU,IAAI;AAClC,eAAa,MAAM,KAAK,MAAM,UAAU;AACxC,SAAO,OAAO;AAAA;AAAA,IAA2B,MAAM;AAAA,MAAc,KAAK;AAClE;AAAA;AAAA,IAAuD;AAAA;AACxD;AASA,SAAS,uBAAuB,OAAO,KAAK,eAAeC,UAAS;AACnE,MAAI;AAAA;AAAA,IAA4D,MAAM;AAAA;AACtE,MAAIA,aAAY,MAAM;AACrB,QAAI,eAAe;AAClB,aAAO;AAAA,QAAO;AAAA;AAAA,QAAiC;AAAA,QAAM;AAAA,MAAI;AAAA,IAC1D,OAAO;AACN,aAAO;AAAA,QAAO;AAAA;AAAA,QAAiC,IAAI;AAAA,QAAa;AAAA,MAAG;AAAA,IACpE;AAAA,EACD;AACA,SAAO,OAAO,SAAS,MAAMA,QAAO;AACrC;AAMA,SAAS,gBAAgB,OAAO;AAC/B,MAAI,UAAU,MAAM;AACpB,MAAI,SAAS,OAAO,GAAG;AACtB;AAAA;AAAA,MAAgD,QAAQ,CAAC;AAAA;AAAA,EAC1D;AACA;AAAA;AAAA,IAAgD;AAAA;AACjD;AAMA,SAAS,iCAAiC,oBAAoB;AAC7D,MAAI,SAAS,mBAAmB;AAChC,MAAI,SAAS,GAAG;AACf,QAAI,IAAI;AACR,QAAI;AACJ,QAAIC;AACJ,WAAO,IAAI,QAAQ,KAAK;AACvB,cAAQ,mBAAmB,CAAC;AAC5B,MAAAA,cAAa,MAAM;AACnB,UAAIA,gBAAe,MAAM;AACxB,cAAM,aAAa;AACnB,gCAAwB,OAAO,MAAM,KAAK;AAAA,MAC3C;AAAA,IACD;AACA,uBAAmB,SAAS;AAAA,EAC7B;AACD;AAaO,SAAS,wBACf,OACA,YACA,KACA,eACA,WACA,OACA,mBACC;AACD,MAAI,WAAW,WAAW;AAC1B,MAAI,qBAAqB,WAAW;AAGpC,MAAI,IAAI,SAAS;AAGjB,MAAI,IAAI,MAAM;AACd,MAAI,SAAS,KAAK,IAAI,GAAG,CAAC;AAC1B,MAAI,QAAQ;AAGZ,MAAI;AACJ,MAAI;AACJ,MAAI,mBAAmB,WAAW,GAAG;AACpC,qCAAiC,kBAAkB;AAAA,EACpD;AACA,MAAI,MAAM,GAAG;AACZ,eAAW,CAAC;AAEZ,QAAI,iBAAiB,MAAM,GAAG;AAC7B,yBAAmB,GAAG;AAAA,IACvB;AACA,WAAO,QAAQ,QAAQ;AACtB,cAAQ,SAAS,OAAO;AACxB,8BAAwB,OAAO,oBAAoB,mBAAmB,aAAa;AAAA,IACpF;AAAA,EACD,OAAO;AACN,QAAI;AACJ,eAAW,MAAM,CAAC;AAClB,QAAI,+BAA+B,MAAM;AAExC,UAAI,iBAAiB,2BAA2B,CAAC;AACjD,aAAO,QAAQ,QAAQ,SAAS;AAE/B,eAAO,MAAM,KAAK;AAClB,YAAI;AAAA;AAAA,UACH,uBAAuB,cAAc;AAAA;AAEtC,uCAA+B,QAAQ;AACvC;AAAA;AAAA;AAAA,QAC2C,SAAS,GAAG,EAAE,EAAG,YAAa;AAEzE,gBAAQ,gBAAgB,MAAM,MAAM,OAAO,WAAW,KAAK;AAC3D,iBAAS,KAAK,IAAI;AAAA,MACnB;AAAA,IACD,OAAO;AACN,aAAO,QAAQ,QAAQ,SAAS;AAC/B,YAAI,SAAS,GAAG;AAEf,iBAAO,MAAM,KAAK;AAClB,kBAAQ,gBAAgB,MAAM,MAAM,OAAO,WAAW,KAAK;AAC3D,mBAAS,KAAK,IAAI;AAClB,iCAAuB,OAAO,KAAK,eAAe,IAAI;AAAA,QACvD,WAAW,SAAS,GAAG;AAEtB,kBAAQ,SAAS,KAAK;AACtB,kCAAwB,OAAO,oBAAoB,iBAAiB;AAAA,QACrE,OAAO;AAEN,iBAAO,MAAM,KAAK;AAClB,kBAAQ,SAAS,KAAK;AACtB,mBAAS,KAAK,IAAI;AAClB,iCAAuB,OAAO,MAAM,OAAO,KAAK;AAAA,QACjD;AAAA,MACD;AAAA,IACD;AAAA,EACD;AACA,aAAW,QAAQ;AACpB;AAmBO,SAAS,wBACf,OACA,YACA,KACA,eACA,WACA,OACA,mBACA,MACC;AACD,MAAI,WAAW,WAAW;AAC1B,QAAM,kBAAkB,SAAS;AACjC,MAAI,qBAAqB,WAAW;AAGpC,MAAI,IAAI,SAAS;AAGjB,MAAI,IAAI,MAAM;AAGd,MAAI;AACJ,MAAI;AACJ,MAAI,mBAAmB,WAAW,GAAG;AACpC,qCAAiC,kBAAkB;AAAA,EACpD;AACA,MAAI,MAAM,GAAG;AACZ,eAAW,CAAC;AAEZ,QAAI,iBAAiB,MAAM,GAAG;AAC7B,yBAAmB,GAAG;AAAA,IACvB;AACA,WAAO,IAAI,GAAG;AACb,cAAQ,SAAS,EAAE,CAAC;AACpB,8BAAwB,OAAO,oBAAoB,mBAAmB,aAAa;AAAA,IACpF;AAAA,EACD,OAAO;AACN,QAAI,QAAQ,IAAI;AAChB,QAAI,QAAQ,IAAI;AAChB,QAAIC;AACJ,QAAI;AACJ,QAAI;AACJ,eAAW,MAAM,CAAC;AAClB,QAAI,+BAA+B,MAAM;AACxC,UAAI;AAGJ,UAAI,iBAAiB,2BAA2B,CAAC;AACjD,aAAO,IAAI,GAAG;AAEb,cAAM,QAAQ,EAAE;AAChB,eAAO,MAAM,GAAG;AAChB,QAAAA,OAAM,kBAAkB,KAAK,GAAG,IAAI;AACpC;AAAA,QACC,uBAAuB,cAAc;AAEtC,uCAA+B,QAAQ;AAGvC;AAAA;AAAA,SACuB,SAAS,GAAG,EAAE,KAAK,gBAAgB,YAAa;AAEvE,gBAAQ,gBAAgB,MAAMA,MAAK,KAAK,WAAW,KAAK;AACxD,iBAAS,GAAG,IAAI;AAAA,MACjB;AAAA,IACD,WAAW,MAAM,GAAG;AAEnB,aAAO,IAAI,GAAG;AACb,cAAM,QAAQ,EAAE;AAChB,eAAO,MAAM,GAAG;AAChB,QAAAA,OAAM,kBAAkB,KAAK,GAAG,IAAI;AACpC,gBAAQ,gBAAgB,MAAMA,MAAK,KAAK,WAAW,KAAK;AACxD,iBAAS,GAAG,IAAI;AAChB,+BAAuB,OAAO,KAAK,eAAe,IAAI;AAAA,MACvD;AAAA,IACD,OAAO;AACN,UAAI,uBACF,QAAQ,wBAAwB,MAAM,QAAQ,yBAAyB;AACzE,UAAI,QAAQ;AAGZ,UAAIF,WAAU;AACd,aAAO,MAAM,KAAK;AAClB,MAAAE,OAAM,kBAAkB,KAAK,KAAK,IAAI;AAEtC;AAAO,eAAO,MAAM;AAEnB,iBAAO,SAAS,KAAK,EAAE,QAAQA,MAAK;AACnC,oBAAQ,SAAS,OAAO;AACxB,mBAAO,MAAM,KAAK;AAClB,gBAAI,qBAAqB;AACxB,qCAAuB,OAAO,MAAM,OAAO,KAAK;AAAA,YACjD;AACA,YAAAF,WAAU,gBAAgB,KAAK;AAC/B,qBAAS,KAAK,IAAI;AAClB,gBAAI,QAAQ,EAAE,SAAS,QAAQ,OAAO;AACrC,oBAAM;AAAA,YACP;AACA,YAAAE,OAAM,kBAAkB,KAAK,KAAK,IAAI;AAAA,UACvC;AACA,iBAAO,MAAM,KAAK;AAClB,UAAAA,OAAM,kBAAkB,KAAK,KAAK,IAAI;AAEtC,iBAAO,SAAS,SAAS,SAAS,SAAS,SAAS,KAAK,EAAE,QAAQA,MAAK;AACvE,mBAAO,MAAM,KAAK;AAClB,oBAAQ,SAAS,KAAK;AACtB,gBAAI,qBAAqB;AACxB,qCAAuB,OAAO,MAAM,OAAO,KAAK;AAAA,YACjD;AACA,qBAAS,KAAK,IAAI;AAClB,cAAE;AACF,YAAAA,OAAM,kBAAkB,KAAK,KAAK,IAAI,MAAM,KAAK;AAAA,UAClD;AACA;AAAA,QACD;AAEA,UAAI,QAAQ,OAAO;AAClB,eAAO,SAAS,OAAO;AACtB,iBAAO,MAAM,KAAK;AAClB,UAAAA,OAAM,kBAAkB,KAAK,KAAK,IAAI;AACtC,kBAAQ,gBAAgB,MAAMA,MAAK,OAAO,WAAW,KAAK;AAC1D,mBAAS,OAAO,IAAI;AACpB,UAAAF,WAAU,uBAAuB,OAAO,KAAK,eAAeA,QAAO;AAAA,QACpE;AAAA,MACD,WAAW,QAAQ,OAAO;AACzB,YAAI;AACJ,WAAG;AACF,eAAK,QAAQ,SAAS,GAAG,OAAO,MAAM;AACrC,oCAAwB,OAAO,oBAAoB,iBAAiB;AAAA,UACrE;AAAA,QACD,SAAS,KAAK;AAAA,MACf,OAAO;AAEN,YAAI,MAAM;AACV,YAAI,WAAW,QAAQ,QAAQ;AAC/B,YAAI,UAAU,IAAI,WAAW,QAAQ;AACrC,YAAI,aAAa,oBAAI,IAAI;AACzB,aAAK,IAAI,GAAG,IAAI,UAAU,EAAE,GAAG;AAC9B,cAAI,IAAI;AACR,kBAAQ,CAAC,IAAI;AACb,iBAAO,MAAM,CAAC;AACd,UAAAE,OAAM,kBAAkB,KAAK,CAAC,IAAI;AAClC,kBAAQ,YAAYA,MAAK,CAAC;AAAA,QAC3B;AACA,aAAK,IAAI,OAAO,KAAK,OAAO,EAAE,GAAG;AAChC,cAAI;AAAA,YAAQ;AAAA;AAAA,YAA8B,SAAS,CAAC,EAAE;AAAA,UAAI;AAC1D,kBAAQ,SAAS,CAAC;AAClB,cAAI,MAAM,QAAW;AACpB,kBAAM,MAAM,IAAI,IAAI;AACpB,oBAAQ,IAAI,KAAK,IAAI;AACrB,qBAAS,CAAC,IAAI;AAAA,UACf,WAAW,UAAU,MAAM;AAC1B,oCAAwB,OAAO,oBAAoB,iBAAiB;AAAA,UACrE;AAAA,QACD;AAEA,YAAI,QAAQ,aAAa;AACxB,mBAAS,OAAO;AAAA,QACjB;AAEA,YAAI,eAAe,QAAQ,sBAAsB;AACjD,YAAI;AACJ,YAAI,aAAa;AAChB,cAAI,IAAI;AACR,iBAAO,MAAM,GAAG;AACf,oBAAQ,IAAI;AACZ,gBAAI,QAAQ,CAAC;AACb,gBAAI,QAAQ,eAAe,MAAM,WAAW;AAC3C,sBAAQ,SAAS,KAAK;AACtB,qCAAuB,OAAO,MAAM,OAAO,KAAK;AAAA,YACjD;AAAA,UACD;AAAA,QACD;AACA,YAAI;AACJ,YAAI;AACJ,eAAO,aAAa,GAAG;AACtB,kBAAQ,WAAW;AACnB,cAAI,QAAQ,QAAQ;AACpB,0BAAgB,MAAM;AACtB,iBAAO,MAAM,KAAK;AAClB,cAAI,eAAe;AAClB,YAAAA,OAAM,kBAAkB,KAAK,KAAK,IAAI;AACtC,oBAAQ,gBAAgB,MAAMA,MAAK,OAAO,WAAW,KAAK;AAAA,UAC3D,OAAO;AACN,oBAAQ,SAAS,KAAK;AACtB,gBAAI,CAAC,eAAe,qBAAqB;AACxC,qCAAuB,OAAO,MAAM,OAAO,KAAK;AAAA,YACjD;AAAA,UACD;AACA,cAAI,iBAAkB,QAAQ,eAAe,MAAM,WAAY;AAC9D,2BAAe,eAAe,SAAYF,WAAU,gBAAgB,UAAU;AAC9E,YAAAA,WAAU,uBAAuB,OAAO,KAAK,eAAe,YAAY;AAAA,UACzE;AACA,mBAAS,KAAK,IAAI;AAClB,uBAAa;AAAA,QACd;AAAA,MACD;AAAA,IACD;AAAA,EACD;AACA,aAAW,QAAQ;AACpB;AAOA,SAAS,SAAS,GAAG;AACpB,MAAI,SAAS,EAAE;AACf,MAAI,SAAS,IAAI,WAAW,MAAM;AAClC,MAAI,QAAQ,IAAI,WAAW,MAAM;AACjC,MAAI,eAAe;AACnB,MAAI,IAAI;AAGR,MAAI;AAGJ,MAAI;AAGJ,MAAI;AAGJ,MAAI;AAEJ,SAAO,EAAE,CAAC,MAAM,WAAW,EAAE,GAAG;AAAA,EAEhC;AACA,QAAM,CAAC,IAAI;AACX,SAAO,IAAI,QAAQ,EAAE,GAAG;AACvB,QAAI,EAAE,CAAC;AACP,QAAI,MAAM,WAAW;AAEpB,UAAI,MAAM,YAAY;AACtB,UAAI,EAAE,CAAC,IAAI,GAAG;AACb,eAAO,CAAC,IAAI;AACZ,cAAM,EAAE,YAAY,IAAI;AAAA,MACzB,OAAO;AACN,aAAK;AACL,aAAK;AACL,eAAO,KAAK,IAAI;AACf,cAAK,KAAK,MAAO;AACjB,cAAI,EAAE,MAAM,CAAC,CAAC,IAAI,GAAG;AACpB,iBAAK,IAAI;AAAA,UACV,OAAO;AACN,iBAAK;AAAA,UACN;AAAA,QACD;AACA,YAAI,IAAI,EAAE,MAAM,EAAE,CAAC,GAAG;AACrB,cAAI,KAAK,GAAG;AACX,mBAAO,CAAC,IAAI,MAAM,KAAK,CAAC;AAAA,UACzB;AACA,gBAAM,EAAE,IAAI;AAAA,QACb;AAAA,MACD;AAAA,IACD;AAAA,EACD;AAEA,MAAI,MAAM,YAAY;AACtB,SAAO,kBAAkB,GAAG;AAC3B,MAAE,CAAC,IAAI;AACP,QAAI,OAAO,CAAC;AAAA,EACb;AACD;;;AC3fA,IAAM,yBAAyB,oBAAI,IAAI;AACvC,IAAM,kBAAkB,OAAO;AAG/B,IAAI,kBAAkB;AAStB,SAAS,aAAa,MAAM,QAAQ,EAAE,UAAU,OAAO,aAAa,MAAM,IAAI,CAAC,GAAG;AACjF,QAAM,IAAI,SAAS,YAAY,aAAa;AAC5C,IAAE,gBAAgB,MAAM,SAAS,YAAY,MAAM;AACnD,SAAO;AACR;AAOA,SAAS,eAAe,KAAK,MAAM;AAClC,MAAI,cAAc,aAAa,IAAI,CAAC;AACrC;AAMA,SAAS,0BAA0BG,QAAO;AACzC,QAAM,QAAQA,OAAM,MAAM,GAAG;AAC7B,MAAI,MAAM,WAAW;AAAG,WAAO,MAAM,CAAC;AACtC,SACC,MAAM,CAAC,IACP,MACE,MAAM,CAAC,EACP;AAAA;AAAA,IAA6B,CAAC,SAAS,KAAK,CAAC,EAAE,YAAY,IAAI,KAAK,MAAM,CAAC;AAAA,EAAC,EAC5E,KAAK,EAAE;AAEX;AAMA,SAAS,gBAAgB,KAAK;AAE7B,QAAM,WAAW,CAAC;AAClB,QAAM,QAAQ,IAAI,MAAM,GAAG;AAC3B,aAAW,QAAQ,OAAO;AACzB,UAAM,CAAC,UAAU,KAAK,IAAI,KAAK,MAAM,GAAG;AACxC,QAAI,CAAC,YAAY,UAAU;AAAW;AAEtC,UAAM,qBAAqB,0BAA0B,SAAS,KAAK,CAAC;AACpE,aAAS,kBAAkB,IAAI,MAAM,KAAK;AAAA,EAC3C;AACA,SAAO;AACR;AApFA;AAsFA,IAAM,gBAAN,MAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqCnB,YAAY,SAAS,UAAU,OAAOC,MAAK;AAiC3C;AApEA;AAAA;AAGA;AAAA;AAGA;AAAA;AAGA;AAAA;AAGA;AAAA;AAGA;AAAA;AAGA;AAAA;AAGA;AAAA;AAGA;AAAA;AAGA;AAAA;AASC,uBAAK,WAAY;AACjB,uBAAK,QAAS;AACd,SAAK,SAAS;AACd,uBAAK,UAAW;AAChB,uBAAK,WAAYA;AACjB,uBAAK,gBAAiB;AACtB,uBAAK,UAAWA,OAAM,WAAW;AACjC,uBAAK,WAAY;AACjB,uBAAK,kBAAmB;AACxB,SAAK,WAAW;AAChB,QAAI,mBAAK,SAAQ;AAChB,UAAI,CAACA,MAAK;AACT,2BAAK,UAAL,WAAc,GAAG;AAAA,MAClB;AAAA,IACD;AAAA,EACD;AAAA,EAEA,QAAQ;AACP,SAAK,SAAS;AAAA,EACf;AAAA,EAEA,OAAO;AACN,SAAK,SAAS;AACd,QAAI,CAAC,uBAAuB,IAAI,IAAI,GAAG;AACtC,yBAAK,WAAY,IAAI,IAAI;AACzB,UAAI,oBAAoB,QAAW;AAClC,0BAAkB,IAAI,KAAK,UAAU;AAAA,MACtC;AACA,6BAAuB,IAAI,IAAI;AAAA,IAChC;AAAA,EACD;AAAA,EAYA,UAAU;AACT,QAAI,mBAAK,YAAW,GAAG;AACtB,4BAAK,sBAAL;AAAA,IACD,OAAO;AACN,yBAAK,gBAAiB,mBAAK;AAC3B,yBAAK,kBAAmB;AAAA,IACzB;AAAA,EACD;AAAA,EAEA,SAAS;AACR,UAAM,IAAI,mBAAK,aAAY,IAAI;AAC/B,2BAAuB,OAAO,IAAI;AAClC,uBAAK,UAAL,WAAc,GAAG,IAAI;AAAA,EACtB;AAAA,EAEA,SAAS;AACR,2BAAuB,OAAO,IAAI;AAClC,QAAI,KAAK,UAAU;AAClB,WAAK,SAAS;AAAA,IACf;AAAA,EACD;AAAA;AAAA,EAGA,QAAQ,MAAM;AACb,QAAI,OAAO,OAAO,mBAAK;AACvB,uBAAK,WAAY;AACjB,QAAI,mBAAK,oBAAmB,GAAG;AAC9B,YAAM,aAAa,mBAAK,oBAAmB;AAC3C,UAAI,SAAS,CAAC,mBAAK;AACnB,yBAAK,gBAAL,mBAAK,kBAAkB;AACvB,UAAI,mBAAK,kBAAiB,KAAK,cAAe,mBAAK,oBAAmB,KAAK,mBAAK,YAAY;AAC3F,cAAM,aAAa,aAAa,IAAI,CAAC,mBAAK;AAC1C,2BAAK,gBAAiB;AAEtB,YAAI,mBAAK,mBAAkB;AAC1B,6BAAK,kBAAmB;AACxB,gCAAK,sBAAL;AAAA,QACD,WAAW,eAAe,KAAK,mBAAK,YAAW;AAC9C,iBAAO;AAAA,QACR;AACA,iBAAS;AAAA,MACV,WAAW,mBAAK,oBAAmB,GAAG;AACrC,2BAAK,gBAAiB;AAAA,MACvB;AACA,UAAI,QAAQ;AACX;AAAA,MACD;AAAA,IACD;AACA,uBAAK,UAAL,mBAAK,aAAY,mBAAK,aAAY,CAAC,OAAO;AAC1C,QAAI,IAAI,mBAAK,YAAW,mBAAK;AAE7B,QAAI,IAAI,GAAG;AACV,UAAI;AAAA,IACL,WAAW,IAAI,GAAG;AACjB,UAAI;AAAA,IACL;AAEA,QAAK,mBAAK,cAAa,KAAK,KAAO,CAAC,mBAAK,cAAa,KAAK,GAAI;AAC9D,UAAI,mBAAK,aAAY,IAAI;AACzB,UAAI,mBAAK,oBAAmB,GAAG;AAC9B,+BAAuB,OAAO,IAAI;AAClC,YAAI,KAAK,UAAU;AAClB,eAAK,SAAS;AACd,eAAK,SAAS;AAAA,QACf;AAAA,MACD;AAAA,IACD;AACA,uBAAK,UAAL,WAAc,GAAG,IAAI;AAAA,EACtB;AACD;AAhJC;AAGA;AAGA;AAGA;AAGA;AAMA;AAGA;AAGA;AAyCA;AAAA,aAAQ,WAAG;AACV,qBAAK,WAAY,CAAC,mBAAK;AACvB,MAAI,KAAK,QAAQ;AAChB,QAAI,mBAAK,cAAa,GAAG;AACxB,yBAAK,UAAW,mBAAK;AAAA,IACtB;AACA,SAAK,KAAK;AAAA,EACX;AACD;AA0ED,SAAS,WAAW,MAAM;AACzB,aAAW,aAAa,wBAAwB;AAC/C,QAAI,CAAC,UAAU,QAAQ;AACtB,gBAAU,QAAQ,IAAI;AAAA,IACvB;AAAA,EACD;AACA,MAAI,uBAAuB,SAAS,GAAG;AACtC,sBAAkB,IAAI,KAAK,UAAU;AAAA,EACtC,OAAO;AACN,sBAAkB;AAAA,EACnB;AACD;AASA,SAAS,kBAAkB,KAAK,MAAM,WAAWC,SAAQ;AACxD,MAAI,iBAAiB;AAGrB,MAAI,OAAO,CAAC;AAGZ,MAAI,YAAY;AAChB,MAAI,YAAY;AAEhB,QAAM,mBAAmB,MAAM;AAC9B,QAAI;AAAA;AAAA,MAAiEC,YAAW;AAAA;AAChF,QAAI,OAAO,YAAY,YAAY;AAElC,gBAAU,QAAQ,EAAE,WAAW,eAAe,CAAC;AAAA,IAChD;AACA,UAAM,WAAW,QAAQ,YAAY;AACrC,UAAM,QAAQ,QAAQ,SAAS;AAC/B,UAAM,SAAS,QAAQ;AACvB,UAAM,UAAU,QAAQ;AAGxB,UAAM,SAAS,CAAC,MAAM;AACtB,UAAM,YAAY,QAAQ,UAAU;AAGpC,UAAM,YAAY,CAAC;AAEnB,QAAI,OAAO,YAAY,YAAY;AAClC,kBAAY,IAAI,cAAc,SAAS,UAAU,OAAO,cAAc,KAAK;AAAA,IAC5E,OAAO;AACN,UAAI,OAAO,WAAW,YAAY;AAEjC,cAAM,aAAa;AACnB,cAAM,eAAe,KAAK,IAAI,UAAU,UAAU;AAElD,iBAAS,IAAI,GAAG,KAAK,cAAc,KAAK,YAAY;AACnD,cAAI;AACJ,cAAI,IAAI,aAAa,cAAc;AAClC,mBAAO;AAAA,UACR,WAAW,MAAM,GAAG;AACnB,mBAAO;AAAA,UACR,OAAO;AACN,mBAAO,IAAI;AAAA,UACZ;AACA,gBAAM,IAAI,UAAU,IAAI;AACxB,oBAAU,KAAK,gBAAgB,OAAO,GAAG,IAAI,CAAC,CAAC,CAAC;AAAA,QACjD;AACA,YAAI,cAAc,OAAO;AACxB,oBAAU,QAAQ;AAAA,QACnB;AAAA,MACD;AACA,kBAAY,IAAI,QAAQ,WAAW;AAAA,QAClC;AAAA,QACA,UAAU;AAAA,QACV;AAAA,QACA,MAAM;AAAA,MACP,CAAC;AAAA,IACF;AACA,cAAU,MAAM;AAEhB,cAAU,WAAW,MAAM;AAC1B,YAAM,WAAW,mBAAmB;AACK,MAAC,UAAW,MAAM;AAC3D,UAAI,UAAU;AACb,mBAAW,OAAO,MAAM;AACvB,cAAI;AAAA,QACL;AACA,eAAO,CAAC;AAAA,MACT;AACA,qBAAe,KAAK,WAAW,aAAa,UAAU;AAAA,IACvD;AAAA,EACD;AAGA,QAAMA,cAAa;AAAA,IAClB,QAAAD;AAAA,IACA;AAAA,IACA,SAAS;AAAA;AAAA,IAGT,SAAS,IAAI;AACZ,WAAK,KAAK,EAAE;AAAA,IACb;AAAA,IACA,KAAK;AACJ,YAAM,gBAAgB,mBAAmB;AACzC,uBAAiB;AACjB,UAAI,cAAc,QAAQ,WAAW;AACpC,oBAAY;AACZ,yBAAiB;AAAA,MAClB;AACA,qBAAe,KAAK,YAAY;AAChC,UAAI,eAAe;AACuB,QAAC,UAAW,QAAQ;AAAA,MAC9D;AACyC,MAAC,UAAW,KAAK;AAAA,IAC3D;AAAA,IACA,MAAM;AACL,YAAM,gBAAgB,cAAc,UAAU,mBAAmB;AACjE,uBAAiB;AACjB,UAAI,cAAc,QAAQ,WAAW;AACpC,oBAAY;AACZ,yBAAiB;AAAA,MAClB;AACA,qBAAe,KAAK,YAAY;AAChC,UAAI,eAAe;AACuB,QAAC,UAAW,QAAQ;AAAA,MAC9D,OAAO;AACmC,QAAC,UAAW,KAAK;AAAA,MAC3D;AAAA,IACD;AAAA,IACA,SAAS;AACiC,MAAC,UAAW,OAAO;AAC5D,kBAAY;AAAA,IACb;AAAA,IACA,UAAU;AACT,iBAAW,OAAO,MAAM;AACvB,YAAI;AAAA,MACL;AACA,aAAO,CAAC;AAAA,IACT;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACA,SAAOC;AACR;AAMA,SAAS,oBAAoB,OAAO;AACnC,SACC,MAAM,SAAS,YACf,MAAM,SAAS,mBACf,MAAM,SAAS,aACf,MAAM,SAAS,eACf,MAAM,SAAS,2BACd,MAAM,SAAS,cAAc,MAAM,MAAM,WAAW;AAEvD;AAWO,SAAS,gBAAgB,KAAK,eAAe,UAAU,WAAW,QAAQ;AAChF,QAAM;AAAA;AAAA,IAAsE;AAAA;AAC5E,QAAM,QAAQ;AACd,QAAM,QAAQ,aAAa,OAAO,CAAC,IAAI,SAAS;AAEhD,MAAI,aAAa;AAGjB,MAAI,mBAAmB;AACvB,SAAO,qBAAqB,MAAM;AACjC,QAAI,oBAAoB,gBAAgB,GAAG;AAC1C,UAAI,iBAAiB,SAAS,iBAAiB;AAE9C,yBAAiB,aAAa;AAC9B,2BAAmB,iBAAiB;AAAA,MACrC,WAAW,iBAAiB,SAAS,eAAe,iBAAiB,SAAS;AAC7E,qBAAa;AAAA,MACd;AACA,UAAI,YAAY;AACf,qBAAa,iBAAiB,WAAW;AAAA,MAC1C;AACA,UAAI,CAAC,cAAc,CAAC,QAAQ;AAC3B;AAAA,MACD;AAAA,IACD,WACC,iBAAiB,SAAS,eACzB,iBAAiB,WAAW,QAAQ,iBAAiB,QACrD;AACD,mBAAa;AAAA,IACd;AACA,uBAAmB,iBAAiB;AAAA,EACrC;AAGA,MAAIA;AAEJ,SAAO,MAAM;AAEZ,UAAM,OAAO,CAAC,SACb;AAAA,MAAQ,MACP,cAAc;AAAA;AAAA,QACyC;AAAA,UACpD;AAAA,UACA,EAAE;AAAA;AAAA,YAA8B;AAAA,aAAO,IAAI,IAAI,sBAAsB,EAAE;AAAA,UACvE;AAAA,UACA,CAAC;AAAA,QACD;AAAA;AAAA;AAAA,QACuD,cAAe,KAAK,OAAO;AAAA,UAClF;AAAA,QACA,CAAC;AAAA;AAAA,IACL;AAED,IAAAA,cAAa,kBAAkB,KAAK,MAAM,WAAW,iBAAiB;AACtE,UAAM,WAAW,cAAc;AAC/B,UAAM,aAAa,CAAC,eAAe,YAAY,cAAc;AAE7D,QAAI,YAAY;AACf,MAAAA,YAAW,UAAUA,YAAW,KAAK;AAAA,IACtC;AAEA,UAAMD,UAAS,mBAAmB,MAAM;AACvC,qBAAeA,OAAM;AACrB,UAAI,QAAQ;AAEZ,UAAI,YAAY;AACf,QAAAC,YAAW,GAAG;AAAA,MACf;AAGA,UAAIC,oBAAmB;AACvB,aAAOA,sBAAqB,MAAM;AACjC,cAAM,SAASA,kBAAiB;AAChC,YAAI,oBAAoBA,iBAAgB,GAAG;AAC1C,cAAIA,kBAAiB,eAAe,MAAM;AACzC,YAAAA,kBAAiB,WAAWD,WAAU;AAAA,UACvC;AACA,cACC,WAAW,QACV,CAAC,WACAC,kBAAiB,SAAS,YAAY,OAAO,SAAS,YAAY,OAAO,UAC1E;AACD;AAAA,UACD;AAAA,QACD;AACA,QAAAA,oBAAmB;AAAA,MACpB;AAAA,IACD,GAAG,KAAK;AAAA,EACT,CAAC;AAED,MAAI,cAAc,OAAO;AACxB,WAAO,MAAM;AACZ,aAAO,MAAM;AACZ,QAAAD,YAAW,QAAQ;AAAA,MACpB;AAAA,IACD,CAAC;AAAA,EACF;AACD;AAKO,SAAS,sBAAsB,aAAa;AAClD,WAAS,SAAS,aAAa;AAC9B,QAAI,MAAM,cAAc,MAAM;AAC7B,kBAAY,OAAO,KAAK;AAAA,IACzB;AAAA,EACD;AACD;AAQO,SAAS,oBAAoB,aAAa,kBAAkB,MAAM;AAExE,QAAM,SAAS,CAAC;AAChB,aAAWA,eAAc,aAAa;AACrC,UAAM,YAAYA,YAAW;AAC7B,QAAI,qBAAqB,MAAM;AAC9B,UAAI,cAAc,QAAQ,cAAc,QAAQ;AAC/C,QAAAA,YAAW,GAAG;AAAA,MACf,OAAO;AACN,QAAAA,YAAW,OAAO;AAAA,MACnB;AACA,MAAAA,YAAW,IAAI,QAAQ;AACvB,yBAAmBA,YAAW,QAAQ,KAAK;AAAA,IAC5C,WAAW,qBAAqB,OAAO;AACtC,UAAI,cAAc,OAAO;AACxB,QAAAA,YAAW,UAAUA,YAAW;AAAA;AAAA,UAA6B;AAAA,QAAK;AAClE,QAAAA,YAAW,GAAG;AAAA,MACf;AAAA,IACD,OAAO;AACN,UAAI,cAAc,SAAS,cAAc,QAAQ;AAChD,QAAAA,YAAW,UAAUA,YAAW,KAAK;AACrC,eAAO,KAAKA,YAAW,GAAG;AAAA,MAC3B;AACA,MAAAA,YAAW,IAAI,QAAQ;AACvB,yBAAmBA,YAAW,QAAQ,IAAI;AAAA,IAC3C;AAAA,EACD;AACA,MAAI,OAAO,SAAS,GAAG;AAEtB,UAAM,IAAI,mBAAmB,MAAM;AAClC,qBAAe,CAAC;AAChB,YAAM,KAAK,eAAe,MAAM;AAC/B,uBAAe,EAAE;AACjB,eAAO;AAAA;AAAA,UAA8B,CAAC,MAAM,EAAE;AAAA,QAAC;AAAA,MAChD,CAAC;AAAA,IACF,GAAG,KAAK;AAAA,EACT;AACD;AAOA,SAAS,qBAAqBA,aAAY;AACzC,QAAM,QAAQ;AACd,QAAM,aAAa,MAAM;AACzB,QAAM,iBAAiB,WAAW,QAAQ,wBAAwB;AAElE,MAAI,eAAe;AAClB,UAAM,SAAS,MAAM;AACrB,eAAW,SAAS;AACpB;AAAA;AAAA,MAAqC,WAAW;AAAA,MAAS;AAAA,IAAM;AAC/D,eAAW,SAAS;AAAA,EACrB;AACA,MAAIA,YAAW,cAAc,UAAU,WAAW,QAAQ,sBAAsB,GAAG;AAClF,eAAW,SAAS;AAAA,EACrB;AACA,MAAI,cAAc,MAAM;AACxB,MAAI,gBAAgB,MAAM;AACzB,UAAM,cAAc,cAAc,oBAAI,IAAI;AAAA,EAC3C;AACA,EAAAA,YAAW,SAAS,MAAM;AACzB,QAAI,gBAAgB,MAAM;AACzB,kBAAY,OAAOA,WAAU;AAC7B,UAAIA,YAAW,cAAc,OAAO;AACnC,iBAAS,SAAS,aAAa;AAC9B,cAAI,MAAM,cAAc,SAAS,MAAM,cAAc,MAAM;AAC1D,wBAAY,OAAO,KAAK;AAAA,UACzB;AAAA,QACD;AACA,YAAI,YAAY,SAAS,GAAG;AAC3B,gBAAM,cAAc;AACpB,kCAAwB,OAAO,MAAM,IAAI;AAAA,QAC1C;AAAA,MACD;AAAA,IACD;AAAA,EACD,CAAC;AACD,cAAY,IAAIA,WAAU;AAC3B;;;AChhBA,IAAM,uBAAuB,oBAAI,IAAI;AAGrC,IAAM,qBAAqB,oBAAI,IAAI;AAG5B,SAAS,QAAQ;AACvB,SAAO,SAAS,eAAe,EAAE;AAClC;AAQO,SAAS,SAASE,OAAM,aAAa;AAE3C,MAAI;AACJ,SAAO,MAAM;AACZ,QAAI,mBAAmB,QAAW;AACjC,YAAM,UAAU,0BAA0BA,KAAI;AAC9C,uBAAiB,cAAc;AAAA;AAAA,QAA+B,MAAM,OAAO;AAAA;AAAA,IAC5E;AACA,WAAO;AAAA,EACR;AACD;AAQO,SAAS,aAAa,KAAK,aAAa;AAE9C,MAAI;AACJ,SAAO,MAAM;AACZ,QAAI,mBAAmB,QAAW;AACjC,YAAM;AAAA;AAAA,QAA+B,MAAM,0BAA0B,QAAQ,GAAG,QAAQ,CAAC;AAAA;AACzF,uBAAiB,cAAc;AAAA;AAAA,QAA+B,MAAM,OAAO;AAAA;AAAA,IAC5E;AACA,WAAO;AAAA,EACR;AACD;AAMO,SAAS,YAAY,MAAM;AACjC,QAAM;AAAA;AAAA,IAAsC,KAAK;AAAA;AACjD,OAAK,YAAY,WAAW;AAC5B,SAAO;AACR;AASA,SAAS,cAAc,aAAa,gBAAgB,QAAQ,qBAAqB;AAChF,MAAI,+BAA+B,MAAM;AACxC,QAAI,WAAW,MAAM;AACpB,2BAAqB,QAAQ,KAAK;AAAA,IACnC;AAGA,UAAM,WAAW;AACjB,QAAI,aAAa,MAAM;AACtB,aAAO,cAAc;AAAA;AAAA,QAAmC,SAAS,CAAC;AAAA;AAAA,IACnE;AAAA,EACD;AACA,SAAO,iBACJ;AAAA;AAAA,IAAyC,oBAAqB;AAAA,IAAG;AAAA,EAAI,IACrE,SAAS;AAAA;AAAA,IAAyC,oBAAqB;AAAA,IAAG;AAAA,EAAI;AAClF;AASO,SAAS,KAAK,QAAQ,gBAAgB,qBAAqB;AACjE,SAAO,cAAc,OAAO,gBAAgB,QAAQ,mBAAmB;AACxE;AASO,SAAS,UAAU,QAAQ,gBAAgB,qBAAqB;AACtE,SAAO,cAAc,MAAM,gBAAgB,QAAQ,mBAAmB;AACvE;AAQA,SAAS,eAAe,KAAK,aAAa,QAAQ;AACjD,QAAM;AAAA;AAAA,IAAmD;AAAA;AAGzD,QAAM,UAAU,cACb,SAAS,GAAG,IACX;AAAA;AAAA,IACoD,MAAM,KAAK,IAAI,UAAU;AAAA,MAC9E;AACH,MAAI,WAAW,QAAQ,+BAA+B,MAAM;AAC3D,WAAO,SAAS,MAAM,MAAM;AAAA,EAC7B;AACA,QAAM,MAAM;AACb;AAOO,SAAS,MAAM,QAAQ,KAAK;AAClC,iBAAe,KAAK,OAAO,MAAM;AAClC;AAOO,SAAS,WAAW,QAAQ,KAAK;AACvC,iBAAe,KAAK,MAAM,MAAM;AACjC;AAMO,SAAS,QAAQ,IAAI;AAC3B,SAAO,YAAa,MAAM;AACzB,UAAMC;AAAA;AAAA,MAA8B,KAAK,CAAC;AAAA;AAC1C,QAAIA,OAAM,WAAW;AAEpB,aAAO,EAAE,EAAE,MAAM,MAAM,IAAI;AAAA,IAC5B;AAAA,EACD;AACD;AAMO,SAAS,KAAK,IAAI;AACxB,SAAO,YAAa,MAAM;AACzB,UAAMA;AAAA;AAAA,MAA8B,KAAK,CAAC;AAAA;AAE1C,QAAIA,OAAM,WAAW,MAAM;AAE1B,aAAO,EAAE,EAAE,MAAM,MAAM,IAAI;AAAA,IAC5B;AAAA,EACD;AACD;AAMO,SAAS,gBAAgB,IAAI;AACnC,SAAO,YAAa,MAAM;AACzB,UAAMA;AAAA;AAAA,MAA8B,KAAK,CAAC;AAAA;AAC1C,IAAAA,OAAM,gBAAgB;AAEtB,WAAO,OAAO,EAAE,EAAE,MAAM,MAAM,IAAI;AAAA,EACnC;AACD;AAMO,SAAS,KAAK,IAAI;AACxB,MAAI,MAAM;AACV,SAAO,YAAa,MAAM;AACzB,QAAI,KAAK;AACR;AAAA,IACD;AACA,UAAM;AAEN,WAAO,OAAO,EAAE,EAAE,MAAM,MAAM,IAAI;AAAA,EACnC;AACD;AAMO,SAAS,yBAAyB,IAAI;AAC5C,SAAO,YAAa,MAAM;AACzB,UAAMA;AAAA;AAAA,MAA8B,KAAK,CAAC;AAAA;AAC1C,IAAAA,OAAM,yBAAyB;AAE/B,WAAO,OAAO,EAAE,EAAE,MAAM,MAAM,IAAI;AAAA,EACnC;AACD;AAMO,SAAS,eAAe,IAAI;AAClC,SAAO,YAAa,MAAM;AACzB,UAAMA;AAAA;AAAA,MAA8B,KAAK,CAAC;AAAA;AAC1C,IAAAA,OAAM,eAAe;AAErB,WAAO,OAAO,EAAE,EAAE,MAAM,MAAM,IAAI;AAAA,EACnC;AACD;AAUO,SAAS,MAAM,YAAY,KAAK,SAAS,SAAS,SAAS;AACjE,QAAM,UAAU;AAAA,IACf;AAAA,IACA;AAAA,EACD;AACA,QAAM,iBAAiB;AACvB,MAAI,iBAAiB,YAAY,gBAAgB,OAAO;AAExD,MAAI,QAAQ,SAAS,QAAQ,QAAQ,UAAU,QAAQ,UAAU;AAChE,kBAAc,MAAM;AACnB,aAAO,MAAM;AACZ,YAAI,oBAAoB,YAAY,gBAAgB,OAAO;AAAA,MAC5D;AAAA,IACD,CAAC;AAAA,EACF;AACD;AAOO,SAAS,kBAAkB,KAAK,OAAO;AAC7C,gBAAc,MAAM;AACnB,UAAM,SAAS,MAAM;AACrB,eAAW,KAAK,MAAM;AAAA,EACvB,CAAC;AACF;AAOO,SAAS,WAAW,KAAK,OAAO;AAEtC,QAAM,kBAAkB,IAAI;AAC5B,QAAM,kBAAkB,SAAS,KAAK;AACtC,QAAM,eAAe,+BAA+B;AACpD,MAAI,gBAAgB,IAAI,cAAc,iBAAiB;AAGtD,QAAI,cAAc;AAAA,EACnB,WACC,oBAAoB,mBACnB,gBAAgB,IAAI,cAAc,iBAClC;AACD,QAAI,oBAAoB,IAAI;AAC3B,UAAI,gBAAgB,OAAO;AAAA,IAC5B,OAAO;AACN,qBAAe,KAAK,eAAe;AAAA,IACpC;AAEA,QAAI,cAAc;AAAA,EACnB;AACD;AAOO,SAAS,YAAY,KAAK,OAAO;AACvC,gBAAc,MAAM;AACnB,UAAM,SAAS,MAAM;AACrB,SAAK,KAAK,MAAM;AAAA,EACjB,CAAC;AACF;AAOO,SAAS,KAAK,KAAK,OAAO;AAEhC,QAAM,kBAAkB,IAAI;AAC5B,QAAM,kBAAkB,UAAU,KAAK;AACvC,MAAI,+BAA+B,QAAQ,IAAI,cAAc,iBAAiB;AAG7E,QAAI,cAAc;AAAA,EACnB,WAAW,oBAAoB,iBAAiB;AAC/C,QAAI,YAAY;AAEhB,QAAI,cAAc;AAAA,EACnB;AACD;AAOO,SAAS,WAAW,KAAK,OAAO;AACtC,MAAI,OAAO;AACV,UAAM,OAAO,SAAS;AACtB,QAAI,YAAY;AAChB;AAAA,MACC,MAAM;AACL,YAAI,SAAS,kBAAkB,MAAM;AACpC,cAAI,MAAM;AAAA,QACX;AAAA,MACD;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACD;AAAA,EACD;AACD;AAOO,SAAS,SAAS,OAAO;AAC/B,SAAO,SAAS,OAAO,KAAK;AAC7B;AAQO,SAAS,aAAa,KAAKC,aAAY,OAAO;AACpD,MAAI,OAAO;AACV,QAAI,UAAU,IAAIA,WAAU;AAAA,EAC7B,OAAO;AACN,QAAI,UAAU,OAAOA,WAAU;AAAA,EAChC;AACD;AAOO,SAAS,cAAc,QAAQ,OAAO;AAC5C,MAAI,OAAO,UAAU;AACpB,WAAO,eAAe,QAAQ,KAAK;AAAA,EACpC;AACA,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,QAAQ,KAAK,GAAG;AAClD,UAAM,SAAS,OAAO,QAAQ,CAAC;AAC/B,UAAM,eAAe,iBAAiB,MAAM;AAC5C,QAAI,iBAAiB,OAAO;AAC3B,aAAO,WAAW;AAClB;AAAA,IACD;AAAA,EACD;AACA,SAAO,QAAQ;AAChB;AAOA,SAAS,eAAe,QAAQ,OAAO;AACtC,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,QAAQ,KAAK,GAAG;AAClD,UAAM,SAAS,OAAO,QAAQ,CAAC;AAE/B,WAAO,WAAW,CAAC,MAAM,QAAQ,iBAAiB,MAAM,CAAC;AAAA,EAC1D;AACD;AAGA,SAAS,iBAAiB,QAAQ;AAEjC,MAAI,aAAa,QAAQ;AACxB,WAAO,OAAO;AAAA,EACf,OAAO;AACN,WAAO,OAAO;AAAA,EACf;AACD;AAMO,SAAS,YAAY,QAAQ;AACnC,QAAM,iBAAiB,MAAM;AAC5B,WAAO,UAAU,MAAM;AAAA,EACxB;AACA,mBAAiB,QAAQ,CAAC,UAAU,SAAS,GAAG,cAAc;AAC/D;AAGA,SAAS,qBAAqB,QAAQ;AACrC,QAAM,QAAQ,CAAC;AACf,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK,GAAG;AAC1C,UAAM,KAAK,EAAE,OAAO,OAAO,MAAM,CAAC,GAAG,KAAK,OAAO,IAAI,CAAC,EAAE,CAAC;AAAA,EAC1D;AACA,SAAO;AACR;AAQO,SAAS,kBAAkB,OAAO,WAAW,QAAQ;AAE3D,MAAI;AACJ,MAAI,WAAW;AAIf,QAAM,WAAW,MAAM;AACtB,yBAAqB,MAAM;AAC3B,QAAI,CAAC,MAAM,QAAQ;AAClB,eAAS,sBAAsB,QAAQ;AAAA,IACxC;AACA,eAAW;AACX,WAAO,MAAM,WAAW;AAAA,EACzB;AACA,WAAS,sBAAsB,QAAQ;AACvC,QAAM,iBAAiB,cAAc,QAAQ;AAC7C,gBAAc,MAAM;AACnB,UAAM,QAAQ,UAAU;AAExB,QAAI,CAAC,YAAY,CAAC;AAAA;AAAA,MAA0B;AAAA,IAAM,GAAG;AACpD,YAAM;AAAA,MAAqC;AAAA,IAC5C;AACA,eAAW;AAAA,EACZ,CAAC;AACD,gBAAc,MAAM,MAAM,qBAAqB,MAAM,CAAC;AACvD;AAMO,SAAS,cAAc,OAAO,QAAQ;AAC5C,QAAM,WAAW,MAAM;AACtB,WAAO,qBAAqB,MAAM,QAAQ,CAAC;AAAA,EAC5C;AACA,mBAAiB,OAAO,CAAC,kBAAkB,UAAU,GAAG,QAAQ;AACjE;AAMO,SAAS,cAAc,OAAO,QAAQ;AAC5C,QAAM,WAAW,MAAM;AACtB,WAAO,qBAAqB,MAAM,QAAQ,CAAC;AAAA,EAC5C;AACA,mBAAiB,OAAO,CAAC,gBAAgB,GAAG,QAAQ;AACrD;AAMO,SAAS,YAAY,OAAO,QAAQ;AAC1C,QAAM,WAAW,MAAM;AACtB,WAAO,qBAAqB,MAAM,MAAM,CAAC;AAAA,EAC1C;AACA,mBAAiB,OAAO,CAAC,YAAY,GAAG,QAAQ;AACjD;AAMO,SAAS,aAAa,OAAO,QAAQ;AAC3C,QAAM,WAAW,MAAM;AACtB,WAAO,MAAM,OAAO;AAAA,EACrB;AACA,mBAAiB,OAAO,CAAC,WAAW,QAAQ,GAAG,QAAQ;AACxD;AAMO,SAAS,WAAW,OAAO,QAAQ;AACzC,QAAM,WAAW,MAAM;AACtB,WAAO,MAAM,KAAK;AAAA,EACnB;AACA,mBAAiB,OAAO,CAAC,cAAc,OAAO,GAAG,QAAQ;AAC1D;AAMO,SAAS,iBAAiB,OAAO,QAAQ;AAC/C,QAAM,WAAW,MAAM;AACtB,WAAO,MAAM,UAAU;AAAA,EACxB;AACA;AAAA,IACC;AAAA,IACA,CAAC,kBAAkB,cAAc,WAAW,kBAAkB,WAAW,WAAW,SAAS;AAAA,IAC7F;AAAA,EACD;AACD;AAOO,SAAS,mBAAmB,OAAO,WAAW,QAAQ;AAC5D,MAAI,WAAW;AACf,QAAM,WAAW,MAAM;AACtB,QAAI,CAAC,UAAU;AACd,aAAO,MAAM,YAAY;AAAA,IAC1B;AACA,eAAW;AAAA,EACZ;AAKA,MAAI;AACJ,MAAI,YAAY;AAChB,QAAMC,UAAS,eAAe,MAAM;AACnC,mBAAeA,OAAM;AACrB,QAAI;AAAW;AACf,QAAI,UAAU,KAAK,MAAM;AACxB,eAAS;AAAA,IACV;AACA,qBAAiB,OAAO,CAAC,YAAY,GAAG,UAAU,KAAK;AACvD,aAAS,cAAc,MAAM;AAC5B,YAAM,QAAQ,UAAU;AAExB,UAAI,CAAC;AAAA;AAAA,QAA0B;AAAA,MAAM,KAAK,UAAU,MAAM,cAAc;AACvE,mBAAW;AACX,cAAM;AAAA,QAAsC;AAAA,MAC7C;AAAA,IACD,CAAC;AAAA,EACF,CAAC;AACD,gBAAc,MAAM,MAAM;AACzB,gBAAY;AACZ,QAAI,QAAQ;AACX,qBAAe,MAAM;AAAA,IACtB;AAAA,EACD,CAAC;AACF;AAOO,SAAS,YAAY,OAAO,WAAW,QAAQ;AACrD,MAAI,UAAU,+BAA+B;AAC7C,MAAI,SAAS,UAAU;AACvB,QAAM,WAAW,MAAM;AACtB,QAAI,WAAW,MAAM,QAAQ;AAC5B,eAAS,MAAM;AACf,aAAQ,SAAS,MAAM,MAAO;AAAA,IAC/B;AAAA,EACD;AACA,MAAI,UAAU,MAAM;AACnB,aAAS;AAAA,EACV;AAEA,MAAI,SAAS;AAGZ,qBAAiB,OAAO,CAAC,QAAQ,SAAS,SAAS,GAAG,UAAU,KAAK;AAAA,EACtE;AACA,gBAAc,MAAM;AACnB,aAAS,CAAC,CAAC,UAAU;AACrB,QAAI,WAAW,MAAM,QAAQ;AAC5B,YAAM,SAAS,MAAM;AACpB,kBAAU;AACV,YAAI,QAAQ;AACX,gBAAM,MAAM;AAAA,QACb,OAAO;AACN,gBAAM,KAAK,EAAE,MAAM,MAAM;AACxB,mBAAQ,SAAS,IAAK;AAAA,UACvB,CAAC;AAAA,QACF;AAAA,MACD;AACA,UAAI,SAAS;AACZ,eAAO;AAAA,MACR,OAAO;AAIN,cAAM;AAAA,UACL;AAAA,UACA,MAAM;AACL,6BAAiB,OAAO,CAAC,QAAQ,SAAS,SAAS,GAAG,UAAU,KAAK;AACrE,mBAAO;AAAA,UACR;AAAA,UACA,EAAE,MAAM,KAAK;AAAA,QACd;AAAA,MACD;AAAA,IACD;AAAA,EACD,CAAC;AACF;AAOO,SAAS,YAAY,OAAO,WAAW,QAAQ;AACrD,MAAI,WAAW;AACf,QAAM,WAAW,MAAM;AACtB,eAAW;AACX,WAAO,MAAM,MAAM;AAAA,EACpB;AACA,MAAI,UAAU,KAAK,MAAM;AACxB,aAAS;AAAA,EACV;AACA,mBAAiB,OAAO,CAAC,cAAc,GAAG,UAAU,KAAK;AACzD,gBAAc,MAAM;AACnB,UAAM,QAAQ,UAAU;AAExB,QAAI,CAAC,YAAY,CAAC;AAAA;AAAA,MAA0B;AAAA,IAAM,GAAG;AACpD,YAAM;AAAA,MAAgC;AAAA,IACvC;AACA,eAAW;AAAA,EACZ,CAAC;AACF;AAOO,SAAS,WAAW,OAAO,WAAW,QAAQ;AACpD,MAAI,WAAW;AACf,QAAM,WAAW,MAAM;AACtB,eAAW;AACX,WAAO,MAAM,KAAK;AAAA,EACnB;AACA,MAAI,UAAU,KAAK,MAAM;AACxB,aAAS;AAAA,EACV;AACA,mBAAiB,OAAO,CAAC,cAAc,GAAG,UAAU,KAAK;AACzD,gBAAc,MAAM;AACnB,UAAM,QAAQ,UAAU;AACxB,QAAI,CAAC,UAAU;AACd,YAAM,QAAQ,CAAC,CAAC;AAAA,IACjB;AACA,eAAW;AAAA,EACZ,CAAC;AACF;AASA,SAAS,iBAAiB,KAAK,QAAQ,SAAS,2BAA2B,MAAM;AAChF,MAAI,0BAA0B;AAC7B,YAAQ;AAAA,EACT;AACA,aAAW,QAAQ,QAAQ;AAC1B,QAAI,iBAAiB,MAAM,OAAO;AAAA,EACnC;AACA,gBAAc,MAAM;AACnB,WAAO,MAAM;AACZ,iBAAW,QAAQ,QAAQ;AAC1B,YAAI,oBAAoB,MAAM,OAAO;AAAA,MACtC;AAAA,IACD;AAAA,EACD,CAAC;AACF;AAzwBA;AA+wBA,IAAM,2BAAN,MAAM,yBAAwB;AAAA;AAAA,EAc7B,YAAY,SAAS;AAsBrB;AAlCA;AAAA,mCAAa,oBAAI,QAAQ;AAGzB;AAAA;AAGA;AAAA;AAOC,uBAAK,UAAW;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,QAAQC,UAAS,UAAU;AAC1B,UAAM,YAAY,mBAAK,YAAW,IAAIA,QAAO,KAAK,oBAAI,IAAI;AAC1D,cAAU,IAAI,QAAQ;AACtB,uBAAK,YAAW,IAAIA,UAAS,SAAS;AACtC,0BAAK,8BAAL,WAAoB,QAAQA,UAAS,mBAAK,SAAQ;AAClD,WAAO,MAAM;AACZ,YAAMC,aAAY,mBAAK,YAAW,IAAID,QAAO;AAC7C,MAAAC,WAAU,OAAO,QAAQ;AACzB,UAAIA,WAAU,SAAS,GAAG;AACzB,2BAAK,YAAW,OAAOD,QAAO;AACA,QAAC,mBAAK,WAAW,UAAUA,QAAO;AAAA,MACjE;AAAA,IACD;AAAA,EACD;AAgBD;AAjDC;AAGA;AAGA;AA4BA;AAAA,iBAAY,WAAG;AACd,SACC,mBAAK,cACJ,mBAAK,WAAY,IAAI;AAAA;AAAA,IACO,CAAC,YAAY;AACxC,iBAAW,SAAS,SAAS;AAC5B,iCAAwB,QAAQ,IAAI,MAAM,QAAQ,KAAK;AACvD,mBAAW,YAAY,mBAAK,YAAW,IAAI,MAAM,MAAM,KAAK,CAAC,GAAG;AAC/D,mBAAS,KAAK;AAAA,QACf;AAAA,MACD;AAAA,IACD;AAAA,EACD;AAEF;AAAA;AAvCA,cAXK,0BAWE,WAAU,oBAAI,QAAQ;AAX9B,IAAM,0BAAN;AAoDA,IAAM,8BAA8C,IAAI,wBAAwB;AAAA,EAC/E,KAAK;AACN,CAAC;AACD,IAAM,6BAA6C,IAAI,wBAAwB;AAAA,EAC9E,KAAK;AACN,CAAC;AACD,IAAM,2CAA2D,IAAI,wBAAwB;AAAA,EAC5F,KAAK;AACN,CAAC;AAOM,SAAS,qBAAqB,KAAK,MAAM,QAAQ;AACvD,QAAM,WACL,SAAS,iBAAiB,SAAS,mBAChC,8BACA,SAAS,kBACT,6BACA;AACJ,QAAM,QAAQ,SAAS;AAAA,IAAQ;AAAA;AAAA,IAA+B,CAAC,UAAU,OAAO,MAAM,IAAI,CAAC;AAAA,EAAC;AAC5F,gBAAc,MAAM,KAAK;AAC1B;AAOO,SAAS,kBAAkB,KAAK,MAAM,QAAQ;AAGpD,wBAAsB,MAAM,sBAAsB,MAAM,OAAO,IAAI,IAAI,CAAC,CAAC,CAAC;AAC1E,QAAM,QAAQ,2BAA2B,QAAQ,KAAK,MAAM,OAAO,IAAI,IAAI,CAAC,CAAC;AAC7E,gBAAc,MAAM,KAAK;AAC1B;AAMO,SAAS,iBAAiB,MAAM,QAAQ;AAC9C,QAAM,WAAW,MAAM,OAAO,OAAO,IAAI,CAAC;AAC1C,mBAAiB,QAAQ,CAAC,QAAQ,GAAG,QAAQ;AAC9C;AAOO,SAAS,SAAS,KAAK;AAG7B,SAAO,MAAM;AACZ,QAAI,SAAS,IAAI;AACjB,WAAO,UAAU,MAAM;AACtB,UAAI,OAAO,aAAa,UAAU;AACjC;AAAA,MACD;AACA,eAAS,OAAO;AAAA,IACjB;AACA,QAAI,UAAU,MAAM;AAEnB,YAAM,eAAe,OAAO;AAE5B,YAAM,eAAe,IAAI;AACzB,YAAME,YAAW,iBAAiB;AAClC,UAAI,WAAWA;AACf,UAAI,QAAQ;AAIZ,UAAI,OAAO,YAAY,MAAM;AACK,QAAC,OAAQ,QAAQ;AAAA,MACnD;AAAA,IACD;AAAA,EACD,CAAC;AACF;AAQO,SAAS,WAAW,KAAK,WAAW,QAAQ;AAClD,MAAI,iBAAiB,SAAS,MAAM;AAEnC,QAAI,QAAQ,IAAI;AAEhB,UAAM,OAAO,IAAI;AACjB,QAAI,SAAS,YAAY,SAAS,SAAS;AAC1C,cAAQ,UAAU,KAAK,OAAO,CAAC;AAAA,IAChC;AACA,WAAO,KAAK;AAAA,EACb,CAAC;AACD,gBAAc,MAAM;AACnB,UAAM,QAAQ,UAAU;AACxB,UAAM,gBAAgB,SAAS,OAAO,OAAO,QAAQ;AAErD,QAAI,QAAQ;AAEZ,QAAI,UAAU;AAAA,EACf,CAAC;AACF;AAQO,SAAS,kBAAkB,KAAK,WAAW,QAAQ;AACzD,MAAI,UAAU;AACd,MAAI,iBAAiB,UAAU,MAAM;AAEpC,QAAI;AACJ,QAAI,IAAI,UAAU;AACjB,cAAQ,CAAC,EAAE,IAAI,KAAK,IAAI,iBAAiB,UAAU,GAAG,gBAAgB;AAAA,IACvE,OAAO;AAEN,YAAM,kBAAkB,IAAI,cAAc,UAAU;AACpD,cAAQ,mBAAmB,iBAAiB,eAAe;AAAA,IAC5D;AACA,WAAO,KAAK;AAAA,EACb,CAAC;AAED,SAAO,MAAM;AACZ,UAAM,QAAQ,UAAU;AACxB,QAAI,SAAS,QAAQ,CAAC,SAAS;AAE9B,UAAI,kBAAkB,UAAU,SAAY,IAAI,cAAc,UAAU,IAAI;AAC5E,UAAI,oBAAoB,MAAM;AAC7B,YAAI,QAAQ;AAEZ,YAAI,UAAU;AAAA,MACf;AACA,YAAM,UAAU,IAAI,iBAAiB,QAAQ;AAC7C,iBAAW,UAAU,SAAS;AAC7B,YAAI,iBAAiB,MAAM,MAAM,SAAS,OAAO,aAAa,UAAU,GAAG;AAC1E,cAAI,OAAO,UAAU;AACpB,mBAAO,QAAQ;AAAA,UAChB;AACA,iBAAO,WAAW;AAClB,4BAAkB;AAClB;AAAA,QACD;AAAA,MACD;AACA,UAAI,mBAAmB,MAAM;AAC5B,cAAM,iBAAiB,iBAAiB,eAAe;AACvD,eAAO,cAAc;AACrB,YAAI,gBAAgB,aAAa,UAAU,GAAG;AAC7C,0BAAgB,gBAAgB,UAAU;AAC1C,0BAAgB,WAAW;AAAA,QAC5B;AAAA,MACD;AAAA,IACD,OAAO;AACN,oBAAc,KAAK,KAAK;AAExB,UAAI,UAAU;AAAA,IACf;AACA,cAAU;AAAA,EACX,CAAC;AACF;AASO,SAAS,sBAAsB,UAAU,KAAK,WAAW,QAAQ;AACvE,MAAI,iBAAiB,SAAS,MAAM;AAEnC,UAAM,QAAQ,IAAI,QAAQ;AAC1B,WAAO,KAAK;AAAA,EACb,CAAC;AACD,gBAAc,MAAM;AACnB,UAAM,QAAQ,UAAU;AACxB,QAAI,IAAI,QAAQ,MAAM,OAAO;AAC5B,UAAI,UAAU,MAAM;AAEnB,cAAM,iBAAiB,IAAI,QAAQ;AACnC,eAAO,cAAc;AAAA,MACtB,OAAO;AAEN,YAAI,QAAQ,IAAI,QAAQ;AAAA,MACzB;AAAA,IACD;AAAA,EACD,CAAC;AACF;AASA,SAAS,wBAAwB,OAAO,SAAS,SAAS;AACzD,QAAM,QAAQ,oBAAI,IAAI;AACtB,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK,GAAG;AACzC,QAAI,MAAM,CAAC,EAAE,SAAS;AAErB,YAAM,IAAI,MAAM,CAAC,EAAE,OAAO;AAAA,IAC3B;AAAA,EACD;AACA,MAAI,CAAC,SAAS;AACb,UAAM,OAAO,OAAO;AAAA,EACrB;AACA,SAAO,MAAM,KAAK,KAAK;AACxB;AAUO,SAAS,WAAW,OAAO,aAAa,KAAK,WAAW,QAAQ;AACtE,QAAM,cAAc,IAAI,aAAa,MAAM,MAAM;AACjD,MAAI,gBAAgB;AACpB,MAAI,gBAAgB,MAAM;AACzB,eAAW,SAAS,aAAa;AAChC,YAAMC,SAAQ;AAEd,sBAAgBA,OAAM,KAAK;AAC3B,UAAI,kBAAkB,QAAW;AAEhC,wBAAgBA,OAAM,KAAK,IAAI,CAAC;AAAA,MACjC;AAAA,IACD;AAAA,EACD;AACA,gBAAc,KAAK,GAAG;AACtB,MAAI,iBAAiB,UAAU,MAAM;AAEpC,QAAI,QAAQ,IAAI;AAChB,QAAI,aAAa;AAChB,cAAQ,wBAAwB,eAAe,OAAO,IAAI,OAAO;AAAA,IAClE;AACA,WAAO,KAAK;AAAA,EACb,CAAC;AACD,gBAAc,MAAM;AACnB,QAAI,QAAQ,UAAU;AACtB,QAAI,aAAa;AAChB,cAAQ,SAAS,CAAC;AAElB,UAAI,UAAU,MAAM,SAAS,IAAI,OAAO;AAAA,IACzC,OAAO;AAEN,UAAI,UAAU,IAAI,YAAY;AAAA,IAC/B;AAAA,EACD,CAAC;AACD,gBAAc,MAAM;AACnB,WAAO,MAAM;AACZ,YAAM,QAAQ,cAAc,QAAQ,GAAG;AACvC,UAAI,UAAU,IAAI;AACjB,sBAAc,OAAO,OAAO,CAAC;AAAA,MAC9B;AAAA,IACD;AAAA,EACD,CAAC;AACF;AAQO,SAAS,aAAa,KAAK,WAAW,QAAQ;AACpD,MAAI,iBAAiB,UAAU,MAAM;AACpC,UAAM,QAAQ,IAAI;AAClB,WAAO,KAAK;AAAA,EACb,CAAC;AAED,MAAI,UAAU,KAAK,QAAW;AAC7B,WAAO,KAAK;AAAA,EACb;AACA,gBAAc,MAAM;AACnB,UAAM,QAAQ,UAAU;AACxB,QAAI,UAAU,QAAQ,KAAK;AAAA,EAC5B,CAAC;AACF;AAQO,SAAS,mBAAmB,MAAM,WAAW,QAAQ;AAC3D,QAAM,iBAAiB,SAAS;AAChC,QAAM,iBAAiB,MAAM;AAC5B,gBAAY;AACZ,iBAAa,OAAO;AACpB,cAAU,WAAW,OAAO,GAAG;AAC/B,UAAM,QAAQ,OAAO,iBAAiB,YAAY,SAAS;AAC3D,WAAO,KAAK;AAAA,EACb;AACA,mBAAiB,UAAU,gBAAgB;AAAA,IAC1C,SAAS;AAAA,EACV,CAAC;AACD,MAAI,eAAe;AACnB,MAAI,YAAY;AAGhB,MAAI;AACJ,QAAM,QAAQ,MAAM;AACnB,gBAAY;AAAA,EACb;AACA,gBAAc,MAAM;AACnB,mBAAe,UAAU,KAAK;AAC9B,QAAI,CAAC,WAAW;AACf,kBAAY;AACZ,mBAAa,OAAO;AACpB,UAAI,gBAAgB;AACnB,iBAAS,cAAc,OAAO,OAAO;AAAA,MACtC,OAAO;AACN,iBAAS,OAAO,SAAS,YAAY;AAAA,MACtC;AACA,gBAAU,WAAW,OAAO,GAAG;AAAA,IAChC;AAAA,EACD,CAAC;AACD,gBAAc,MAAM;AACnB,WAAO,MAAM;AACZ,0BAAoB,UAAU,cAAc;AAAA,IAC7C;AAAA,EACD,CAAC;AACF;AAWO,SAAS,cAAc,UAAU,YAAY,MAAM,KAAK,WAAW,QAAQ;AACjF,QAAM,iBAAiB,MAAM;AAE5B,UAAM,QAAQ,IAAI,QAAQ;AAC1B,WAAO,KAAK;AAAA,EACb;AACA,MAAI,iBAAiB,YAAY,cAAc;AAC/C,MAAI,SAAS,OAAO;AACnB,kBAAc,MAAM;AACnB,YAAM,QAAQ,UAAU;AAExB,UAAI,QAAQ,IAAI;AAAA,IACjB,CAAC;AAAA,EACF;AACA,MAAI,SAAS,OAAO;AAEnB,UAAM,QAAQ,IAAI,QAAQ;AAC1B,WAAO,KAAK;AAAA,EACb;AACA,gBAAc,MAAM;AAEnB,QAAI,QAAQ,SAAS,QAAQ,QAAQ,UAAU,QAAQ,UAAU;AAChE,aAAO,MAAM;AACZ,YAAI,oBAAoB,YAAY,cAAc;AAAA,MACnD;AAAA,IACD;AAAA,EACD,CAAC;AACF;AAUO,SAAS,UAAU,OAAOC,OAAM,OAAO;AAE7C,QAAM,SAAS,CAACC,WAAU;AAnsC3B;AAosCE,UAAM,gBAAgB,OAAO,KAAK;AAClC,UAAM,SAAS,OAAO,MAAM,cAAcD,KAAI,CAAC;AAC/C,QAAI,UAAU,MAAM,GAAG;AACtB,UAAI,QAAQC,MAAK;AAAA,IAClB,aAAW,YAAO,yBAAyB,eAAeD,KAAI,MAAnD,mBAAsD,SAAQ,QAAW;AACnF,oBAAcA,KAAI,IAAIC;AAAA,IACvB;AAAA,EACD;AACA,SAAO,KAAK;AACZ,gBAAc,MAAM,MAAM;AACzB,WAAO,IAAI;AAAA,EACZ,CAAC;AACF;AAOO,SAAS,UAAU,sBAAsB,QAAQ;AACvD,UAAQ,MAAM;AACb,WAAO,oBAAoB;AAC3B,kBAAc,MAAM,MAAM;AACzB,cAAQ,MAAM;AACb,eAAO,IAAI;AAAA,MACZ,CAAC;AAAA,IACF,CAAC;AAAA,EACF,CAAC;AACF;AAMO,SAAS,SAAS,QAAQ;AAChC,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACvC,yBAAqB,IAAI,OAAO,CAAC,CAAC;AAAA,EACnC;AACA,aAAW,MAAM,oBAAoB;AACpC,OAAG,MAAM;AAAA,EACV;AACD;AAOA,SAAS,yBAAyB,cAAcR,QAAO;AApvCvD;AAqvCC,QAAM,aAAaA,OAAM;AACzB,QAAM,SAAO,KAAAA,OAAM,iBAAN,wBAAAA,YAA0B,CAAC;AACxC,MAAI;AAAA;AAAA,IAAgD,KAAK,CAAC,KAAKA,OAAM;AAAA;AACrE,MAAIA,OAAM,WAAW,gBAAgB;AACpC,oBAAgBA,QAAO,UAAU;AAAA,MAChC,cAAc;AAAA,MACd,OAAO;AAAA,IACR,CAAC;AAAA,EACF;AASA,MAAI,WAAW;AAEf,QAAM,aAAaA,OAAM;AACzB,MAAI,YAAY;AACf,UAAM,SAAS,KAAK,QAAQ,UAAU;AACtC,QAAI,SAAS,KAAK,QAAQ,YAAY,GAAG;AACxC,iBAAW;AAAA,IACZ;AAAA,EACD;AACA;AAAA,EAAyC,KAAK,QAAQ,KAAKA,OAAM;AAEjE,kBAAgBA,QAAO,iBAAiB;AAAA,IACvC,cAAc;AAAA,IACd,MAAM;AAEL,aAAO,kBAAkB;AAAA,IAC1B;AAAA,EACD,CAAC;AAED,SAAO,mBAAmB,MAAM;AAE/B,UAAM,iBACL,eAAe;AAAA,IAAkC,eAAgB,QAAQ;AAC1E,UAAM,qBAAqB,OAAO;AAElC,UAAM,YAAY,eAAe,kBAAkB;AACnD,QAAI,cAAc,UAAa;AAAA,IAAsB,eAAgB,UAAW;AAC/E,UAAI,SAAS,SAAS,GAAG;AACxB,cAAM,CAAC,IAAI,GAAG,IAAI,IAAI;AACtB,WAAG,MAAM,gBAAgB,CAACA,QAAO,GAAG,IAAI,CAAC;AAAA,MAC1C,OAAO;AACN,kBAAU,KAAK,gBAAgBA,MAAK;AAAA,MACrC;AAAA,IACD;AACA,QAAIA,OAAM,gBAAgB,mBAAmB,cAAc;AAC1D;AAAA,IACD;AACA,qBAAiB;AAAA,EAClB;AAGA,EAAAA,OAAM,SAAS;AAChB;AAQO,SAAS,KAAK,aAAa,SAAS,YAAY,aAAa;AACnE,uBAAqB,WAAW;AAChC,MAAI,YAAY,QAAW;AAC1B,QAAI,gBAAgB,MAAM;AACzB,kBAAY,WAAW;AAAA,IACxB;AAAA,EACD,OAAO;AACN,YAAQ,aAAa,UAAU;AAAA,EAChC;AACD;AASA,SAAS,SAAS,aAAa,cAAc,eAAe,cAAc;AACzE,QAAM,QAAQ,gBAAgB;AAC9B,uBAAqB,WAAW;AAChC,QAAM,yBAAyB,oBAAI,IAAI;AACvC,QAAM,wBAAwB,oBAAI,IAAI;AACtC,QAAM,8BAA8B;AAGpC,MAAI,iBAAiB;AAErB,MAAI,gBAAgB;AACpB,MAAI,cAAc;AAClB,MAAI,qBAAqB;AAEzB,QAAM;AAAA;AAAA;AAAA;AAAA,EAKL,CAACS,gBAAe;AACf,QAAI,MAAM,SAAS;AAClB,6BAAuB,IAAIA,WAAU;AACrC,MAAAA,YAAW,SAAS,MAAM;AACzB,+BAAuB,OAAOA,WAAU;AACxC,8BAAsB,sBAAsB;AAC5C,YAAI,uBAAuB,SAAS,GAAG;AACtC,yBAAe,iBAAiB;AAAA,QACjC;AAAA,MACD,CAAC;AAAA,IACF,OAAO;AACN,4BAAsB,IAAIA,WAAU;AACpC,MAAAA,YAAW,SAAS,MAAM;AACzB,8BAAsB,OAAOA,WAAU;AACvC,8BAAsB,qBAAqB;AAC3C,YAAI,sBAAsB,SAAS,GAAG;AACrC,yBAAe,gBAAgB;AAAA,QAChC;AAAA,MACD,CAAC;AAAA,IACF;AAAA,EACD;AACD,QAAM,YAAY;AAAA,IACjB,MAAM;AAn3CR;AAo3CG,YAAM,SAAS,CAAC,CAAC,aAAa;AAC9B,UAAI,MAAM,YAAY,UAAU,CAAC,aAAa;AAC7C,cAAM,UAAU;AAChB,YAAI,aAAa;AAChB,cAAI,QAAQ;AACX,kCAAsB,qBAAqB;AAC3C,gBAAI,sBAAsB,SAAS,GAAG;AACrC,6BAAe,gBAAgB;AAAA,YAChC,OAAO;AACN,kCAAoB,uBAAuB,KAAK;AAAA,YACjD;AACA,gBAAI,uBAAuB,SAAS,GAAG;AACtC,6BAAe,iBAAiB;AAAA,YACjC,OAAO;AACN,kCAAoB,wBAAwB,IAAI;AAAA,YACjD;AAAA,UACD,OAAO;AACN,kCAAsB,sBAAsB;AAC5C,gBAAI,uBAAuB,SAAS,GAAG;AACtC,6BAAe,iBAAiB;AAAA,YACjC,OAAO;AACN,kCAAoB,wBAAwB,KAAK;AAAA,YAClD;AACA,gBAAI,sBAAsB,SAAS,GAAG;AACrC,6BAAe,gBAAgB;AAAA,YAChC,OAAO;AACN,kCAAoB,uBAAuB,IAAI;AAAA,YAChD;AAAA,UACD;AAAA,QACD,WAAW,+BAA+B,MAAM;AAC/C,gBAAM;AAAA;AAAA,aAAuC,6DAA6B,OAA7B,mBAAkC;AAAA;AAC/E,cACE,CAAC;AAAA,UAED,2BAA2B,CAAC,MAAM,QAClC,iBAAiB,iBAAiB,CAAC,UACnC,iBAAiB,kBAAkB,QACnC;AAGD,mBAAO,0BAA0B;AACjC,2CAA+B,IAAI;AAAA,UACpC,OAAO;AAEN,uCAA2B,MAAM;AAAA,UAClC;AAAA,QACD;AACA,sBAAc;AAAA,MACf;AAAA,IACD;AAAA,IACA;AAAA,IACA;AAAA,EACD;AAEA,QAAM,oBAAoB;AAAA,IACzB,MAAM;AACL,UAAI,mBAAmB,MAAM;AAC5B,eAAO,cAAc;AACrB,yBAAiB;AAAA,MAClB;AACA,UAAI,MAAM,SAAS;AAClB,sBAAc,WAAW;AACzB,YAAI,CAAC,oBAAoB;AAExB,yCAA+B,2BAA2B;AAC1D,+BAAqB;AAAA,QACtB;AAAA,MACD;AACA,uBAAiB,MAAM;AACvB,YAAM,MAAM;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,EACD;AAEA,QAAM,mBAAmB;AAAA,IACxB,MAAM;AACL,UAAI,kBAAkB,MAAM;AAC3B,eAAO,aAAa;AACpB,wBAAgB;AAAA,MACjB;AACA,UAAI,CAAC,MAAM,SAAS;AACnB,YAAI,iBAAiB,MAAM;AAC1B,uBAAa,WAAW;AAAA,QACzB;AACA,YAAI,CAAC,oBAAoB;AAExB,yCAA+B,2BAA2B;AAC1D,+BAAqB;AAAA,QACtB;AAAA,MACD;AACA,sBAAgB,MAAM;AACtB,YAAM,MAAM;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACA,kBAAgB,WAAW,MAAM;AAChC,QAAI,mBAAmB,MAAM;AAC5B,aAAO,cAAc;AAAA,IACtB;AACA,QAAI,kBAAkB,MAAM;AAC3B,aAAO,aAAa;AAAA,IACrB;AACA,mBAAe,iBAAiB;AAChC,mBAAe,gBAAgB;AAAA,EAChC,CAAC;AACD,QAAM,SAAS;AAChB;AAOO,SAAS,KAAK,WAAW;AAC/B,QAAM,QAAQ,kBAAkB;AAGhC,QAAM,qBACL,+BAA+B,OAAO,uBAAuB,SAAS,KAAK,UAAU,IAAI;AAC1F,QAAM,8BAA8B;AACpC,iCAA+B,kBAAkB;AACjD,MAAI;AACH,UAAM,cAAc;AAAA,MACnB,MAAM;AACL,cAAM,UAAU,MAAM;AACtB,YAAI,YAAY,MAAM;AACrB,iBAAO,OAAO;AACd,gBAAM,MAAM;AAAA,QACb;AACA,YAAI,SAAS;AACb,YAAI,+BAA+B,MAAM;AACxC,mBAAS,MAAM;AACf,mBAAS,KAAK,YAAY,MAAM;AAAA,QACjC;AACA,kBAAU,MAAM;AAAA,MACjB;AAAA,MACA;AAAA,MACA;AAAA,IACD;AACA,oBAAgB,aAAa,MAAM;AAClC,YAAM,UAAU,MAAM;AACtB,UAAI,YAAY,MAAM;AACrB,eAAO,OAAO;AAAA,MACf;AAAA,IACD,CAAC;AACD,UAAM,SAAS;AAAA,EAChB,UAAE;AACD,mCAA+B,2BAA2B;AAAA,EAC3D;AACD;AAQA,SAAS,eAAe,OAAO,MAAM,IAAI;AACxC,QAAM,MAAM,MAAM;AAClB,MAAI,SAAS,GAAG,GAAG;AAClB,aAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACpC,UAAI,IAAI,CAAC,MAAM,MAAM;AACpB,YAAI,CAAC,IAAI;AACT;AAAA,MACD;AAAA,IACD;AAAA,EACD,WAAW,QAAQ,MAAM;AACxB,UAAM,MAAM;AAAA,EACb;AACD;AASO,SAAS,QAAQ,aAAa,QAAQ,WAAW,SAAS,OAAO;AACvE,QAAM,QAAQ,6BAA6B;AAC3C,uBAAqB,WAAW;AAChC,MAAI,cAAc;AAGlB,MAAI;AAGJ,MAAIC,WAAU;AACd,QAAM,iBAAiB;AAAA,IACtB,MAAM;AACL,YAAM,OAAO;AACb,UAAI,aAAa;AAChB,uBAAe,oBAAoB;AAAA,MACpC;AACA,oBAAc;AAAA,IACf;AAAA,IACA;AAAA,IACA;AAAA,EACD;AAEA,QAAM,uBAAuB;AAAA,IAC5B,MAAM;AACL,YAAM,eAAe,MAClB,+BAA+B;AAAA;AAAA,QACW,2BAA2B,CAAC;AAAA,UACrE,SACA,SAAS,gBAAgB,8BAA8B,GAAG,IAC1D,SAAS,cAAc,GAAG,IAC3B;AACH,YAAM,eAAeA;AACrB,UAAI,iBAAiB,MAAM;AAC1B,cAAM,MAAM;AAAA,MACb;AACA,MAAAA,WAAU;AACV,UAAIA,aAAY,QAAQ,cAAc,MAAM;AAC3C,YAAI;AACJ,YAAI,+BAA+B,MAAM;AAGxC;AAAA,UAAiCA,SAAQ;AAAA,QAC1C,OAAO;AACN,mBAAS,MAAM;AACf,UAAAA,SAAQ,YAAY,MAAM;AAAA,QAC3B;AACA,kBAAUA,UAAS,MAAM;AAAA,MAC1B;AACA,YAAM,mBAAmB,iBAAiB;AAC1C,UAAI,kBAAkB;AACrB,eAAO,YAAY;AAAA,MACpB;AACA,UAAIA,aAAY,MAAM;AACrB,eAAOA,UAAS,MAAM,WAAW;AACjC,YAAI,kBAAkB;AACrB,gBAAM,eAAe,MAAM;AAC3B,yBAAe,cAAc,cAAcA,QAAO;AAAA,QACnD;AAAA,MACD;AAAA,IACD;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACA,kBAAgB,gBAAgB,MAAM;AACrC,QAAIA,aAAY,MAAM;AACrB,aAAOA,QAAO;AACd,YAAM,MAAM;AACZ,MAAAA,WAAU;AAAA,IACX;AACA,mBAAe,oBAAoB;AAAA,EACpC,CAAC;AACD,QAAM,SAAS;AAChB;AASO,SAAS,UAAU,aAAa,cAAc,WAAW;AAC/D,QAAM,QAAQ,+BAA+B;AAG7C,MAAI,iBAAiB;AACrB,uBAAqB,WAAW;AAGhC,MAAIC,aAAY;AAChB,QAAM;AAAA;AAAA;AAAA;AAAA,EAKL,CAACC,gBAAe;AACf,UAAMC;AAAA;AAAA,MAAqD;AAAA;AAC3D,UAAM,cAAcA,QAAO;AAC3B,gBAAY,IAAID,WAAU;AAC1B,IAAAA,YAAW,SAAS,MAAM;AACzB,kBAAY,OAAOA,WAAU;AAC7B,4BAAsB,WAAW;AACjC,UAAI,YAAY,SAAS,GAAG;AAC3B,YAAIC,QAAO,WAAW,MAAM;AAC3B,cAAIA,QAAO,QAAQ,MAAM;AACxB,mBAAOA,QAAO,GAAG;AACjB,YAAAA,QAAO,MAAM;AAAA,UACd;AACA,yBAAeA,QAAO,MAAM;AAC5B,UAAAA,QAAO,SAAS;AAAA,QACjB;AAAA,MACD;AAAA,IACD,CAAC;AAAA,EACF;AACD,QAAM,uBAAuB,MAAM;AAElC,UAAMA,UAAS;AAAA,MACd,KAAK;AAAA,MACL,QAAQ;AAAA,MACR,aAAa,oBAAI,IAAI;AAAA,MACrB,MAAM;AAAA,IACP;AAEA,UAAMC,UAAS;AAAA,MACd,MAAM;AACL,cAAM,UAAU,MAAM;AACtB,YAAI,YAAY,MAAM;AACrB,iBAAO,OAAO;AACd,gBAAM,MAAM;AAAA,QACb;AACA,YAAIH,YAAW;AACd,oBAAUA,UAAS;AAAA,QACpB;AACA,QAAAE,QAAO,MAAM,MAAM;AACnB,cAAM,MAAM;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,IACD;AACA,IAAAA,QAAO,SAASC;AAChB,qBAAiBD;AAAA,EAClB;AACA,QAAM,SAAS,MAAM;AACpB,UAAMA,UAAS;AACf,QAAIA,YAAW,MAAM;AACpB,2BAAqB;AACrB;AAAA,IACD;AACA,UAAM,cAAcA,QAAO;AAC3B,QAAI,YAAY,SAAS,GAAG;AAC3B,UAAIA,QAAO,QAAQ,MAAM;AACxB,eAAOA,QAAO,GAAG;AACjB,QAAAA,QAAO,MAAM;AAAA,MACd;AACA,UAAIA,QAAO,QAAQ;AAClB,uBAAeA,QAAO,MAAM;AAAA,MAC7B,OAAO;AACN,6BAAqB;AAAA,MACtB;AAAA,IACD,OAAO;AACN,2BAAqB;AACrB,0BAAoB,aAAa,KAAK;AAAA,IACvC;AAAA,EACD;AACA,QAAM,mBAAmB;AAAA,IACxB,MAAM;AACL,YAAM,iBAAiB,aAAa;AACpC,UAAIF,eAAc,gBAAgB;AACjC,QAAAA,aAAY;AACZ,eAAO;AAAA,MACR;AAAA,IACD;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACA,kBAAgB,kBAAkB,MAAM;AACvC,QAAIE,UAAS;AACb,WAAOA,YAAW,MAAM;AACvB,YAAM,MAAMA,QAAO;AACnB,UAAI,QAAQ,MAAM;AACjB,eAAO,GAAG;AAAA,MACX;AACA,YAAMC,UAASD,QAAO;AACtB,UAAIC,YAAW,MAAM;AACpB,uBAAeA,OAAM;AAAA,MACtB;AACA,MAAAD,UAASA,QAAO;AAAA,IACjB;AAAA,EACD,CAAC;AACD,QAAM,SAAS;AAChB;AAWA,SAAS,YAAY,aAAa,OAAO,YAAY,SAAS,UAAU;AACvE,QAAM,QAAQ,mBAAmB;AAGjC,MAAI,iBAAiB;AACrB,uBAAqB,WAAW;AAGhC,MAAI;AAGJ,MAAI,iBAAiB;AAGrB,MAAI,QAAQ;AACZ,MAAI,UAAU;AACd,QAAM;AAAA;AAAA;AAAA;AAAA,EAKL,CAACD,gBAAe;AACf,UAAMC;AAAA;AAAA,MAAqD;AAAA;AAC3D,UAAM,cAAcA,QAAO;AAC3B,gBAAY,IAAID,WAAU;AAC1B,IAAAA,YAAW,SAAS,MAAM;AACzB,kBAAY,OAAOA,WAAU;AAC7B,4BAAsB,WAAW;AACjC,UAAI,YAAY,SAAS,GAAG;AAC3B,YAAIC,QAAO,WAAW,MAAM;AAC3B,cAAIA,QAAO,QAAQ,MAAM;AACxB,mBAAOA,QAAO,GAAG;AACjB,YAAAA,QAAO,MAAM;AAAA,UACd;AACA,yBAAeA,QAAO,MAAM;AAC5B,UAAAA,QAAO,SAAS;AAAA,QACjB;AAAA,MACD;AAAA,IACD,CAAC;AAAA,EACF;AACD,QAAM,uBAAuB,MAAM;AAElC,UAAMA,UAAS;AAAA,MACd,KAAK;AAAA,MACL,QAAQ;AAAA,MACR,aAAa,oBAAI,IAAI;AAAA,MACrB,MAAM;AAAA,IACP;AACA,UAAMC,UAAS;AAAA,MACd,MAAM;AACL,YAAI,UAAU,eAAe;AAC5B,cAAI,mBAAmB,eAAe;AACrC,kBAAM,UAAU;AAChB,gBAAI,eAAe,MAAM;AACxB,yBAAW,WAAW;AAAA,YACvB;AAAA,UACD,WAAW,YAAY,MAAM;AAC5B,kBAAM,UAAU;AAChB,oBAAQ,aAAa,cAAc;AAAA,UACpC;AAAA,QACD,WAAW,aAAa,MAAM;AAC7B,gBAAM,UAAU;AAChB,mBAAS,aAAa,KAAK;AAAA,QAC5B;AACA,QAAAD,QAAO,MAAM,MAAM;AACnB,cAAM,MAAM;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACD;AACA,IAAAA,QAAO,SAASC;AAChB,qBAAiBD;AAAA,EAClB;AACA,QAAM,SAAS,MAAM;AACpB,UAAMA,UAAS;AACf,QAAIA,YAAW,MAAM;AACpB,2BAAqB;AACrB;AAAA,IACD;AACA,UAAM,cAAcA,QAAO;AAC3B,0BAAsB,WAAW;AACjC,QAAI,YAAY,SAAS,GAAG;AAC3B,UAAIA,QAAO,QAAQ,MAAM;AACxB,eAAOA,QAAO,GAAG;AACjB,QAAAA,QAAO,MAAM;AAAA,MACd;AACA,UAAIA,QAAO,QAAQ;AAClB,uBAAeA,QAAO,MAAM;AAAA,MAC7B,OAAO;AACN,6BAAqB;AAAA,MACtB;AAAA,IACD,OAAO;AACN,2BAAqB;AACrB,0BAAoB,aAAa,KAAK;AAAA,IACvC;AAAA,EACD;AACA,QAAM,eAAe;AAAA,IACpB,MAAM;AACL,YAAM,QAAQ,CAAC;AACf,qBAAe;AACf,YAAM,UAAU,UAAU,KAAK,IAAI,IAAI,KAAK,IAAI,OAAO,UAAU,aAAa,MAAM,IAAI;AACxF,UAAI,WAAW,OAAO,GAAG;AACxB,gBAAQ;AAAA;AAAA,UAEP,CAAC,MAAM;AACN,gBAAI,iBAAiB,OAAO;AAE3B,wBAAU;AACV,+BAAiB;AACjB,wBAAU;AACV,qBAAO;AAAA,YACR;AAAA,UACD;AAAA;AAAA,UAEA,CAAC,WAAW;AACX,oBAAQ;AACR,sBAAU;AACV,mBAAO;AAAA,UACR;AAAA,QACD;AACA,YAAI,mBAAmB,iBAAiB,UAAU,eAAe;AAChE,kBAAQ;AACR,2BAAiB;AAAA,QAClB;AACA,YAAI,CAAC,SAAS;AACb,oBAAU;AACV,iBAAO;AAAA,QACR;AAAA,MACD,OAAO;AACN,gBAAQ;AACR,yBAAiB;AACjB,kBAAU;AACV,eAAO;AAAA,MACR;AAAA,IACD;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACA,kBAAgB,cAAc,MAAM;AACnC,QAAIA,UAAS;AACb,mBAAe,CAAC;AAChB,WAAOA,YAAW,MAAM;AACvB,YAAM,MAAMA,QAAO;AACnB,UAAI,QAAQ,MAAM;AACjB,eAAO,GAAG;AAAA,MACX;AACA,YAAMC,UAASD,QAAO;AACtB,UAAIC,YAAW,MAAM;AACpB,uBAAeA,OAAM;AAAA,MACtB;AACA,MAAAD,UAASA,QAAO;AAAA,IACjB;AAAA,EACD,CAAC;AACD,QAAM,SAAS;AAChB;AAUO,SAAS,IAAI,aAAaE,MAAK,WAAW;AAChD,QAAM,QAAQ,iBAAiB;AAG/B,MAAI,iBAAiB;AACrB,uBAAqB,WAAW;AAGhC,MAAI,YAAY;AAChB,MAAI,UAAU;AACd,QAAM;AAAA;AAAA;AAAA;AAAA,EAKL,CAACC,gBAAe;AACf,UAAMC;AAAA;AAAA,MAAqD;AAAA;AAC3D,UAAM,cAAcA,QAAO;AAC3B,gBAAY,IAAID,WAAU;AAC1B,IAAAA,YAAW,SAAS,MAAM;AACzB,kBAAY,OAAOA,WAAU;AAC7B,4BAAsB,WAAW;AACjC,UAAI,YAAY,SAAS,GAAG;AAC3B,YAAIC,QAAO,WAAW,MAAM;AAC3B,cAAIA,QAAO,QAAQ,MAAM;AACxB,mBAAOA,QAAO,GAAG;AACjB,YAAAA,QAAO,MAAM;AAAA,UACd;AACA,yBAAeA,QAAO,MAAM;AAC5B,UAAAA,QAAO,SAAS;AAAA,QACjB;AAAA,MACD;AAAA,IACD,CAAC;AAAA,EACF;AACD,QAAM,uBAAuB,MAAM;AAElC,UAAMA,UAAS;AAAA,MACd,KAAK;AAAA,MACL,QAAQ;AAAA,MACR,aAAa,oBAAI,IAAI;AAAA,MACrB,MAAM;AAAA,IACP;AACA,UAAMC,UAAS;AAAA,MACd,MAAM;AACL,kBAAU,WAAW;AACrB,QAAAD,QAAO,MAAM,MAAM;AACnB,cAAM,MAAM;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACD;AACA,IAAAA,QAAO,SAASC;AAChB,qBAAiBD;AAAA,EAClB;AACA,QAAM,SAAS,MAAM;AACpB,UAAMA,UAAS;AACf,QAAIA,YAAW,MAAM;AACpB,2BAAqB;AACrB;AAAA,IACD;AACA,UAAM,cAAcA,QAAO;AAC3B,0BAAsB,WAAW;AACjC,QAAI,YAAY,SAAS,GAAG;AAC3B,UAAIA,QAAO,QAAQ,MAAM;AACxB,eAAOA,QAAO,GAAG;AACjB,QAAAA,QAAO,MAAM;AAAA,MACd;AACA,UAAIA,QAAO,QAAQ;AAClB,uBAAeA,QAAO,MAAM;AAAA,MAC7B,OAAO;AACN,6BAAqB;AAAA,MACtB;AAAA,IACD,OAAO;AACN,0BAAoB,aAAa,KAAK;AACtC,2BAAqB;AAAA,IACtB;AAAA,EACD;AACA,QAAM,aAAa;AAAA,IAClB,MAAM;AACL,YAAM,iBAAiB;AACvB,kBAAYF,KAAI;AAChB,UAAI,WAAW,eAAe,gBAAgB,SAAS,GAAG;AACzD,eAAO;AAAA,MACR;AAAA,IACD;AAAA,IACA;AAAA,IACA;AAAA,EACD;AAGA,SAAO;AACP,YAAU;AACV,kBAAgB,YAAY,MAAM;AACjC,QAAIE,UAAS;AACb,WAAOA,YAAW,MAAM;AACvB,YAAM,MAAMA,QAAO;AACnB,UAAI,QAAQ,MAAM;AACjB,eAAO,GAAG;AAAA,MACX;AACA,YAAMC,UAASD,QAAO;AACtB,UAAIC,YAAW,MAAM;AACpB,uBAAeA,OAAM;AAAA,MACtB;AACA,MAAAD,UAASA,QAAO;AAAA,IACjB;AAAA,EACD,CAAC;AACD,QAAM,SAAS;AAChB;AAMA,SAAS,kBAAkB,OAAO;AACjC,QAAM,UAAU,MAAM;AACtB,MAAI,SAAS,OAAO,GAAG;AACtB,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACxC,YAAM,OAAO,QAAQ,CAAC;AACtB,UAAI,KAAK,aAAa,GAAG;AACxB,eAAO;AAAA,MACR;AAAA,IACD;AAAA,EACD;AACA;AAAA;AAAA,IAAgD;AAAA;AACjD;AASO,SAAS,uBAAuB,OAAO,MAAM,OAAO,MAAM;AAChE,OAAK,OAAO,wBAAwB,GAAG;AACtC,qBAAiB,MAAM,MAAM,IAAI;AAAA,EAClC;AACA,QAAM,cAAc,MAAM;AAC1B,QAAM,qBAAqB,OAAO,yBAAyB;AAE3D,MAAI,gBAAgB,SAAS,OAAO,gBAAgB,GAAG;AACtD,QAAI,aAAa,MAAM;AACvB,QAAI,mBAAmB;AACtB;AAAA,MAAiE,WAAY;AAAA,IAC9E;AACA,UAAM,QAAQ,MAAM,OAAO;AAC3B,QAAI,eAAe;AAAA,IAAgC,QAAS,MAAM,QAAQ;AACzE,YAAM;AAAA;AAAA,QAAmC,kBAAkB,KAAK;AAAA;AAChE,YAAM,OAAO,SAAS,sBAAsB;AAC5C,oBAAc,MAAM;AACnB,4BAAoB,aAAa,OAAO,IAAI;AAAA,MAC7C,CAAC;AAAA,IACF;AAAA,EACD;AACA,MAAI,mBAAmB;AACtB;AAAA;AAAA,MAAqE,MAAM;AAAA,MAAQ;AAAA,IAAK;AAAA,EACzF,OAAO;AACN,UAAM,QAAQ;AAAA,EACf;AACD;AASO,SAAS,wBACf,OACA,kBACA,mBACA,aAAa,OACZ;AACD,QAAM,cAAc,MAAM;AAC1B,MAAI,qBAAqB,gBAAgB,MAAM;AAC9C,wBAAoB,aAAa,KAAK;AACtC,QAAI,qBAAqB,MAAM;AAC9B,uBAAiB,KAAK,KAAK;AAAA,IAC5B;AAAA,EACD,OAAO;AACN,UAAM,MAAM,MAAM;AAClB,QAAI,CAAC,cAAc,QAAQ,MAAM;AAChC,aAAO,GAAG;AAAA,IACX;AACA;AAAA;AAAA,MAAiE,MAAM;AAAA,IAAO;AAAA,EAC/E;AACD;AAWO,SAAS,gBAAgB,MAAMF,MAAK,OAAO,WAAW,OAAO;AACnE,QAAM,cAAc,QAAQ,wBAAwB,IAAI,OAAO,OAAO,IAAI;AAC1E,QAAM,eAAe,QAAQ,yBAAyB,IAAI,QAAQ,OAAO,KAAK;AAC9E,QAAM,QAAQ,uBAAuB,YAAY,aAAaA,IAAG;AACjE,QAAMG,UAAS;AAAA;AAAA,IAEd,CAACC,WAAU;AACV,gBAAU,MAAMA,OAAM,MAAMA,OAAM,KAAK;AAAA,IACxC;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACA,QAAM,SAASD;AACf,SAAO;AACR;AAaA,SAAS,KAAK,aAAa,YAAY,OAAO,QAAQ,WAAW,aAAa,cAAc;AAC3F,QAAM,iBAAiB,QAAQ,wBAAwB;AACvD,QAAM,QAAQ,kBAAkB,OAAO,WAAW;AAGlD,MAAI,mBAAmB;AACvB,uBAAqB,aAAa,aAAa;AAG/C,MAAI;AAGJ,MAAI,OAAO;AAGX,MAAI,SAAS;AACb,QAAM;AAAA,EAEL,CAACF,gBAAe;AACf,UAAM;AAAA;AAAA,MAAuD;AAAA;AAC7D,UAAM,cAAc,SAAS;AAC7B,gBAAY,IAAIA,WAAU;AAC1B,IAAAA,YAAW,SAAS,MAAM;AACzB,kBAAY,OAAOA,WAAU;AAC7B,4BAAsB,WAAW;AACjC,UAAI,YAAY,SAAS,GAAG;AAC3B,YAAI,SAAS,WAAW,MAAM;AAC7B,cAAI,SAAS,QAAQ,MAAM;AAC1B,mBAAO,SAAS,GAAG;AACnB,qBAAS,MAAM;AAAA,UAChB;AACA,yBAAe,SAAS,MAAM;AAC9B,mBAAS,SAAS;AAAA,QACnB;AAAA,MACD;AAAA,IACD,CAAC;AAAA,EACF;AACD,QAAM,yBAAyB,MAAM;AAEpC,UAAM,WAAW;AAAA,MAChB,KAAK;AAAA,MACL,QAAQ;AAAA,MACR,aAAa,oBAAI,IAAI;AAAA,MACrB,MAAM;AAAA,IACP;AAEA,UAAME,UAAS;AAAA,MACd,MAAM;AACL,cAAM,MAAM,MAAM;AAClB,YAAI,QAAQ,MAAM;AACjB,iBAAO,GAAG;AACV,gBAAM,MAAM;AAAA,QACb;AACA,YAAI,SAAS,MAAM;AACnB,cAAME,kBAAiB,MAAM,QAAQ,wBAAwB;AAC7D,YAAIA,gBAAe;AAClB,mBAAS,MAAM;AACf,gBAAM,OAAO,YAAY,MAAM;AAAA,QAChC;AACsC,QAAC,YAAa,MAAM;AAC1D,iBAAS,MAAM,MAAM;AACrB,cAAM,MAAM;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,IACD;AACA,aAAS,SAASF;AAClB,uBAAmB;AAAA,EACpB;AACA,QAAMG,QAAO;AAAA,IACZ,MAAM;AAEL,YAAM,cAAc,WAAW;AAC/B,cAAQ,SAAS,WAAW,IACzB,cACA,eAAe,OACf,CAAC,IACD,MAAM,KAAK,WAAW;AACzB,UAAI,WAAW,MAAM;AACpB,eAAO,MAAM,IAAI,MAAM;AAAA,MACxB;AACA,UAAI,gBAAgB,MAAM;AACzB,YAAI,MAAM,WAAW,GAAG;AACvB,cAAI,MAAM,MAAM,WAAW,KAAK,WAAW,MAAM;AAChD,mCAAuB;AAAA,UACxB;AAAA,QACD,WAAW,MAAM,MAAM,WAAW,KAAK,qBAAqB,MAAM;AACjE,gBAAM,WAAW;AACjB,gBAAM,cAAc,SAAS;AAC7B,cAAI,YAAY,SAAS,GAAG;AAC3B,gBAAI,SAAS,QAAQ,MAAM;AAC1B,qBAAO,SAAS,GAAG;AACnB,uBAAS,MAAM;AAAA,YAChB;AAAA,UACD,OAAO;AACN,gCAAoB,aAAa,KAAK;AAAA,UACvC;AAAA,QACD;AAAA,MACD;AACA,UAAI,WAAW,MAAM;AACpB,uBAAe,MAAM;AAAA,MACtB;AAAA,IACD;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACA,WAAS;AAAA;AAAA,IAER,CAACF,WAAU;AACV,YAAMG,SAAQH,OAAM;AACpB,YAAMC,kBAAiBE,SAAQ,wBAAwB;AACvD,YAAMC,eAAcJ,OAAM;AAC1B,mBAAa,OAAOA,QAAOI,cAAaH,gBAAe,WAAWE,QAAO,MAAM,IAAI;AAAA,IACpF;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACA,kBAAgBD,OAAM,MAAM;AAC3B,UAAMC,SAAQ,MAAM;AACpB,UAAMF,kBAAiBE,SAAQ,wBAAwB;AACvD,UAAMC,eAAc,MAAM;AAC1B,QAAI,WAAW;AACf,WAAO,aAAa,MAAM;AACzB,YAAM,MAAM,SAAS;AACrB,UAAI,QAAQ,MAAM;AACjB,eAAO,GAAG;AAAA,MACX;AACA,YAAML,UAAS,SAAS;AACxB,UAAIA,YAAW,MAAM;AACpB,uBAAeA,OAAM;AAAA,MACtB;AACA,iBAAW,SAAS;AAAA,IACrB;AAEA,iBAAa,CAAC,GAAG,OAAOK,cAAaH,gBAAe,WAAWE,QAAO,OAAO,IAAI;AACjF;AAAA;AAAA,MAAiE;AAAA,IAAO;AAAA,EACzE,CAAC;AACD,QAAM,SAASD;AAChB;AAYO,SAAS,WAAW,aAAa,YAAY,OAAO,QAAQ,WAAW,aAAa;AAC1F,OAAK,aAAa,YAAY,OAAO,QAAQ,WAAW,aAAa,uBAAuB;AAC7F;AAWO,SAAS,aAAa,aAAa,YAAY,OAAO,WAAW,aAAa;AACpF,OAAK,aAAa,YAAY,OAAO,MAAM,WAAW,aAAa,uBAAuB;AAC3F;AASO,SAAS,SAAS,QAAQ,SAAS,OAAOG,YAAW;AAC3D,uBAAqB,MAAM;AAG3B,MAAI;AAGJ,MAAI;AACJ,MAAI,+BAA+B,MAAM;AAExC;AAAA,IAA+C,2BAA2B,CAAC;AAE3E;AAAA,IAA2C,IAAI;AAAA,EAChD,OAAO;AACN,QAAI,SAAS;AACZ,YAAM,SAAS,cAAc,KAAK;AAClC,UAAI,MAAM,UAAU;AAAA,IACrB,OAAO;AACN,YAAM,SAAS,gBAAgB,8BAA8B,GAAG;AAAA,IACjE;AACA,WAAO,KAAK,MAAM,MAAM;AACxB,uBAAmB,MAAM;AACzB,QAAI,YAAY,gBAAgB;AAAA,EACjC;AACA,EAAAA,WAAU,gBAAgB;AAG1B,MAAI,gBAAgB,CAAC;AACrB,QAAMN,UAAS,cAAc,MAAM;AAClC,UAAM,aAAa,MAAM;AACzB,eAAWH,QAAO,eAAe;AAChC,UAAI,EAAEA,QAAO,aAAa;AACzB,YAAI,MAAM,eAAeA,IAAG;AAAA,MAC7B;AAAA,IACD;AACA,eAAWA,QAAO,YAAY;AAC7B,UAAI,MAAM,YAAYA,MAAK,WAAWA,IAAG,CAAC;AAAA,IAC3C;AACA,oBAAgB;AAAA,EACjB,CAAC;AACD,kBAAgBG,SAAQ,MAAM;AAC7B,WAAO,GAAG;AAAA,EACX,CAAC;AACF;AAMO,SAAS,UAAU,OAAO;AAChC,SAAO,OAAO,UAAU,WAAW,QAAQ,SAAS,OAAO,KAAK,QAAQ;AACzE;AAQO,SAAS,KAAK,KAAK,WAAW,KAAK;AAEzC,MAAI;AAEJ,MAAI;AACJ,QAAMA,UAAS,cAAc,MAAM;AAClC,QAAI,WAAW,QAAQ,UAAU,IAAI;AACpC,UAAI,UAAU;AACb,eAAO,QAAQ;AAAA,MAChB;AACA,iBAAW,eAAe,KAAK,OAAO,GAAG;AAAA,IAC1C;AAAA,EACD,CAAC;AACD,kBAAgBA,SAAQ,MAAM;AAC7B,QAAI,UAAU;AACb,aAAO,QAAQ;AAAA,IAChB;AAAA,EACD,CAAC;AACF;AAUO,SAAS,WAAW,KAAK,eAAe,OAAO,SAAS,OAAO;AACrE,kBAAgB,KAAK,eAAe,OAAO,QAAQ,MAAM;AAC1D;AASO,SAAS,QAAQ,KAAK,eAAe,OAAO;AAClD,kBAAgB,KAAK,eAAe,OAAO,OAAO,KAAK;AACxD;AAUA,SAAS,MAAM,KAAK,eAAe,OAAO,SAAS,OAAO;AACzD,kBAAgB,KAAK,eAAe,OAAO,MAAM,MAAM;AACxD;AAWO,SAAS,IAAI,KAAK,eAAe,OAAO,SAAS,OAAO;AAC9D,kBAAgB,KAAK,eAAe,OAAO,OAAO,MAAM;AACzD;AASO,SAAS,OAAO,KAAKO,SAAQ,UAAU;AAE7C,MAAI,UAAU;AAGd,SAAO,MAAM;AACZ,QAAI,UAAU;AACb,YAAM,QAAQ,SAAS;AACvB,cAAQ,MAAM;AACb,YAAI,YAAY,QAAW;AAC1B,oBAAUA,QAAO,KAAK,KAAK;AAAA,QAC5B,OAAO;AACN,gBAAM,SAAS,QAAQ;AACvB,cAAI,OAAO,WAAW,YAAY;AACjC,mBAAO,KAAK;AAAA,UACb;AAAA,QACD;AAAA,MACD,CAAC;AAAA,IACF,OAAO;AACN,cAAQ,MAAO,UAAUA,QAAO,GAAG,CAAE;AAAA,IACtC;AAAA,EACD,CAAC;AACD,SAAO,MAAM;AACZ,QAAI,YAAY,QAAW;AAC1B,YAAM,UAAU,QAAQ;AACxB,UAAI,OAAO,YAAY,YAAY;AAClC,eAAO,MAAM;AACZ,kBAAQ;AAAA,QACT;AAAA,MACD;AAAA,IACD;AAAA,EACD,CAAC;AACF;AAOO,SAAS,2BAA2B,KAAK;AAC/C,MAAI,+BAA+B,MAAM;AACxC,SAAK,KAAK,SAAS,IAAI;AACvB,SAAK,KAAK,WAAW,IAAI;AAAA,EAC1B;AACD;AAOO,SAAS,sBAAsB,KAAK;AAC1C,MAAI,+BAA+B,QAAQ,IAAI,eAAe,MAAM;AACnE,QAAI,cAAc;AAAA,EACnB;AACD;AAOO,SAAS,YAAY,KAAK,WAAW,OAAO;AAClD,gBAAc,MAAM;AACnB,UAAM,SAAS,MAAM;AACrB,SAAK,KAAK,WAAW,MAAM;AAAA,EAC5B,CAAC;AACF;AAOO,SAAS,KAAK,KAAK,WAAW,OAAO;AAC3C,UAAQ,SAAS,OAAO,OAAO,QAAQ;AAEvC,MAAI,KAAK;AACR,+BAA2B,KAAK,WAAW,KAAK;AAAA,EACjD;AAEA,MACC,+BAA+B,QAC9B,IAAI,aAAa,SAAS,MAAM;AAAA;AAAA;AAAA;AAAA,EAKhC,cAAc,SACd,cAAc,UACd;AACD,QAAI,UAAU,MAAM;AACnB,UAAI,gBAAgB,SAAS;AAAA,IAC9B,OAAO;AACN,UAAI,aAAa,WAAW,KAAK;AAAA,IAClC;AAAA,EACD;AACD;AAGA,IAAI;AAOG,SAAS,cAAc,aAAa,KAAK;AAC/C,MAAI,gBAAgB;AAAK,WAAO;AAChC,MAAI,CAAC,sBAAsB;AAC1B,2BAAuB,SAAS,cAAc,GAAG;AAAA,EAClD;AAEA,uBAAqB,OAAO;AAC5B,SAAO,gBAAgB,qBAAqB;AAC7C;AAGA,SAAS,aAAa,QAAQ;AAC7B,SAAO,OAAO,MAAM,GAAG,EAAE,IAAI,CAAC,QAAQ,IAAI,KAAK,EAAE,MAAM,GAAG,EAAE,OAAO,OAAO,CAAC;AAC5E;AAOO,SAAS,iBAAiB,gBAAgB,QAAQ;AACxD,QAAM,eAAe,aAAa,eAAe,MAAM;AACvD,QAAM,OAAO,aAAa,UAAU,EAAE;AAEtC,SACC,KAAK,WAAW,aAAa,UAC7B,KAAK;AAAA,IACJ,CAAC,CAAC,KAAK,KAAK,GAAG,MACd,UAAU,aAAa,CAAC,EAAE,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA,KAM1B,cAAc,aAAa,CAAC,EAAE,CAAC,GAAG,GAAG,KAAK,cAAc,KAAK,aAAa,CAAC,EAAE,CAAC,CAAC;AAAA,EAClF;AAEF;AAOA,SAAS,2BAA2B,KAAK,WAAW,OAAO;AAC1D,MAAI,+BAA+B,SAAS,cAAc,SAAS,cAAc,WAAW;AAC3F,QACE,cAAc,SAAS,CAAC,cAAc,IAAI,aAAa,KAAK,KAAK,IAAI,SAAS,EAAE,KAChF,cAAc,YACd,CAAC;AAAA;AAAA,MAAsE;AAAA,MAAM,SAAS;AAAA,IAAE,GACxF;AAED,cAAQ;AAAA,QACP;AAAA,QAEA;AAAA,QACA;AAAA,QACA;AAAA,MACD;AAAA,IACD;AAAA,EACD;AACD;AAOO,SAAS,kBAAkB,KAAK,WAAW,OAAO;AACxD,gBAAc,MAAM;AACnB,UAAM,SAAS,MAAM;AACrB,eAAW,KAAK,WAAW,MAAM;AAAA,EAClC,CAAC;AACF;AAOO,SAAS,WAAW,KAAK,WAAW,OAAO;AACjD,MAAI,eAAe,gCAAgC,WAAW,KAAK;AACpE;AAOO,SAAS,+BAA+B,MAAMC,OAAM,OAAO;AACjE,gBAAc,MAAM;AACnB,4BAAwB,MAAMA,OAAM,MAAM,CAAC;AAAA,EAC5C,CAAC;AACF;AAOO,SAAS,wBAAwB,MAAMA,OAAM,OAAO;AAC1D,MAAIA,SAAQ,MAAM;AACjB,SAAKA,KAAI,IAAI,OAAO,KAAKA,KAAI,MAAM,aAAa,UAAU,KAAK,OAAO;AAAA,EACvE,OAAO;AACN,SAAK,MAAMA,OAAM,KAAK;AAAA,EACvB;AACD;AAQO,SAAS,MAAM,KAAKC,MAAK,OAAO,WAAW;AACjD,MAAI,SAAS,MAAM;AAClB,QAAI,MAAM,eAAeA,IAAG;AAAA,EAC7B,OAAO;AACN,QAAI,MAAM,YAAYA,MAAK,OAAO,YAAY,cAAc,EAAE;AAAA,EAC/D;AACD;AASA,IAAM,mCAAmC,CAAC,SAAS,QAAQ;AAG3D,IAAM,gBAAgB,oBAAI,IAAI;AAG9B,SAAS,YAAYC,UAAS;AAE7B,QAAM,UAAU,CAAC;AAEjB,QAAM,cAAc,gBAAgBA,SAAQ,SAAS;AACrD,aAAWD,QAAO,aAAa;AAC9B,QAAI,YAAYA,IAAG,EAAE,OAAO,CAAC,iCAAiC,SAASA,IAAG,GAAG;AAC5E,cAAQ,KAAKA,IAAG;AAAA,IACjB;AAAA,EACD;AACA,SAAO;AACR;AAUO,SAAS,kBAAkB,KAAK,MAAM,OAAO,UAAU;AAC7D,QAAM,OAAO,OAAO,OAAO,CAAC,GAAG,GAAG,KAAK;AACvC,QAAM,WAAW,SAAS,WAAW;AACrC,aAAWA,QAAO,MAAM;AACvB,QAAI,EAAEA,QAAO,OAAO;AACnB,WAAKA,IAAG,IAAI;AAAA,IACb;AAAA,EACD;AACA,MAAI,YAAY,CAAC,KAAK,OAAO;AAC5B,SAAK,QAAQ;AAAA,EACd;AAEA,MAAI,UAAU,QAAQ,eAAe,IAAI,QAAQ;AACjD,MAAI,CAAC;AAAS,YAAQ,eAAe,IAAI,UAAW,UAAU,YAAY,GAAG,CAAE;AAE/E,aAAWA,QAAO,MAAM;AACvB,QAAI,QAAQ,KAAKA,IAAG;AACpB,QAAI,WAAU,6BAAOA;AAAM;AAE3B,UAAM,SAASA,KAAI,MAAM,GAAG,CAAC;AAC7B,QAAI,WAAW;AAAM;AAErB,QAAI,WAAW,MAAM;AAEpB,YAAM,OAAO,CAAC;AACd,UAAI,aAAaA,KAAI,MAAM,CAAC,EAAE,YAAY;AAC1C,YAAM,YAAY,gBAAgB,SAAS,UAAU;AAErD,UACC,WAAW,SAAS,SAAS,KAC7B,eAAe,yBACf,eAAe,wBACd;AACD,qBAAa,WAAW,MAAM,GAAG,EAAE;AACnC,aAAK,UAAU;AAAA,MAChB;AACA,UAAI,CAAC,cAAa,6BAAOA,QAAM;AAC9B,YAAI;AAAA,UAAoB;AAAA;AAAA,UAAgC,KAAKA,IAAG;AAAA,UAAI;AAAA,QAAI;AAAA,MACzE;AACA,UAAI,SAAS,MAAM;AAClB,YAAI,CAAC,WAAW;AACf,cAAI,iBAAiB,YAAY,OAAO,IAAI;AAAA,QAC7C,OAAO;AAEN,cAAI,KAAK,UAAU,EAAE,IAAI;AACzB,mBAAS,CAAC,UAAU,CAAC;AAAA,QACtB;AAAA,MACD;AAAA,IACD,WAAW,SAAS,MAAM;AACzB,UAAI,gBAAgBA,IAAG;AAAA,IACxB,WAAWA,SAAQ,SAAS;AAC3B,UAAI,MAAM,UAAU,QAAQ;AAAA,IAC7B,WAAWA,SAAQ,aAAa;AAC/B;AAAA;AAAA,QAAuC;AAAA,QAAM,QAAQ,KAAK;AAAA,MAAC;AAAA,IAC5D,WAAWA,SAAQ,aAAaA,SAAQ,SAAS;AAEhD,UAAI,QAAQ,IAAIA,IAAG,IAAI,IAAI,UAAU;AAAA,IACtC,WAAW,QAAQ,SAASA,IAAG,GAAG;AACjC,UAAI,KAAK;AACR,mCAA2B,KAAKA,MAAK,KAAK;AAAA,MAC3C;AACA,UACC,+BAA+B;AAAA,MAE9B,IAAIA,IAAG,MAAM,SAASA,SAAQ,SAASA,SAAQ,UAC/C;AAED,YAAIA,IAAG,IAAI;AAAA,MACZ;AAAA,IACD,WAAW,OAAO,UAAU,YAAY;AACvC,UAAI,YAAYA,SAAQ,SAAS;AAChC,YAAI;AAAO,mBAAS;AACpB,iBAAS;AAAA,MACV;AAEA,WAAK,KAAKA,MAAK,KAAK;AAAA,IACrB;AAAA,EACD;AACA,SAAO;AACR;AAQO,SAAS,kCAAkC,MAAM,MAAM,OAAO,UAAU;AAC9E,MAAI,KAAK,QAAQ,SAAS,GAAG,GAAG;AAC/B,UAAM,OAAO,OAAO,OAAO,CAAC,GAAG,GAAG,KAAK;AACvC,QAAI,SAAS,MAAM;AAClB,iBAAWA,QAAO,MAAM;AACvB,YAAI,EAAEA,QAAO,OAAO;AACnB,eAAKA,IAAG,IAAI;AAAA,QACb;AAAA,MACD;AAAA,IACD;AACA,eAAWA,QAAO,MAAM;AACvB,8BAAwB,MAAMA,MAAK,KAAKA,IAAG,CAAC;AAAA,IAC7C;AACA,WAAO;AAAA,EACR,OAAO;AACN,WAAO;AAAA;AAAA,MAC0C;AAAA,MAChD;AAAA,MACA;AAAA,MACA;AAAA,IACD;AAAA,EACD;AACD;AAOO,SAAS,WAAW,cAAc,MAAM;AAC9C,SAAO,QAAQ,MAAM;AACpB,QAAI,QAAQ,OAAO,YAAY;AAG/B,QAAIE,cAAa,CAAC;AAElB,aAASF,QAAO,OAAO;AACtB,UAAI,KAAK,SAASA,IAAG;AAAG;AAExB,YAAM,EAAE,KAAAG,MAAK,OAAO,WAAW;AAAA;AAAA,QAC9B,eAAe,OAAOH,IAAG;AAAA;AAG1B,sBAAgBE,aAAYF,MAAKG,OAAM,EAAE,KAAAA,MAAK,WAAW,IAAI,EAAE,OAAO,WAAW,CAAC;AAAA,IACnF;AAEA,WAAOD;AAAA,EACR,CAAC;AACF;AAMO,SAAS,aAAa,OAAO;AACnC,MAAI,OAAO,UAAU,YAAY;AAChC,WAAO,QAAQ,MAAM;AACpB,aAAO,aAAa,MAAM,CAAC;AAAA,IAC5B,CAAC;AAAA,EACF;AAGA,QAAM,eAAe,CAAC;AACtB,MAAIF;AACJ,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACtC,UAAM,MAAM,MAAM,CAAC;AACnB,SAAKA,QAAO,KAAK;AAChB,YAAM;AAAA;AAAA,QAA0C,eAAe,KAAKA,IAAG;AAAA;AACvE,YAAM,SAAS,KAAK;AACpB,UAAI,WAAW,QAAW;AACzB,wBAAgB,cAAcA,MAAK;AAAA,UAClC,YAAY;AAAA,UACZ,cAAc;AAAA,UACd,KAAK;AAAA,QACN,CAAC;AAAA,MACF,WAAW,KAAK,QAAQ,QAAW;AAClC,qBAAaA,IAAG,IAAI,IAAIA,IAAG;AAAA,MAC5B,OAAO;AACN,wBAAgB,cAAcA,MAAK;AAAA,UAClC,YAAY;AAAA,UACZ,cAAc;AAAA,UACd,OAAO,IAAIA,IAAG;AAAA,QACf,CAAC;AAAA,MACF;AAAA,IACD;AAAA,EACD;AACA,SAAO;AACR;AAOO,SAAS,OAAO,OAAO;AAC7B,MAAI,UAAU,KAAK,GAAG;AAErB,WAAO,IAAI,KAAK;AAAA,EACjB;AAEA,SAAO;AACR;AAsBO,SAAS,WAAWI,YAAW,SAAS;AAI9C,QAAM,SAAS,CAAC;AAEhB,QAAM,WAAW,CAAC;AAMlB,WAAS,SAAS,MAAM,OAAO;AAC9B,UAAML,QAAO;AAAA,MACZ;AAAA,MACA,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA,QAID,CAAC,GAAG,MAAM,MAAM;AAAA,UACpB;AAAA,IACJ;AACA,aAAS,IAAI,IAAIA;AACjB,oBAAgB,QAAQ,MAAM;AAAA,MAC7B,MAAM;AACL,eAAO,IAAIA,KAAI;AAAA,MAChB;AAAA,MACA,YAAY;AAAA,IACb,CAAC;AAAA,EACF;AAEA,aAAWA,SAAQ,QAAQ,SAAS,CAAC,GAAG;AACvC;AAAA,MACCA;AAAA;AAAA,MAEA,QAAQ,MAAMA,KAAI;AAAA,IACnB;AAAA,EACD;AAKA,QAAM,cAAc,IAAI,MAAM,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA,IAKrC,KAAK,CAAC,QAAQ,aAAa;AAC1B,UAAI,OAAO,aAAa;AAAU,eAAO,OAAO,QAAQ;AACxD,UAAI,EAAE,YAAY,WAAW;AAC5B,iBAAS,UAAU,MAAS;AAAA,MAC7B;AACA,aAAO,OAAO,QAAQ;AAAA,IACvB;AAAA,EACD,CAAC;AACD,QAAM,eAAe;AAAA,IACpB;AAAA;AAAA,IAEA,MAAM;AAAA,EACP;AAEA,MAAI,CAAC,WAAW,QAAQ,IAAI,MAAMK,YAAW;AAAA,IAC5C,GAAG;AAAA;AAAA,IAEH,OAAO;AAAA,EACR,CAAC;AAED,QAAM;AAAA;AAAA,IACsF;AAAA,MAC1F,MAAM,CAAC,UAAU;AAChB,mBAAW,CAACL,OAAM,KAAK,KAAK,OAAO,QAAQ,KAAK,GAAG;AAClD,cAAIA,SAAQ,UAAU;AACrB,gBAAI,SAASA,KAAI,GAAG,KAAK;AAAA,UAC1B,OAAO;AACN,qBAASA,OAAM,KAAK;AACpB,gBAAI,cAAc,WAAW;AAAA,UAC9B;AAAA,QACD;AAAA,MACD;AAAA,MACA;AAAA,IACD;AAAA;AAED,aAAWC,QAAO,OAAO,KAAK,aAAa,CAAC,CAAC,GAAG;AAC/C,oBAAgB,QAAQA,MAAK;AAAA,MAC5B,MAAM;AAEL,eAAO,UAAUA,IAAG;AAAA,MACrB;AAAA;AAAA,MAEA,IAAI,OAAO;AAEV,kBAAUA,IAAG,IAAI;AAAA,MAClB;AAAA,MACA,YAAY;AAAA,IACb,CAAC;AAAA,EACF;AAEA,SAAO;AACR;AAsBO,SAAS,MAAMI,YAAW,SAAS;AA7/F1C;AA8/FC,kBAAgB;AAChB,QAAM,oBAAoB,oBAAI,IAAI;AAClC,QAAM,YAAY,QAAQ;AAC1B,QAAM,QAAQ,kBAAkB,WAAW,QAAQ,SAAS,KAAK;AACjE,QAAM;AAAA;AAAA,IAAwC,UAAU;AAAA;AACxD,QAAM,qBAAqB,uBAAuB,WAAW;AAC7D,QAAM,8BAA8B;AAIpC,MAAI,YAAY;AAEhB,MAAI;AAEH,QAAI,SAAS;AACb,QAAI,uBAAuB,MAAM;AAChC,eAAS,MAAM;AACf,gBAAU,YAAY,MAAM;AAAA,IAC7B;AACA,mCAA+B,kBAAkB;AACjD,UAAMC,UAAS;AAAA,MACd,MAAM;AACL,YAAI,QAAQ,SAAS;AACpB,eAAK,CAAC,CAAC;AACsD,UAC5D,0BACC,UAAU,QAAQ;AAAA,QACrB;AAEA,oBAAYD,WAAU,QAAQ,QAAQ,SAAS,CAAC,GAAG,QAAQ,UAAU,CAAC,CAAC;AACvE,YAAI,QAAQ,SAAS;AACpB,cAAI;AAAA,QACL;AAAA,MACD;AAAA,MACA;AAAA,MACA;AAAA,IACD;AACA,UAAM,SAASC;AAAA,EAChB,SAAS,OAAO;AACf,QAAI,QAAQ,YAAY,SAAS,uBAAuB,MAAM;AAE7D,cAAQ;AAAA,QACP;AAAA,QACA;AAAA,MACD;AACA,aAAO,kBAAkB;AACzB,kBAAY,OAAO;AACnB,qCAAmB,GAAG,EAAE,MAAxB,mBAA2B,gBAA3B,mBAAwC;AACxC,aAAO,MAAMD,YAAW,OAAO;AAAA,IAChC,OAAO;AACN,YAAM;AAAA,IACP;AAAA,EACD,UAAE;AACD,mCAA+B,2BAA2B;AAAA,EAC3D;AACA,QAAM,uBAAuB,yBAAyB,KAAK,MAAM,SAAS;AAG1E,QAAM,eAAe,CAAC,WAAW;AAChC,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACvC,YAAM,aAAa,OAAO,CAAC;AAC3B,UAAI,CAAC,kBAAkB,IAAI,UAAU,GAAG;AACvC,0BAAkB,IAAI,UAAU;AAChC,kBAAU;AAAA,UACT;AAAA,UACA;AAAA,UACA,uBAAuB,SAAS,UAAU,IACvC;AAAA,YACA,SAAS;AAAA,UACT,IACA;AAAA,QACJ;AAAA,MACD;AAAA,IACD;AAAA,EACD;AACA,eAAa,WAAW,oBAAoB,CAAC;AAC7C,qBAAmB,IAAI,YAAY;AAEnC,SAAO;AAAA,IACN;AAAA,IACA,MAAM;AACL,iBAAW,cAAc,mBAAmB;AAC3C,kBAAU,oBAAoB,YAAY,oBAAoB;AAAA,MAC/D;AACA,yBAAmB,OAAO,YAAY;AACtC,YAAM,MAAM,MAAM;AAClB,UAAI,QAAQ,MAAM;AACjB,eAAO,GAAG;AAAA,MACX;AACA,UAAI,uBAAuB,MAAM;AAChC,eAAO,kBAAkB;AAAA,MAC1B;AACA;AAAA;AAAA,QAAiE,MAAM;AAAA,MAAO;AAAA,IAC/E;AAAA,EACD;AACD;AAMO,SAAS,aAAa,OAAO;AACnC,aAAWL,SAAQ,OAAO;AAEzB,UAAMA,KAAI;AAAA,EACX;AACD;AAMO,SAAS,eAAe,OAAO;AACrC,UAAQ,OAAO,KAAK;AACpB,QAAM,YAAY,EAAE,GAAG,MAAM,QAAQ;AACrC,MAAI,MAAM;AAAU,cAAU,UAAU,MAAM;AAC9C,SAAO;AACR;AAMO,SAAS,eAAe,gBAAgB;AAC9C,QAAM,QAAQ,qBAAqB;AACnC,gBAAc,MAAM;AACnB,mBAAe;AACf,WAAO,MAAM;AACZ,UAAI,MAAM,QAAQ,MAAM;AACvB,eAAO,MAAM,GAAG;AAAA,MACjB;AAAA,IACD;AAAA,EACD,GAAG,KAAK;AACT;AAOA,eAAsB,cAAc,QAAQ,gBAAgB,QAAQ;AAInE,QAAM,QAAQ,QAAQ;AACtB,QAAM,mBAAmB,mBAAmB,MAAM;AAClD,MAAI,CAAC,iBAAiB,eAAe,cAAc,GAAG;AACrD,UAAMO,SAAQ,eAAe,OAAO;AACpC,IAAAA,OAAM,KAAK;AACX,IAAAA,OAAM,cAAc;AACpB;AAAA;AAAA,MAAsC,iBAAkB,QAAQ;AAAA,MAAkBA;AAAA,IAAK;AAAA,EACxF;AACD;AAKA,SAAS,mBAAmB,MAAM;AACjC,MAAI,CAAC;AAAM,WAAO;AAClB,QAAM,OAAO,KAAK,cAAc,KAAK,YAAY,IAAI,KAAK;AAC1D,MAAI;AAAA,EAAmC,KAAM,MAAM;AAClD;AAAA;AAAA,MAAkC;AAAA;AAAA,EACnC;AACA;AAAA;AAAA,IAAgC,KAAK;AAAA;AACtC;AAQO,SAAS,cAAc,SAAS,UAAU,iBAAiB;AAEjE,QAAM,OAAO,SAAS,cAAc,KAAK;AACzC,QAAM,YAAY,SAAS,cAAc,KAAK;AAC9C,QAAM,MAAM,SAAS,cAAc,KAAK;AACxC,QAAM,KAAK,SAAS,cAAc,IAAI;AACtC,QAAM,KAAK,SAAS,cAAc,IAAI;AACtC,QAAM,IAAI,SAAS,cAAc,GAAG;AACpC,KAAG,cAAc;AACjB,KAAG,cAAc;AACjB,IAAE,cAAc;AAChB,MAAI,YAAY,EAAE;AAClB,MAAI,YAAY,EAAE;AAClB,MAAI,iBAAiB;AACpB,UAAM,iBAAiB,SAAS,cAAc,KAAK;AACnD,eAAW,QAAQ,iBAAiB;AACnC,YAAM,YAAY,SAAS,cAAc,KAAK;AAC9C,YAAM,mBAAmB,SAAS,cAAc,MAAM;AACtD,uBAAiB,cAAc,OAAO,KAAK,IAAI;AAC/C,YAAM,cAAc,SAAS,cAAc,MAAM;AACjD,kBAAY,cAAc,KAAK;AAC/B,UAAI,KAAK,WAAW;AACnB,kBAAU,MAAM,UAAU;AAAA,MAC3B,OAAO;AACN,kBAAU,MAAM,UAAU;AAAA,MAC3B;AACA,uBAAiB,MAAM,UAAU;AACjC,gBAAU,YAAY,gBAAgB;AACtC,gBAAU,YAAY,WAAW;AACjC,qBAAe,YAAY,SAAS;AAAA,IACrC;AACA,QAAI,YAAY,cAAc;AAAA,EAC/B;AACA,KAAG,MAAM,UAAU;AACnB,KAAG,MAAM,UACR;AACD,IAAE,MAAM,UAAU;AAClB,OAAK,MAAM,UACV;AACD,YAAU,MAAM,UAAU;AAC1B,MAAI,YAAY,CAAC;AACjB,YAAU,YAAY,GAAG;AACzB,OAAK,YAAY,SAAS;AAC1B,WAAS,KAAK,YAAY,IAAI;AAE9B,UAAQ,MAAM,yBAAyB,OAAO;AAC/C;;;ACntGO,IAAM,SAAS;AACf,IAAM,UAAU,KAAK;AACrB,IAAM,SAAS,KAAK;AACpB,IAAM,aAAa,KAAK;AACxB,IAAM,gBAAgB,KAAK;AAC3B,IAAM,cAAc,KAAK;AAChC,IAAM,UAAU,KAAK;AACrB,IAAM,UAAU,KAAK;AACd,IAAM,QAAQ,KAAK;AACnB,IAAM,QAAQ,KAAK;AACnB,IAAM,cAAc,KAAK;AACzB,IAAM,QAAQ,KAAK;AACnB,IAAM,YAAY,KAAK;AAE9B,IAAM,YAAY,SAAS,aAAa,gBAAgB;AAExD,IAAM,kBAAkB;AACxB,IAAM,aAAa;AACnB,IAAM,eAAe,OAAO;AAErB,IAAM,gBAAgB,OAAO;AAGpC,IAAI,yBAAyB;AAE7B,IAAI,uBAAuB;AAC3B,IAAI,iBAAiB;AAErB,IAAI,oBAAoB;AAIxB,IAAI,wCAAwC,CAAC;AAG7C,IAAI,yBAAyB,CAAC;AAG9B,IAAI,uBAAuB,CAAC;AAC5B,IAAI,cAAc;AAIlB,IAAI,mBAAmB;AAGhB,IAAI,iBAAiB;AAG5B,IAAI,uBAAuB;AAC3B,IAAI,6BAA6B;AAEjC,IAAI,gCAAgC;AAE7B,IAAI,qBAAqB;AAEhC,IAAI,6BAA6B;AAGjC,IAAI,0BAA0B;AAG9B,IAAI,wBAAwB;AAE5B,IAAI,sBAAsB;AAC1B,IAAI,mBAAmB,oBAAI,IAAI;AAIxB,IAAI,gBAAgB;AAIpB,IAAI,4BAA4B;AAChC,IAAI,SAAS;AAcb,SAAS,yBAAyB,OAAO;AAC/C,QAAM,SAAS;AACf,SAAO;AAAA,IACN,SAAS;AAAA,IACT;AAAA,IACA;AAAA,IACA,WAAW;AAAA,IACX,SAAS;AAAA,IACT,WAAW;AAAA,IACX,SAAS;AAAA,IACT,OAAO;AAAA,IACP,kBAAkB;AAAA,EACnB;AACD;AAMA,SAAS,SAAS,SAAS;AAC1B,QAAM,oBAAoB,WAAW;AACrC,SAAO,sBAAsB,QAAQ,kBAAkB;AACxD;AAeA,SAAS,eAAe,GAAG,GAAG;AAC7B,SAAO,MAAM;AACd;AAQA,SAAS,qBAAqB,OAAO,OAAO;AAC3C,SAAO;AAAA,IACN,GAAG;AAAA;AAAA,IAEH,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,EACJ;AACD;AASA,SAAS,0BAA0B,OAAO,OAAO,OAAO;AACvD,SAAO;AAAA,IACN,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,EACJ;AACD;AAOA,SAAS,eAAe,eAAe,YAAY;AAClD,QAAM,aAAa,cAAc;AACjC,MAAI,eAAe,MAAM;AACxB,kBAAc,IAAI,CAAC,UAAU;AAAA,EAC9B,OAAO;AACN,eAAW,KAAK,UAAU;AAAA,EAC3B;AACD;AAOA,SAAS,gBAAgB,QAAQ;AAChC,QAAM,QAAQ,OAAO;AACrB,OAAK,QAAQ,WAAW,KAAK,OAAO,MAAM,eAAe;AACxD,WAAO;AAAA,EACR;AACA,OAAK,QAAQ,iBAAiB,GAAG;AAChC,UAAM;AAAA;AAAA,MAA0E,OAAQ;AAAA;AACxF,QAAI,iBAAiB,MAAM;AAC1B,YAAM,SAAS,aAAa;AAC5B,UAAI;AACJ,WAAK,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC5B,cAAM,aAAa,aAAa,CAAC;AAEjC,aAAK,WAAW,IAAI,iBAAiB,KAAK,CAAC,gBAAgB,UAAU,GAAG;AACvE,4BAAkB,YAAY,KAAK;AACnC;AAAA,QACD;AAEA,aAAK,WAAW,IAAI,WAAW,GAAG;AACjC,eAAK,WAAW,IAAI,aAAa,GAAG;AACnC;AAAA;AAAA,cAC4D;AAAA,cAC3D;AAAA,YACD;AAEA,iBAAK,OAAO,IAAI,WAAW,GAAG;AAC7B,qBAAO;AAAA,YACR;AAAA,UACD,OAAO;AACN,mBAAO;AAAA,UACR;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAAA,EACD;AACA,SAAO;AACR;AAOA,SAAS,kBAAkB,QAAQ;AAClC,QAAM,OAAO,OAAO;AACpB,QAAM,wBAAwB;AAC9B,QAAM,8BAA8B;AACpC,QAAM,oBAAoB;AAC1B,QAAM,iBAAiB;AACvB,QAAM,6BAA6B;AACnC,QAAM,yBAAyB;AAC/B,QAAM,oBAAoB,OAAO,IAAI,mBAAmB;AACxD,QAAM,sBAAsB;AAC5B;AAAA,EAA4E;AAC5E,+BAA6B;AAC7B,qBAAmB;AACnB,kBAAgB,OAAO;AACvB,8BAA4B,OAAO;AACnC,0BAAwB,mBAAmB,SAAS,OAAO,IAAI,aAAa;AAC5E,uBAAqB;AAGrB,MAAI,qBAAoB,uEAA2B,qBAAoB,MAAM;AAC5E,8BAA0B,iBAAiB,QAAQ;AAAA,EACpD;AAEA,MAAI;AACH,QAAI;AACJ,QAAI,kBAAkB;AACrB;AAAA,MAA+D;AAAA;AAAA,QACnB,OAAO;AAAA,MACnD;AAAA,IACD,OAAO;AACN;AAAA,MAA8B,KAAM;AAAA,IACrC;AACA,QAAI;AAAA;AAAA,MAAuE,OAAO;AAAA;AAElF,QAAI,yBAAyB,MAAM;AAClC,UAAI;AACJ,sBAAgB,QAAQ,4BAA4B,KAAK;AAEzD,UAAI,iBAAiB,QAAQ,6BAA6B,GAAG;AAC5D,qBAAa,SAAS,6BAA6B,qBAAqB;AACxE,aAAK,IAAI,GAAG,IAAI,qBAAqB,QAAQ,KAAK;AACjD,uBAAa,6BAA6B,CAAC,IAAI,qBAAqB,CAAC;AAAA,QACtE;AAAA,MACD,OAAO;AACN,eAAO;AAAA,QACN,eAAe;AAAA,MAEjB;AAEA,UAAI,CAAC,uBAAuB;AAC3B,aAAK,IAAI,4BAA4B,IAAI,aAAa,QAAQ,KAAK;AAClE,gBAAM,aAAa,aAAa,CAAC;AAEjC,cAAI,WAAW,MAAM,MAAM;AAC1B,uBAAW,IAAI,CAAC,MAAM;AAAA,UACvB,OAAO;AACN,uBAAW,EAAE,KAAK,MAAM;AAAA,UACzB;AAAA,QACD;AAAA,MACD;AAAA,IACD,WAAW,iBAAiB,QAAQ,6BAA6B,aAAa,QAAQ;AACrF,sBAAgB,QAAQ,4BAA4B,KAAK;AACzD,mBAAa,SAAS;AAAA,IACvB;AACA,WAAO;AAAA,EACR,UAAE;AACD,2BAAuB;AACvB,iCAA6B;AAC7B,uBAAmB;AACnB,oBAAgB;AAChB,gCAA4B;AAC5B,4BAAwB;AACxB,yBAAqB;AAAA,EACtB;AACD;AASA,SAAS,gBAAgB,QAAQ,aAAa,gBAAgB;AAC7D,QAAM,eAAe,OAAO;AAC5B,MAAI,iBAAiB,MAAM;AAC1B,QAAI;AACJ,SAAK,IAAI,aAAa,IAAI,aAAa,QAAQ,KAAK;AACnD,YAAM,aAAa,aAAa,CAAC;AACjC,YAAM,YAAY,WAAW;AAC7B,UAAI,mBAAmB;AACvB,UAAI,cAAc,MAAM;AACvB,2BAAmB,UAAU,SAAS;AACtC,YAAI,qBAAqB,GAAG;AAC3B,qBAAW,IAAI;AAAA,QAChB,OAAO;AACN,gBAAM,QAAQ,UAAU,QAAQ,MAAM;AAEtC,oBAAU,KAAK,IAAI,UAAU,gBAAgB;AAC7C,oBAAU,IAAI;AAAA,QACf;AAAA,MACD;AACA,UAAI,kBAAkB,qBAAqB,MAAM,WAAW,IAAI,aAAa,GAAG;AAC/E;AAAA;AAAA,UAC4D;AAAA,UAC3D;AAAA,UACA;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAAA,EACD;AACD;AAOA,SAAS,mBAAmB,QAAQ;AACnC,QAAM,aAAa,OAAO;AAC1B,SAAO,IAAI;AACX,MAAI,eAAe,MAAM;AACxB,QAAI;AACJ,SAAK,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AACvC,YAAM,YAAY,WAAW,CAAC;AAC9B,WAAK,UAAU,IAAI,eAAe,GAAG;AACpC,uBAAe,SAAS;AAAA,MACzB,OAAO;AACN,wBAAgB,WAAW,GAAG,IAAI;AAClC,kBAAU,IAAI;AAAA,MACf;AAAA,IACD;AAAA,EACD;AACD;AAOA,SAAS,aAAa,OAAO,OAAO;AAEnC,MAAIC,iBAAgB;AAEpB,MAAIA,mBAAkB,MAAM;AAC3B,UAAM;AAAA,EACP;AACD;AAMO,SAAS,eAAe,QAAQ;AACtC,OAAK,OAAO,IAAI,eAAe,GAAG;AACjC;AAAA,EACD;AACA,QAAM,WAAW,OAAO;AACxB,QAAM,kBAAkB;AACxB,mBAAiB;AAEjB,MAAI;AACH,uBAAmB,MAAM;AACzB,QAAI,aAAa,MAAM;AACtB,eAAS;AAAA,IACV;AACA,UAAM,oBAAoB,kBAAkB,MAAM;AAClD,QAAI,OAAO,sBAAsB,YAAY;AAC5C,aAAO,IAAI;AAAA,IACZ;AAAA,EACD,SAAS,OAAO;AACf,UAAM,QAAQ,OAAO;AACrB,QAAI,UAAU,MAAM;AACnB,mBAAa,OAAO,KAAK;AAAA,IAC1B,OAAO;AACN,YAAM;AAAA,IACP;AAAA,EACD,UAAE;AACD,qBAAiB;AAAA,EAClB;AACA,QAAM,oBAAoB,OAAO;AACjC,MACC,SAAS,iBAAiB;AAAA,GACzB,OAAO,IAAI,gBAAgB,KAC5B,sCAAsC,SAAS,GAC9C;AACD,4BAAwB,iBAAiB;AAAA,EAC1C;AACD;AAMA,SAAS,qBAAqB,SAAS;AACtC,QAAM,SAAS,QAAQ;AACvB,MAAI,SAAS,GAAG;AACf,QAAI,cAAc,KAAK;AACtB,YAAM,IAAI;AAAA,QACT;AAAA,MAED;AAAA,IACD;AACA;AACA,QAAI;AACJ,SAAK,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC5B,YAAM,SAAS,QAAQ,CAAC;AACxB,YAAM,QAAQ,OAAO;AACrB,WAAK,SAAS,YAAY,YAAY,GAAG;AACxC,YAAI,gBAAgB,MAAM,GAAG;AAC5B,4BAAkB,QAAQ,KAAK;AAC/B,yBAAe,MAAM;AAAA,QACtB,YAAY,QAAQ,iBAAiB,GAAG;AACvC,4BAAkB,QAAQ,KAAK;AAAA,QAChC;AAAA,MACD;AAAA,IACD;AACA,YAAQ,SAAS;AAAA,EAClB;AACD;AAEA,SAAS,oBAAoB;AAC5B,yBAAuB;AACvB,MAAI,cAAc,KAAK;AACtB;AAAA,EACD;AACA,QAAM,yCAAyC;AAC/C,QAAM,0BAA0B;AAChC,0CAAwC,CAAC;AACzC,2BAAyB,CAAC;AAC1B,uBAAqB,sCAAsC;AAC3D,uBAAqB,uBAAuB;AAC5C,MAAI,CAAC,sBAAsB;AAC1B,kBAAc;AAAA,EACf;AACD;AAOO,SAAS,gBAAgB,QAAQ,MAAM;AAC7C,QAAM,QAAQ,OAAO;AACrB,MAAI,SAAS,QAAQ,iBAAiB,GAAG;AACxC,mBAAe,MAAM;AACrB,sBAAkB,QAAQ,KAAK;AAAA,EAChC,OAAO;AACN,QAAI,2BAA2B,iBAAiB;AAC/C,UAAI,CAAC,sBAAsB;AAC1B,+BAAuB;AACvB,uBAAe,iBAAiB;AAAA,MACjC;AAAA,IACD;AACA,SAAK,QAAQ,YAAY,GAAG;AAC3B,6BAAuB,KAAK,MAAM;AAAA,IACnC,OAAO;AACN,4CAAsC,KAAK,MAAM;AAAA,IAClD;AAAA,EACD;AACD;AAEA,SAAS,eAAe;AACvB,mBAAiB;AACjB,QAAM,QAAQ,qBAAqB,MAAM;AACzC,yBAAuB,CAAC;AACxB,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACtC,UAAM,CAAC,EAAE;AAAA,EACV;AACD;AAMO,SAAS,cAAc,IAAI;AACjC,MAAI,CAAC,gBAAgB;AACpB,qBAAiB;AACjB,eAAW,cAAc,CAAC;AAAA,EAC3B;AACA,uBAAqB,KAAK,EAAE;AAC7B;AAKO,SAAS,6BAA6B;AAC5C,QAAM,UAAU,CAAC;AACjB,WAAS,IAAI,GAAG,IAAI,sCAAsC,QAAQ,KAAK;AACtE,UAAMC,UAAS,sCAAsC,CAAC;AACtD,SAAKA,QAAO,IAAI,mBAAmB,KAAKA,QAAO,MAAM,2BAA2B;AAC/E,cAAQ,KAAKA,OAAM;AACnB,4CAAsC,OAAO,GAAG,CAAC;AACjD;AAAA,IACD;AAAA,EACD;AACA,uBAAqB,OAAO;AAC7B;AAMO,SAAS,wBAAwB,SAAS;AAChD,QAAM,UAAU,CAAC;AACjB,WAAS,IAAI,GAAG,IAAI,sCAAsC,QAAQ,KAAK;AACtE,UAAMA,UAAS,sCAAsC,CAAC;AACtD,SAAKA,QAAO,IAAI,gBAAgB,KAAKA,QAAO,MAAM,SAAS;AAC1D,cAAQ,KAAKA,OAAM;AACnB,4CAAsC,OAAO,GAAG,CAAC;AACjD;AAAA,IACD;AAAA,EACD;AACA,uBAAqB,OAAO;AAC7B;AAOO,SAAS,UAAU,IAAI;AAC7B,QAAM,0BAA0B;AAChC,QAAM,yCAAyC;AAC/C,QAAM,0BAA0B;AAChC,MAAI;AAEH,UAAM,yBAAyB,CAAC;AAGhC,UAAM,UAAU,CAAC;AACjB,6BAAyB;AACzB,kBAAc;AACd,4CAAwC;AACxC,6BAAyB;AACzB,yBAAqB,sCAAsC;AAC3D,yBAAqB,uBAAuB;AAC5C,QAAI,OAAO,QAAW;AACrB,SAAG;AAAA,IACJ;AACA,QAAI,sCAAsC,SAAS,KAAK,QAAQ,SAAS,GAAG;AAC3E,gBAAU;AAAA,IACX;AACA,QAAI,gBAAgB;AACnB,mBAAa;AAAA,IACd;AAAA,EACD,UAAE;AACD,6BAAyB;AACzB,4CAAwC;AACxC,6BAAyB;AAAA,EAC1B;AACD;AAMA,eAAsB,OAAO;AAC5B,QAAM,QAAQ,QAAQ;AAGtB,YAAU;AACX;AAQA,SAAS,eAAe,QAAQ,gBAAgB;AAC/C,QAAM,QAAQ,kBAAkB,MAAM;AACtC,QAAM,SACL,yBAA0B,mBAAmB,SAAS,OAAO,IAAI,aAAa,IAC3E,QACA;AACJ,oBAAkB,QAAQ,MAAM;AAChC,QAAM;AAAA;AAAA,IAA8D,OAAO;AAAA;AAC3E,MAAI,CAAC,OAAO,OAAO,OAAO,CAAC,GAAG;AAC7B,WAAO,IAAI;AACX,0BAAsB,QAAQ,OAAO,cAAc;AAAA,EACpD;AACD;AAYO,SAAS,UAAU,OAAO,YAAY,QAAQ;AAEpD,MAAI,QAAQ,OAAO,UAAU;AAC7B,QAAM,SAAS,UAAU;AAEzB,MAAI,QAAQ;AACX,YAAQ;AAAA,MACP,OAAO;AAAA,MACP,YAAY;AAAA,MACZ,OAAO,OAAO,aAAa;AAAA,MAC3B,aAAa;AAAA,IACd;AAMA,WAAO,UAAU,IAAI;AAAA,EACtB;AAEA,MAAI,UAAU,MAAM,UAAU,OAAO;AACpC,UAAM,YAAY;AAClB,UAAM,QAAQ,SAAS;AACvB,UAAM,cAAc,wBAAwB,OAAO,MAAM,KAAK;AAAA,EAC/D;AAEA,QAAM,QAAQ,IAAI,MAAM,KAAK;AAG7B,SAAO,UAAU,gBAAgB,MAAM,aAAa;AACrD;AAOA,SAAS,wBAAwB,OAAOC,SAAQ;AAC/C,MAAI,SAAS,MAAM;AAClB,QAAIA,SAAQ,MAAS;AACrB,WAAO;AAAA,EACR;AAGA,QAAM,MAAM,CAAC,MAAM;AAClB,iCAA6B;AAC7B,QAAIA,SAAQ,CAAC;AACb,iCAA6B;AAAA,EAC9B;AACA,SAAO,mBAAmB,OAAO,GAAG;AACrC;AASO,SAAS,UAAU,OAAO,OAAO;AACvC,QAAM,IAAI,KAAK;AACf,SAAO;AACR;AAMO,SAAS,uBAAuB,QAAQ;AAC9C,YAAU,MAAM;AACf,QAAI;AACJ,SAAK,cAAc,QAAQ;AAC1B,YAAM,MAAM,OAAO,UAAU;AAC7B,UAAI,YAAY;AAAA,IAGjB;AAAA,EACD,CAAC;AACF;AASO,SAAS,UAAU,IAAI;AAC7B,QAAM,6BAA6B;AACnC,MAAI;AACH,wBAAoB;AACpB,WAAO,GAAG;AAAA,EACX,UAAE;AACD,wBAAoB;AAAA,EACrB;AACD;AAOO,SAAS,IAAI,QAAQ;AAC3B,QAAM,QAAQ,OAAO;AACrB,OAAK,QAAQ,eAAe,GAAG;AAC9B,WAAO,OAAO;AAAA,EACf;AAEA,MAAI,qBAAqB,+BAA+B;AACvD,8BAA0B;AAAA,EAC3B;AAEA,MAAI,qBAAqB;AACxB,qBAAiB,IAAI,MAAM;AAAA,EAC5B;AAGA,MAAI,qBAAqB,SAAS,iBAAiB,IAAI,aAAa,KAAK,CAAC,oBAAoB;AAC7F,UAAM,WAAW,iBAAiB,IAAI,aAAa;AACnD,UAAM,eAAe,iBAAiB;AACtC,QACC,yBAAyB,QACzB,iBAAiB,QACjB,aAAa,0BAA0B,MAAM,UAC7C,EAAE,WAAW,mBAAmB,OAC/B;AACD;AAAA,IACD,WAAW,yBAAyB,MAAM;AACzC,6BAAuB,CAAC,MAAM;AAAA,IAC/B,WAAW,WAAW,qBAAqB,qBAAqB,SAAS,CAAC,GAAG;AAC5E,2BAAqB,KAAK,MAAM;AAAA,IACjC;AAAA,EACD;AAEA,OAAK,QAAQ,aAAa,KAAK,gBAAgB,MAAM,GAAG;AACvD;AAAA;AAAA,MAA0E;AAAA,MAAS;AAAA,IAAK;AAAA,EACzF;AACA,SAAO,OAAO;AACf;AAQO,SAAS,IAAI,QAAQ,OAAO;AAClC,mBAAiB,QAAQ,KAAK;AAC9B,SAAO;AACR;AAQO,SAAS,SAAS,QAAQ,OAAO;AACvC,YAAU,MAAM,iBAAiB,QAAQ,KAAK,CAAC;AAChD;AAUO,SAAS,OAAO,oBAAoB;AAC1C,QAAM,2BAA2B;AACjC,QAAM,iCAAiC;AACvC,4BAA0B;AAC1B,kCAAgC;AAChC,MAAI;AACH,UAAM,QAAQ,mBAAmB;AACjC,QAAI,4BAA4B,MAAM;AACrC,aAAO;AAAA,IACR;AACA,WAAO;AAAA,EACR,UAAE;AACD,8BAA0B;AAC1B,oCAAgC;AAAA,EACjC;AACD;AAQO,SAAS,yBAAyB,IAAI;AAC5C,QAAM,+BAA+B;AACrC,QAAM,4BAA4B;AAClC,wBAAsB;AACtB,qBAAmB,oBAAI,IAAI;AAC3B,MAAI;AACH,YAAQ,EAAE;AAAA,EACX,UAAE;AACD,0BAAsB;AACtB,QAAIC;AACJ,SAAKA,WAAU,kBAAkB;AAChC,gCAA0B,IAAIA,OAAM;AAAA,IACrC;AACA,uBAAmB;AAAA,EACpB;AACA,MAAI;AACJ,OAAK,UAAU,kBAAkB;AAChC;AAAA,MAAO;AAAA,MAAQ;AAAA;AAAA,IAAwB;AAAA,EACxC;AACA,SAAO;AACR;AAOO,SAAS,OAAOD,SAAQ,OAAO;AACrC;AAAA,IACCA;AAAA,IACA,QAAQ,MAAM,IAAIA,OAAM,CAAC;AAAA,EAC1B;AACA,SAAO;AACR;AASO,SAAS,aAAa,OAAO,YAAY,WAAW;AAC1D,QAAM,IAAI,SAAS;AACnB,SAAO;AACR;AAOO,SAAS,mBAAmB,QAAQ,OAAO;AACjD,QAAM,QAAQ,OAAO;AACrB,QAAM,oBAAoB,QAAQ,WAAW;AAC7C,MAAI,qBAAqB,OAAO;AAC/B,WAAO,KAAK;AACZ,QAAI,CAAC,UAAU,QAAQ,eAAe,MAAM,QAAQ,WAAW,GAAG;AACjE;AAAA;AAAA,QAAkE;AAAA,QAAS;AAAA,MAAK;AAAA,IACjF;AAAA,EACD;AACA,QAAM,aAAa,OAAO;AAC1B,MAAI,eAAe,MAAM;AACxB,QAAI;AACJ,SAAK,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AACvC,yBAAmB,WAAW,CAAC,GAAG,KAAK;AAAA,IACxC;AAAA,EACD;AACD;AASA,SAAS,sBAAsB,QAAQ,WAAW,gBAAgB;AACjE,QAAM,QAAQ,SAAS,OAAO,CAAC;AAC/B,QAAM,YAAY,OAAO;AACzB,MAAI,cAAc,MAAM;AACvB,UAAM,SAAS,UAAU;AACzB,QAAI;AACJ,SAAK,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC5B,YAAM,WAAW,UAAU,CAAC;AAC5B,YAAM,QAAQ,SAAS;AACvB,YAAM,WAAW,QAAQ,aAAa;AACtC,YAAM,SAAS,QAAQ,WAAW;AAIlC,UAAK,SAAS,CAAC,YAAc,CAAC,kBAAkB,CAAC,UAAU,aAAa,gBAAiB;AACxF;AAAA,MACD;AACA,wBAAkB,UAAU,SAAS;AAIrC,WAAK,QAAQ,WAAW,KAAM,SAAS,SAAU;AAChD,aAAK,SAAS,IAAI,eAAe,GAAG;AACnC;AAAA;AAAA,YAAkE;AAAA,YAAW;AAAA,UAAK;AAAA,QACnF,OAAO;AACN,gCAAsB,UAAU,aAAa,cAAc;AAAA,QAC5D;AAAA,MACD;AAAA,IACD;AAAA,EACD;AACD;AAQO,SAAS,iBAAiB,QAAQ,OAAO;AAC/C,MACC,CAAC,sBACD,CAAC,8BACD,qBAAqB,QACrB,SAAS,OAAO,CAAC,MAChB,iBAAiB,IAAI,aAAa,GAClC;AACD,UAAM,IAAI;AAAA,MACT;AAAA;AAAA;AAAA,IAGD;AAAA,EACD;AACA,OACE,OAAO,IAAI,YAAY,KACxB;AAAA,EAAuD,OAAO,EAAG,OAAO,OAAO,CAAC,GAC/E;AACD,UAAM,oBAAoB,OAAO;AACjC,WAAO,IAAI;AASX,QACC,SAAS,iBAAiB,KAC1B,mBAAmB,QACnB,eAAe,MAAM,SACpB,eAAe,IAAI,WAAW,KAC/B,yBAAyB,QACzB,qBAAqB,SAAS,MAAM,GACnC;AACD,wBAAkB,gBAAgB,KAAK;AACvC,sBAAgB,gBAAgB,KAAK;AAAA,IACtC;AACA,0BAAsB,QAAQ,OAAO,IAAI;AAIzC,QAAI,mBAAmB,QAAQ,sCAAsC,WAAW,GAAG;AAClF,YAAM,mBAAmB,uDAAmB;AAC5C,UAAI,oBAAoB,MAAM;AAC7B,yBAAiB,OAAO;AAAA;AAAA,UAA8B,CAAC,MAAM,EAAE;AAAA,QAAC;AAChE,cAAM,UAAU,eAAe,MAAM;AACpC,yBAAe,OAAO;AACtB,2BAAiB,MAAM;AAAA;AAAA,YAA8B,CAAC,MAAM,EAAE;AAAA,UAAC;AAAA,QAChE,CAAC;AAAA,MACF;AAAA,IACD;AAAA,EACD;AACD;AAOO,SAAS,eAAe,QAAQ;AACtC,QAAM;AAAA;AAAA,IAA+C,OAAO;AAAA;AAC5D,QAAM,UAAU,OAAO;AACvB,QAAM,QAAQ,OAAO;AACrB,qBAAmB,MAAM;AACzB,kBAAgB,QAAQ,GAAG,IAAI;AAC/B,SAAO,IAAI;AACX,SAAO,IAAI;AACX,SAAO,IAAI;AACX,SAAO,IAAI;AACX,SAAO,IAAI;AACX,SAAO;AAAA,EAAsB;AAC7B,SAAO,IAAI;AACX,SAAO,IAAI;AACX,oBAAkB,QAAQ,SAAS;AACnC,MAAI,YAAY,MAAM;AACrB,QAAI,SAAS,OAAO,GAAG;AACtB,UAAI;AACJ,WAAK,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACpC,gBAAQ,CAAC,EAAE;AAAA,MACZ;AAAA,IACD,OAAO;AACN,cAAQ;AAAA,IACT;AAAA,EACD;AACA,MAAI,aAAa,SAAS,QAAQ,eAAe,GAAG;AACnD,aAAS;AAAA,EACV;AACD;AASO,SAAS,QAAQ,MAAM,QAAQ;AACrC,QAAM,aAAa,mBAAmB;AACtC,QAAM,QAAQ,aAAa,UAAU,UAAU;AAC/C,QAAM;AAAA;AAAA,IACL,0BAA0B,QAAQ,OAAO,eAAe,aAAa;AAAA;AAEtE,SAAO,IAAI;AACX,SAAO,IAAI;AACX,SAAO,IAAI,kBAAkB,MAAM;AACnC,MAAI,CAAC,YAAY;AAChB;AAAA;AAAA,MAAiE;AAAA,MAAiB;AAAA,IAAM;AAAA,EACzF;AACA,SAAO;AACR;AASO,SAAS,OAAO,eAAe,QAAQ;AAC7C,QAAMA,UAAS,qBAAqB,SAAS,OAAO,aAAa;AACjE,EAAAA,QAAO,IAAI;AACX,EAAAA,QAAO,IAAI,kBAAkB,MAAM;AACnC,SAAOA;AACR;AAMA,SAAS,kBAAkB,QAAQ;AAClC,MAAI,WAAW,QAAW;AACzB,WAAO;AAAA,EACR;AACA,QAAM,UAAU;AAChB,MAAI,WAAW,CAAC,QAAQ,WAAW;AAClC,WAAO;AAAA,EACR;AACA,SAAO;AACR;AAUO,SAAS,QAAQ,IAAI;AAC3B,QAAM,sBAAsB;AAC5B,MAAI;AACH,yBAAqB;AACrB,WAAO,GAAG;AAAA,EACX,UAAE;AACD,yBAAqB;AAAA,EACtB;AACD;AAUA,SAAS,uBAAuB,MAAM,MAAM,MAAM,OAAO,UAAU;AAClE,QAAM,SAAS,0BAA0B,OAAO,OAAO,MAAM,KAAK;AAClE,SAAO,IAAI;AACX,SAAO,IAAI;AACX,MAAI,UAAU;AACb,oBAAgB,QAAQ,IAAI;AAAA,EAC7B;AACA,MAAI,mBAAmB,SAAS,OAAO,aAAa,GAAG;AACtD,mBAAe,gBAAgB,MAAM;AAAA,EACtC;AACA,SAAO;AACR;AAMO,SAAS,YAAY,MAAM;AACjC,MAAI,mBAAmB,MAAM;AAC5B,UAAM,IAAI,MAAM,2EAA2E;AAAA,EAC5F;AACA,QAAM,oCACL,eAAe,IAAI,iBACnB,8BAA8B,QAC9B,CAAC,0BAA0B;AAC5B,QAAMD,UAAS;AAAA,IACd;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,CAAC;AAAA,EACF;AACA,MAAI,mCAAmC;AACtC,QAAI;AAAA;AAAA,MAAgE,0BAClE;AAAA;AACF,QAAI,YAAY,MAAM;AACrB;AAAA,MACC,0BACC,UAAU,CAAC;AAAA,IACd;AACA,YAAQ,KAAKA,OAAM;AAAA,EACpB;AACA,SAAOA;AACR;AAMO,SAAS,OAAO,MAAM;AAC5B,SAAO,uBAAuB,QAAQ,MAAM,OAAO,eAAe,IAAI;AACvE;AAMO,SAAS,eAAe,MAAM;AACpC,SAAO,uBAAuB,SAAS,SAAS,MAAM,OAAO,eAAe,IAAI;AACjF;AAOO,SAAS,mBAAmB,MAAM,MAAM;AAC9C,SAAO,uBAAuB,aAAa,SAAS,MAAM,MAAM,eAAe,IAAI;AACpF;AAMO,SAAS,WAAW,MAAM;AAChC,MAAI,mBAAmB,MAAM;AAC5B,UAAM,IAAI;AAAA,MACT;AAAA,IACD;AAAA,EACD;AACA,QAAM,OAAO,mBAAmB,SAAS,eAAe,IAAI,mBAAmB;AAC/E,SAAO;AAAA,IACN;AAAA,IACA,MAAM;AACL,YAAM,MAAM,KAAK;AACjB,iCAA2B;AAC3B,aAAO;AAAA,IACR;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACD;AAMA,SAAS,YAAY,MAAM;AAC1B,SAAO,uBAAuB,aAAa,MAAM,MAAM,eAAe,IAAI;AAC3E;AAUO,SAAS,cAAc,MAAM,QAAQ,eAAe,UAAU,OAAO,OAAO,MAAM;AACxF,MAAI,QAAQ;AACZ,MAAI,SAAS;AACZ,aAAS;AAAA,EACV;AACA,SAAO;AAAA,IAAuB;AAAA;AAAA,IAA2B;AAAA,IAAO;AAAA,IAAM;AAAA,IAAO;AAAA,EAAI;AAClF;AAoBO,SAAS,gBAAgB,QAAQ,YAAY;AACnD,MAAI,UAAU,OAAO;AACrB,MAAI,YAAY,MAAM;AACrB,WAAO,IAAI;AAAA,EACZ,WAAW,SAAS,OAAO,GAAG;AAC7B,YAAQ,KAAK,UAAU;AAAA,EACxB,OAAO;AACN,WAAO,IAAI,CAAC,SAAS,UAAU;AAAA,EAChC;AACD;AAQO,SAAS,kBAAkB,QAAQ,QAAQ;AACjD,QAAM,QAAQ,OAAO;AACrB,OAAK,QAAQ,YAAY,GAAG;AAC3B,SAAK,QAAQ,iBAAiB,GAAG;AAChC,aAAO,KAAK;AAAA,IACb,YAAY,QAAQ,WAAW,GAAG;AACjC,aAAO,KAAK;AAAA,IACb,YAAY,QAAQ,WAAW,GAAG;AACjC,aAAO,KAAK;AAAA,IACb;AACA,WAAO,KAAK;AAAA,EACb;AACD;AAOO,SAAS,UAAU,KAAK;AAC9B,SACC,OAAO,QAAQ,YACf,QAAQ,QACR;AAAA,EAAuD,IAAK,MAAO;AAErE;AAiCO,SAAS,YAAY,WAAWG,MAAK,eAAe,oBAAoB;AAnyC/E;AAoyCC,QAAM,QAAQ,UAAU,SAAS,IAAI,IAAI,SAAS,IAAI;AACtD,QAAM;AAAA;AAAA,IACL,OAAO,MAAM,MAAMA,IAAG,CAAC;AAAA;AAExB,QAAM,qBAAoB,YAAO,yBAAyB,OAAOA,IAAG,MAA1C,mBAA6C;AACvE,MAAI,QAAQ,MAAMA,IAAG;AACrB,QAAM,2BAA2B,UAAU,UAAa,kBAAkB;AAE1E,MACC,UAAU,eAAe,KACzB,gBAAgB,MAAM,SACtB,sBAAsB,UACtB,kBAAkB,MAAM,gBAAgB,GACvC;AACD,QAAI,0BAA0B;AAC7B;AAAA,QACC;AAAA;AAAA,QAEA,qBAAqB,cAAc,IAAI;AAAA,MACxC;AAAA,IACD;AACA,WAAO;AAAA,EACR;AAEA,MAAI,0BAA0B;AAC7B;AAAA,IAEC,qBAAqB,cAAc,IAAI;AAAA,EACzC;AAEA,QAAM,gBAAgB,OAAO,KAAK;AAKlC,QAAM;AAAA;AAAA,IAAkE,0BACtE;AAAA;AACF,MAAI,eAAe;AACnB,MAAI,eAAe;AAEnB,MAAIC,SAAQ;AACZ,cAAY,MAAM;AACjB,UAAMC,SAAQ,UAAU,SAAS,IAAI,IAAI,SAAS,IAAI;AAEtD,UAAM,oBAAoBA,OAAMF,IAAG;AACnC,QAAIC,QAAO;AACV,MAAAA,SAAQ;AACR;AAAA,IACD;AACA,QAAI,cAAc;AACjB,qBAAe;AACf;AAAA,IACD;AAEA,QAAI,UAAU,WAAW,mBAAmB,cAAc,CAAC,GAAG;AAC7D,qBAAe;AAGf,cAAQ,MAAM,iBAAiB,eAAe,iBAAiB,CAAC;AAAA,IACjE;AAAA,EACD,CAAC;AAED,MAAI,UAAU,eAAe,KAAK,sBAAsB,QAAW;AAClE,QAAI,eAAe,CAAC;AACpB,gBAAY,MAAM;AAEjB,YAAM,oBAAoB,IAAI,aAAa;AAC3C,UAAI,cAAc;AACjB,uBAAe;AACf;AAAA,MACD;AACA,UAAI,cAAc;AACjB,uBAAe;AACf;AAAA,MACD;AAEA,UAAI,UAAU,WAAW,mBAAmB,gBAAgB,CAAC,GAAG;AAC/D,uBAAe;AACf,gBAAQ,MAAM,kBAAkB,iBAAiB,CAAC;AAAA,MACnD;AAAA,IACD,CAAC;AAAA,EACF;AAEA;AAAA;AAAA,IAAsD;AAAA;AACvD;AASO,SAAS,KAAK,WAAWD,MAAK;AACpC,SAAO,MAAM;AACZ,UAAM,QAAQ,UAAU,SAAS,IAAI,IAAI,SAAS,IAAI;AACtD;AAAA;AAAA,MAAyB,MAAMA,IAAG;AAAA;AAAA,EACnC;AACD;AAQA,SAAS,UAAU,WAAW,GAAG,GAAG;AACnC,SAAO,YAAY,oBAAoB,GAAG,CAAC,IAAI,eAAe,GAAG,CAAC;AACnE;AAOA,SAAS,oBAAoB,GAAG,GAAG;AAElC,SAAO,KAAK,IAAI,KAAK,IAAI,MAAM;AAChC;AAOO,SAAS,eAAe,GAAG,GAAG;AAEpC,SAAO,KAAK;AAAA;AAAA,IAET,KAAK;AAAA,MACL,MAAM,KAAM,MAAM,QAAQ,OAAO,MAAM,YAAa,OAAO,MAAM;AACrE;AAOO,SAAS,WAAW,GAAG,GAAG;AAChC,SAAO,CAAC,eAAe,GAAG,CAAC;AAC5B;AAGO,SAAS,0BAA0B;AACzC,QAAM,oBAAoB;AAC1B,MAAI,sBAAsB,MAAM;AAC/B,UAAM,IAAI,MAAM,2DAA2D;AAAA,EAC5E;AACA,MAAI,cAAc,kBAAkB;AACpC,MAAI,gBAAgB,MAAM;AACzB,UAAM,iBAAiB,mBAAmB,iBAAiB;AAC3D,kBAAc,kBAAkB,UAAU,IAAI,IAAI,kBAAkB,MAAS;AAAA,EAC9E;AACA,SAAO;AACR;AAMA,SAAS,mBAAmB,mBAAmB;AAC9C,MAAI,SAAS,kBAAkB;AAC/B,SAAO,WAAW,MAAM;AACvB,UAAM,cAAc,OAAO;AAC3B,QAAI,gBAAgB,MAAM;AACzB,aAAO;AAAA,IACR;AACA,aAAS,OAAO;AAAA,EACjB;AACA,SAAO;AACR;AAQO,SAAS,aAAa,SAASG,QAAO;AAt9C7C;AAu9CC,QAAM;AAAA;AAAA,KAA+D,YAAO,OAAO,EAAE,aAAhB,mBACpEA,OAAM;AAAA;AAEP,QAAM,YAAY,SAAS,MAAM,IAAI,OAAO,MAAM,IAAI,CAAC,MAAM;AAC7D,MAAI;AACJ,OAAK,MAAM,WAAW;AAErB,QAAI,UAAU,EAAE,GAAG;AAClB,UAAI,EAAE,EAAE,KAAK,MAAMA,MAAK;AAAA,IACzB,OAAO;AACN,SAAG,KAAK,MAAMA,MAAK;AAAA,IACpB;AAAA,EACD;AACD;AAMO,SAAS,UAAU,QAAQ;AACjC,QAAM,QAAQ,IAAI,MAAM;AACxB,mBAAiB,QAAQ,QAAQ,CAAC;AAClC,SAAO;AACR;AAOO,SAAS,gBAAgB,OAAO,aAAa;AACnD,QAAM,IAAI,cAAc,CAAC;AACzB,SAAO;AACR;AAMO,SAAS,UAAU,QAAQ;AACjC,QAAM,QAAQ,IAAI,MAAM;AACxB,mBAAiB,QAAQ,QAAQ,CAAC;AAClC,SAAO;AACR;AAOO,SAAS,gBAAgB,OAAO,aAAa;AACnD,QAAM,IAAI,cAAc,CAAC;AACzB,SAAO;AACR;AAMO,SAAS,cAAc,QAAQ;AACrC,QAAM,QAAQ,IAAI,MAAM,IAAI;AAC5B,mBAAiB,QAAQ,KAAK;AAC9B,SAAO;AACR;AAOO,SAAS,oBAAoB,OAAO,aAAa;AACvD,QAAM,QAAQ,cAAc;AAC5B,QAAM,IAAI,KAAK;AACf,SAAO;AACR;AAMO,SAAS,cAAc,QAAQ;AACrC,QAAM,QAAQ,IAAI,MAAM,IAAI;AAC5B,mBAAiB,QAAQ,KAAK;AAC9B,SAAO;AACR;AAOO,SAAS,oBAAoB,OAAO,aAAa;AACvD,QAAM,QAAQ,cAAc;AAC5B,QAAM,IAAI,KAAK;AACf,SAAO;AACR;AAOO,SAAS,gBAAgB,IAAI;AACnC,QAAM,IAAI,OAAO,CAAC;AAClB,SAAO,WAAY;AAClB,QAAI,UAAU,WAAW,GAAG;AAC3B,UAAI,GAAG,IAAI,CAAC,IAAI,CAAC;AACjB,aAAO,UAAU,CAAC;AAAA,IACnB,OAAO;AACN,UAAI,CAAC;AACL,aAAO,GAAG;AAAA,IACX;AAAA,EACD;AACD;AAOO,SAAS,oBAAoB,KAAK,MAAM;AAC9C,QAAM,EAAE,GAAG,IAAI;AACf,MAAIH;AACJ,OAAKA,QAAO,MAAM;AACjB,WAAO,IAAIA,IAAG;AAAA,EACf;AACA,SAAO;AACR;AAQO,SAAS,kBAAkB,OAAO,UAAU;AAClD,SAAO,UAAU,SAAY,WAAW;AACzC;AAYO,SAAS,UAAU,IAAI;AAC7B,MAAI,CAAC,QAAQ;AACZ,gBAAY,MAAM,MAAM,QAAQ,EAAE,CAAC;AAAA,EACpC;AACD;AAQO,SAAS,KAAK,OAAO,QAAQ,OAAO,YAAY,OAAO;AAC7D,QAAM,qBAAqB,yBAAyB,KAAK;AACzD,qBAAmB,QAAQ;AAC3B,qBAAmB,YAAY;AAC/B,8BAA4B;AAC7B;AAMO,SAAS,IAAI,WAAW;AAC9B,QAAM,qBAAqB;AAC3B,MAAI,uBAAuB,MAAM;AAChC,QAAI,cAAc,QAAW;AAC5B,yBAAmB,YAAY;AAAA,IAChC;AACA,UAAM,UAAU,mBAAmB;AACnC,QAAI,YAAY,MAAM;AACrB,yBAAmB,UAAU;AAC7B,eAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACxC,wBAAgB,QAAQ,CAAC,GAAG,KAAK;AAAA,MAClC;AAAA,IACD;AACA,gCAA4B,mBAAmB;AAC/C,uBAAmB,UAAU;AAAA,EAC9B;AACD;;;AChpDA,IAAM,qBACL;AAGD,SAAS,QAAQ,KAAK;AACrB,SAAO,mBAAmB,KAAK,GAAG,KAAK,IAAI,YAAY,MAAM;AAC9D;AAMO,SAAS,eAAe,OAAO,MAAM;AAC3C,MAAI,SAAS,QAAQ,OAAO,MAAM,cAAc,YAAY;AAC3D,UAAM,IAAI,MAAM,IAAI,IAAI,4CAA4C;AAAA,EACrE;AACD;AAMO,SAAS,2BAA2B,cAAc;AACxD,QAAM,gBAAgB;AACtB,MAAI;AACH,UAAM,WAAW,aAAa;AAC9B,QAAI,aAAa,UAAa,OAAO,aAAa,UAAU;AAC3D,YAAM,IAAI,MAAM,aAAa;AAAA,IAC9B;AACA,WAAO;AAAA,EACR,SAAS,KAAK;AACb,UAAM,EAAE,QAAQ;AAAA;AAAA,MAA0B;AAAA;AAC1C,QAAI,OAAO,YAAY,YAAY,QAAQ,QAAQ,mBAAmB,MAAM,IAAI;AAC/E,YAAM,IAAI,MAAM,aAAa;AAAA,IAC9B,OAAO;AACN,YAAM;AAAA,IACP;AAAA,EACD;AACD;AAMO,SAAS,8BAA8B,QAAQ;AACrD,QAAM,MAAM,OAAO;AACnB,MAAI,OAAO,QAAQ,GAAG,GAAG;AAExB,YAAQ,KAAK,yBAAyB,GAAG,6CAA6C;AAAA,EACvF;AACD;AAGO,SAAS,6BAA6B,QAAQ;AACpD,QAAM,MAAM,OAAO;AACnB,QAAM,YAAY,OAAO,QAAQ;AACjC,MAAI,OAAO,CAAC,WAAW;AACtB,UAAM,IAAI,MAAM,2DAA2D;AAAA,EAC5E;AACD;AAOO,SAAS,mBAAmB,YAAY,QAAQ;AACtD,QAAM,OAAO,oBAAI,IAAI;AACrB,QAAM,cAAc,WAAW;AAC/B,QAAM,QAAQ,SAAS,WAAW,IAC/B,cACA,eAAe,OACf,CAAC,IACD,MAAM,KAAK,WAAW;AACzB,QAAM,SAAS,MAAM;AACrB,WAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAChC,UAAMI,OAAM,OAAO,MAAM,CAAC,CAAC;AAC3B,QAAI,KAAK,IAAIA,IAAG,GAAG;AAClB,YAAM,IAAI;AAAA,QACT,6DAA6D,KAAK;AAAA,UACjEA;AAAA,QACD,CAAC,QAAQ,CAAC,gBAAgB,MAAM,CAAC,CAAC;AAAA,MACnC;AAAA,IACD;AACA,SAAK,IAAIA,MAAK,CAAC;AAAA,EAChB;AACD;AAMO,SAAS,WAAW,SAAS;AACnC,QAAM,QAAQ,KAAK,IAAI;AACvB,SAAO,MAAM;AACZ,QAAI,KAAK,IAAI,IAAI,QAAQ,SAAS;AACjC,YAAM,IAAI,MAAM,wBAAwB;AAAA,IACzC;AAAA,EACD;AACD;AAEA,IAAM,iBAAiB,OAAO,IAAI,gBAAgB;AAK3C,SAAS,mBAAmB,IAAI;AACtC,KAAG,cAAc,IAAI;AACrB,SAAO;AACR;AAMO,SAAS,iBAAiB,YAAY;AAC5C,MAAI,WAAW,cAAc,MAAM,MAAM;AACxC,UAAM,IAAI;AAAA,MACT;AAAA,IAED;AAAA,EACD;AACA,SAAO;AACR;AAMO,SAAS,mBAAmB,cAAc;AAChD,OAAI,6CAAe,qBAAoB,MAAM;AAC5C,UAAM,IAAI,MAAM,iDAAiD;AAAA,EAClE;AACA,SAAO;AACR;;;AC5HA,IAAI;AAEJ,IAAI,OAAO,gBAAgB,YAAY;AACtC,kBAAgB,cAAc,YAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IA2BzC,YAAY,iBAAiB,SAAS,gBAAgB;AACrD,YAAM;AA1BP;AAAA;AAEA;AAAA;AAEA;AAAA;AAEA;AAAA,kCAAO;AAEP;AAAA,iCAAM,CAAC;AAEP;AAAA,iCAAM;AAEN;AAAA,mCAAQ,CAAC;AAET;AAAA,iCAAM,CAAC;AAEP;AAAA,mCAAQ,oBAAI,IAAI;AAEhB;AAAA;AASC,WAAK,SAAS;AACd,WAAK,MAAM;AACX,UAAI,gBAAgB;AACnB,aAAK,aAAa,EAAE,MAAM,OAAO,CAAC;AAAA,MACnC;AAAA,IACD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOA,iBAAiB,MAAM,UAAU,SAAS;AAIzC,WAAK,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,KAAK,CAAC;AACpC,WAAK,IAAI,IAAI,EAAE,KAAK,QAAQ;AAC5B,UAAI,KAAK,KAAK;AACb,cAAM,QAAQ,KAAK,IAAI,IAAI,MAAM,QAAQ;AACzC,aAAK,MAAM,IAAI,UAAU,KAAK;AAAA,MAC/B;AACA,YAAM,iBAAiB,MAAM,UAAU,OAAO;AAAA,IAC/C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOA,oBAAoB,MAAM,UAAU,SAAS;AAC5C,YAAM,oBAAoB,MAAM,UAAU,OAAO;AACjD,UAAI,KAAK,KAAK;AACb,cAAM,QAAQ,KAAK,MAAM,IAAI,QAAQ;AACrC,YAAI,OAAO;AACV,gBAAM;AACN,eAAK,MAAM,OAAO,QAAQ;AAAA,QAC3B;AAAA,MACD;AAAA,IACD;AAAA,IAEA,MAAM,oBAAoB;AACzB,WAAK,OAAO;AACZ,UAAI,CAAC,KAAK,KAAK;AAOd,YAAS,cAAT,SAAqB,MAAM;AAI1B,iBAAO,CAAC,WAAW;AAClB,kBAAM,OAAO,KAAK,QAAQ,MAAM,MAAM;AACrC,oBAAMC,QAAO,SAAS,cAAc,MAAM;AAC1C,kBAAI,SAAS,WAAW;AACvB,gBAAAA,MAAK,OAAO;AAAA,cACb;AACA,qBAAOA;AAAA,YACR,CAAC;AACD;AAAA,cAAM;AAAA;AAAA,cAAgC;AAAA,YAAK;AAAA,UAC5C;AAAA,QACD;AAnBA,cAAM,QAAQ,QAAQ;AACtB,YAAI,CAAC,KAAK,MAAM;AACf;AAAA,QACD;AAkBA,cAAM,UAAU,CAAC;AACjB,cAAM,iBAAiB,0BAA0B,IAAI;AACrD,mBAAW,QAAQ,KAAK,KAAK;AAC5B,cAAI,QAAQ,gBAAgB;AAC3B,gBAAI,SAAS,WAAW;AACvB,mBAAK,IAAI,WAAW,YAAY,IAAI;AAAA,YACrC,OAAO;AACN,sBAAQ,IAAI,IAAI,YAAY,IAAI;AAAA,YACjC;AAAA,UACD;AAAA,QACD;AACA,mBAAW,aAAa,KAAK,YAAY;AAExC,gBAAM,OAAO,KAAK,MAAM,UAAU,IAAI;AACtC,cAAI,EAAE,QAAQ,KAAK,MAAM;AACxB,iBAAK,IAAI,IAAI,IAAI,yBAAyB,MAAM,UAAU,OAAO,KAAK,OAAO,QAAQ;AAAA,UACtF;AAAA,QACD;AACA,aAAK,MAAM,qBAAqB;AAAA,UAC/B,WAAW,KAAK;AAAA,UAChB,QAAQ,KAAK,cAAc;AAAA,UAC3B,OAAO;AAAA,YACN,GAAG,KAAK;AAAA,YACR;AAAA,UACD;AAAA,QACD,CAAC;AAGD,aAAK,OAAO,cAAc,MAAM;AA3IpC;AA4IK,eAAK,MAAM;AACX,qBAAWC,QAAO,OAAO,KAAK,KAAK,GAAG,GAAG;AACxC,gBAAI,GAAC,UAAK,MAAMA,IAAG,MAAd,mBAAiB;AAAS;AAC/B,iBAAK,IAAIA,IAAG,IAAI,KAAK,IAAIA,IAAG;AAC5B,kBAAM,kBAAkB;AAAA,cACvBA;AAAA,cACA,KAAK,IAAIA,IAAG;AAAA,cACZ,KAAK;AAAA,cACL;AAAA,YACD;AACA,gBAAI,mBAAmB,MAAM;AAC5B,mBAAK,gBAAgB,KAAK,MAAMA,IAAG,EAAE,aAAaA,IAAG;AAAA,YACtD,OAAO;AACN,mBAAK,aAAa,KAAK,MAAMA,IAAG,EAAE,aAAaA,MAAK,eAAe;AAAA,YACpE;AAAA,UACD;AACA,eAAK,MAAM;AAAA,QACZ,CAAC;AAED,mBAAW,QAAQ,KAAK,KAAK;AAC5B,qBAAW,YAAY,KAAK,IAAI,IAAI,GAAG;AACtC,kBAAM,QAAQ,KAAK,IAAI,IAAI,MAAM,QAAQ;AACzC,iBAAK,MAAM,IAAI,UAAU,KAAK;AAAA,UAC/B;AAAA,QACD;AACA,aAAK,MAAM,CAAC;AAAA,MACb;AAAA,IACD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAUA,yBAAyBC,OAAM,WAAW,UAAU;AAjLtD;AAkLG,UAAI,KAAK;AAAK;AACd,MAAAA,QAAO,KAAK,MAAMA,KAAI;AACtB,WAAK,IAAIA,KAAI,IAAI,yBAAyBA,OAAM,UAAU,KAAK,OAAO,QAAQ;AAC9E,iBAAK,QAAL,mBAAU,KAAK,EAAE,CAACA,KAAI,GAAG,KAAK,IAAIA,KAAI,EAAE;AAAA,IACzC;AAAA,IAEA,uBAAuB;AACtB,WAAK,OAAO;AAEZ,cAAQ,QAAQ,EAAE,KAAK,MAAM;AAC5B,YAAI,CAAC,KAAK,MAAM;AACf,eAAK,IAAI,SAAS;AAClB,yBAAe,KAAK,IAAI;AACxB,eAAK,MAAM;AAAA,QACZ;AAAA,MACD,CAAC;AAAA,IACF;AAAA;AAAA;AAAA;AAAA,IAKA,MAAM,gBAAgB;AACrB,aACC,OAAO,KAAK,KAAK,KAAK,EAAE;AAAA,QACvB,CAACD,SACA,KAAK,MAAMA,IAAG,EAAE,cAAc,kBAC7B,CAAC,KAAK,MAAMA,IAAG,EAAE,aAAaA,KAAI,YAAY,MAAM;AAAA,MACvD,KAAK;AAAA,IAEP;AAAA,EACD;AACD;AAQA,SAAS,yBAAyBE,OAAM,OAAO,kBAAkB,WAAW;AAzN5E;AA0NC,QAAM,QAAO,sBAAiBA,KAAI,MAArB,mBAAwB;AACrC,UAAQ,SAAS,aAAa,OAAO,UAAU,YAAY,SAAS,OAAO;AAC3E,MAAI,CAAC,aAAa,CAAC,iBAAiBA,KAAI,GAAG;AAC1C,WAAO;AAAA,EACR,WAAW,cAAc,eAAe;AACvC,YAAQ,MAAM;AAAA,MACb,KAAK;AAAA,MACL,KAAK;AACJ,eAAO,SAAS,OAAO,OAAO,KAAK,UAAU,KAAK;AAAA,MACnD,KAAK;AACJ,eAAO,QAAQ,KAAK;AAAA,MACrB,KAAK;AACJ,eAAO,SAAS,OAAO,OAAO;AAAA,MAC/B;AACC,eAAO;AAAA,IACT;AAAA,EACD,OAAO;AACN,YAAQ,MAAM;AAAA,MACb,KAAK;AAAA,MACL,KAAK;AACJ,eAAO,SAAS,KAAK,MAAM,KAAK;AAAA,MACjC,KAAK;AACJ,eAAO;AAAA,MACR,KAAK;AACJ,eAAO,SAAS,OAAO,CAAC,QAAQ;AAAA,MACjC;AACC,eAAO;AAAA,IACT;AAAA,EACD;AACD;AAKA,SAAS,0BAA0BC,UAAS;AAE3C,QAAM,SAAS,CAAC;AAChB,EAAAA,SAAQ,WAAW,QAAQ,CAAC,SAAS;AACpC;AAAA;AAAA,MAAoC,KAAM,QAAQ;AAAA,IAAS,IAAI;AAAA,EAChE,CAAC;AACD,SAAO;AACR;AAaO,SAAS,sBACf,WACA,kBACA,OACA,WACA,gBACA,QACC;AACD,MAAI,QAAQ,cAAc,cAAc;AAAA,IACvC,cAAc;AACb,YAAM,WAAW,OAAO,cAAc;AACtC,WAAK,QAAQ;AAAA,IACd;AAAA,IACA,WAAW,qBAAqB;AAC/B,aAAO,OAAO,KAAK,gBAAgB,EAAE;AAAA,QAAI,CAACH,UACxC,iBAAiBA,IAAG,EAAE,aAAaA,MAAK,YAAY;AAAA,MACtD;AAAA,IACD;AAAA,EACD;AACA,SAAO,KAAK,gBAAgB,EAAE,QAAQ,CAACE,UAAS;AAC/C,oBAAgB,MAAM,WAAWA,OAAM;AAAA,MACtC,MAAM;AACL,eAAO,KAAK,OAAOA,SAAQ,KAAK,MAAM,KAAK,IAAIA,KAAI,IAAI,KAAK,IAAIA,KAAI;AAAA,MACrE;AAAA,MACA,IAAI,OAAO;AAxSd;AAySI,gBAAQ,yBAAyBA,OAAM,OAAO,gBAAgB;AAC9D,aAAK,IAAIA,KAAI,IAAI;AACjB,mBAAK,QAAL,mBAAU,KAAK,EAAE,CAACA,KAAI,GAAG,MAAM;AAAA,MAChC;AAAA,IACD,CAAC;AAAA,EACF,CAAC;AACD,YAAU,QAAQ,CAAC,aAAa;AAC/B,oBAAgB,MAAM,WAAW,UAAU;AAAA,MAC1C,MAAM;AAjTT;AAkTI,gBAAO,UAAK,QAAL,mBAAW;AAAA,MACnB;AAAA,IACD,CAAC;AAAA,EACF,CAAC;AACD,MAAI,QAAQ;AAEX,YAAQ,OAAO,KAAK;AAAA,EACrB;AACA,YAAU;AAAA,EAA6B;AACvC,SAAO;AACR;;;ACxSO,SAAS,qBAAqB,SAAS;AAE7C,SAAO,IAAI,iBAAiB,OAAO;AACpC;AAeO,SAAS,iBAAiBE,YAAW;AAE3C,SAAO,cAAc,iBAAiB;AAAA;AAAA,IAErC,YAAY,SAAS;AACpB,YAAM;AAAA,QACL,WAAAA;AAAA,QACA,GAAG;AAAA,MACJ,CAAC;AAAA,IACF;AAAA,EACD;AACD;AAjDA;AAmDA,IAAM,mBAAN,MAAuB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EActB,YAAY,SAAS;AAZrB;AAAA,gCAAU,CAAC;AAGX;AAAA;AAUC,uBAAK,WAAc,WAAW,QAAQ,WAAW;AAAA,MAChD,QAAQ,QAAQ;AAAA,MAChB,OAAO,EAAE,GAAG,QAAQ,OAAO,UAAU,mBAAK,SAAQ;AAAA,MAClD,SAAS,QAAQ;AAAA,MACjB,WAAW,QAAQ;AAAA,MACnB,OAAO,QAAQ;AAAA,MACf,SAAS,QAAQ;AAAA,IAClB,CAAC;AAED,eAAWC,QAAO,OAAO,KAAK,mBAAK,UAAS,GAAG;AAC9C,UAAIA,SAAQ,UAAUA,SAAQ;AAAY;AAE1C,sBAAgB,MAAMA,MAAK;AAAA,QAC1B,MAAM;AACL,iBAAO,mBAAK,WAAUA,IAAG;AAAA,QAC1B;AAAA;AAAA,QAEA,IAAI,OAAO;AACV,6BAAK,WAAUA,IAAG,IAAI;AAAA,QACvB;AAAA,QACA,YAAY;AAAA,MACb,CAAC;AAAA,IACF;AAAA,EACD;AAAA;AAAA,EAGA,KAAK,OAAO;AACX,uBAAK,WAAU,KAAK,KAAK;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAIC,QAAO,UAAU;AACpB,uBAAK,SAAQA,MAAK,IAAI,mBAAK,SAAQA,MAAK,KAAK,CAAC;AAG9C,UAAM,KAAK,IAAI,SAAS,SAAS,KAAK,MAAM,GAAG,IAAI;AACnD,uBAAK,SAAQA,MAAK,EAAE,KAAK,EAAE;AAC3B,WAAO,MAAM;AACZ,yBAAK,SAAQA,MAAK,IAAI,mBAAK,SAAQA,MAAK,EAAE;AAAA;AAAA,QAA8B,CAAC,OAAO,OAAO;AAAA,MAAE;AAAA,IAC1F;AAAA,EACD;AAAA,EAEA,WAAW;AACV,uBAAK,WAAU,SAAS;AAAA,EACzB;AACD;AA9DC;AAGA;",
  "names": ["element", "child", "key", "key", "child", "text", "class_name", "key", "html", "sibling", "transition", "key", "style", "out", "effect", "transition", "transition_block", "html", "event", "class_name", "effect", "element", "listeners", "selected", "group", "prop", "value", "transition", "element", "component", "transition", "render", "effect", "key", "transition", "render", "effect", "block", "is_controlled", "each", "flags", "anchor_node", "component", "action", "prop", "key", "element", "rest_props", "get", "component", "effect", "style", "current_block", "effect", "source", "signal", "key", "mount", "props", "event", "key", "slot", "key", "attr", "prop", "element", "component", "key", "event"]
}
